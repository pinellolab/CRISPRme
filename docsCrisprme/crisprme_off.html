<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1"
    />
    <meta name="generator" content="pdoc 0.8.1" />
    <title>crisprme_off API documentation</title>
    <meta
      name="description"
      content="CRISPRme performs predictive analysis and result assessment on population and individual specific CRISPR/Cas experiments.
CRISPRme enumerates on- and â€¦"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"
      rel="stylesheet"
    />
    <style>
      .flex {
        display: flex !important;
      }
      body {
        line-height: 1.5em;
      }
      #content {
        padding: 20px;
      }
      #sidebar {
        padding: 30px;
        overflow: hidden;
      }
      #sidebar > *:last-child {
        margin-bottom: 2cm;
      }
      .http-server-breadcrumbs {
        font-size: 130%;
        margin: 0 0 15px 0;
      }
      #footer {
        font-size: 0.75em;
        padding: 5px 30px;
        border-top: 1px solid #ddd;
        text-align: right;
      }
      #footer p {
        margin: 0 0 0 1em;
        display: inline-block;
      }
      #footer p:last-child {
        margin-right: 30px;
      }
      h1,
      h2,
      h3,
      h4,
      h5 {
        font-weight: 300;
      }
      h1 {
        font-size: 2.5em;
        line-height: 1.1em;
      }
      h2 {
        font-size: 1.75em;
        margin: 1em 0 0.5em 0;
      }
      h3 {
        font-size: 1.4em;
        margin: 25px 0 10px 0;
      }
      h4 {
        margin: 0;
        font-size: 105%;
      }
      a {
        color: #058;
        text-decoration: none;
        transition: color 0.3s ease-in-out;
      }
      a:hover {
        color: #e82;
      }
      .title code {
        font-weight: bold;
      }
      h2[id^="header-"] {
        margin-top: 2em;
      }
      .ident {
        color: #900;
      }
      pre code {
        background: #f8f8f8;
        font-size: 0.8em;
        line-height: 1.4em;
      }
      code {
        background: #f2f2f1;
        padding: 1px 4px;
        overflow-wrap: break-word;
      }
      h1 code {
        background: transparent;
      }
      pre {
        background: #f8f8f8;
        border: 0;
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        margin: 1em 0;
        padding: 1ex;
      }
      #http-server-module-list {
        display: flex;
        flex-flow: column;
      }
      #http-server-module-list div {
        display: flex;
      }
      #http-server-module-list dt {
        min-width: 10%;
      }
      #http-server-module-list p {
        margin-top: 0;
      }
      .toc ul,
      #index {
        list-style-type: none;
        margin: 0;
        padding: 0;
      }
      #index code {
        background: transparent;
      }
      #index h3 {
        border-bottom: 1px solid #ddd;
      }
      #index ul {
        padding: 0;
      }
      #index h4 {
        margin-top: 0.6em;
        font-weight: bold;
      }
      @media (min-width: 200ex) {
        #index .two-column {
          column-count: 2;
        }
      }
      @media (min-width: 300ex) {
        #index .two-column {
          column-count: 3;
        }
      }
      dl {
        margin-bottom: 2em;
      }
      dl dl:last-child {
        margin-bottom: 4em;
      }
      dd {
        margin: 0 0 1em 3em;
      }
      #header-classes + dl > dd {
        margin-bottom: 3em;
      }
      dd dd {
        margin-left: 2em;
      }
      dd p {
        margin: 10px 0;
      }
      .name {
        background: #eee;
        font-weight: bold;
        font-size: 0.85em;
        padding: 5px 10px;
        display: inline-block;
        min-width: 40%;
      }
      .name:hover {
        background: #e0e0e0;
      }
      .name > span:first-child {
        white-space: nowrap;
      }
      .name.class > span:nth-child(2) {
        margin-left: 0.4em;
      }
      .inherited {
        color: #999;
        border-left: 5px solid #eee;
        padding-left: 1em;
      }
      .inheritance em {
        font-style: normal;
        font-weight: bold;
      }
      .desc h2 {
        font-weight: 400;
        font-size: 1.25em;
      }
      .desc h3 {
        font-size: 1em;
      }
      .desc dt code {
        background: inherit;
      }
      .source summary,
      .git-link-div {
        color: #666;
        text-align: right;
        font-weight: 400;
        font-size: 0.8em;
        text-transform: uppercase;
      }
      .source summary > * {
        white-space: nowrap;
        cursor: pointer;
      }
      .git-link {
        color: inherit;
        margin-left: 1em;
      }
      .source pre {
        max-height: 500px;
        overflow: auto;
        margin: 0;
      }
      .source pre code {
        font-size: 12px;
        overflow: visible;
      }
      .hlist {
        list-style: none;
      }
      .hlist li {
        display: inline;
      }
      .hlist li:after {
        content: ",\2002";
      }
      .hlist li:last-child:after {
        content: none;
      }
      .hlist .hlist {
        display: inline;
        padding-left: 1em;
      }
      img {
        max-width: 100%;
      }
      .admonition {
        padding: 0.1em 0.5em;
        margin-bottom: 1em;
      }
      .admonition-title {
        font-weight: bold;
      }
      .admonition.note,
      .admonition.info,
      .admonition.important {
        background: #aef;
      }
      .admonition.todo,
      .admonition.versionadded,
      .admonition.tip,
      .admonition.hint {
        background: #dfd;
      }
      .admonition.warning,
      .admonition.versionchanged,
      .admonition.deprecated {
        background: #fd4;
      }
      .admonition.error,
      .admonition.danger,
      .admonition.caution {
        background: lightpink;
      }
    </style>
    <style media="screen and (min-width: 700px)">
      @media screen and (min-width: 700px) {
        #sidebar {
          width: 30%;
          height: 100vh;
          overflow: auto;
          position: sticky;
          top: 0;
        }
        #content {
          width: 70%;
          max-width: 100ch;
          padding: 3em 4em;
          border-left: 1px solid #ddd;
        }
        pre code {
          font-size: 1em;
        }
        .item .name {
          font-size: 1em;
        }
        main {
          display: flex;
          flex-direction: row-reverse;
          justify-content: flex-end;
        }
        .toc ul ul,
        #index ul {
          padding-left: 1.5em;
        }
        .toc > ul > li {
          margin-top: 0.5em;
        }
      }
    </style>
    <style media="print">
      @media print {
        #sidebar h1 {
          page-break-before: always;
        }
        .source {
          display: none;
        }
      }
      @media print {
        * {
          background: transparent !important;
          color: #000 !important;
          box-shadow: none !important;
          text-shadow: none !important;
        }
        a[href]:after {
          content: " (" attr(href) ")";
          font-size: 90%;
        }
        a[href][title]:after {
          content: none;
        }
        abbr[title]:after {
          content: " (" attr(title) ")";
        }
        .ir a:after,
        a[href^="javascript:"]:after,
        a[href^="#"]:after {
          content: "";
        }
        pre,
        blockquote {
          border: 1px solid #999;
          page-break-inside: avoid;
        }
        thead {
          display: table-header-group;
        }
        tr,
        img {
          page-break-inside: avoid;
        }
        img {
          max-width: 100% !important;
        }
        @page {
          margin: 0.5cm;
        }
        p,
        h2,
        h3 {
          orphans: 3;
          widows: 3;
        }
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
          page-break-after: avoid;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <article id="content">
        <header>
          <h1 class="title">Module <code>crisprme_off</code></h1>
        </header>
        <section id="section-intro">
          <p>
            CRISPRme performs predictive analysis and result assessment on
            population and individual specific CRISPR/Cas experiments. CRISPRme
            enumerates on- and off-target accounting simultaneously for
            substitutions, DNA/RNA bulges and common genetic variants from the
            1000 genomes project. CRISPRme is based on CRISPRitz (Cancellieri,
            Samuele, et al. "Crispritz: rapid, high-throughput, and
            variant-aware in silico off-target site identification for crispr
            genome editing." Bioinformatics (2019).) a software tool for
            population target analyses. CRISPRme is devoted to individual
            specific on- and off-target analyses.
          </p>
          <p>Documentation updated up to 07/07/2020</p>
          <p>
            Launch crisprme, NOTE - conda must be active when starting the app:
          </p>
          <ul>
            <li>python crisprme_off.py</li>
            <li>gunicorn -b :8080 crisprme_off:app.server</li>
          </ul>
          <p>Generate docs:</p>
          <ul>
            <li>
              pdoc crisprme_off.py -o docsCrisprme/ &ndash;force &ndash;html
            </li>
          </ul>
          <details class="source">
            <summary>
              <span>Expand source code</span>
            </summary>
            <pre><code class="python">&#39;&#39;&#39;
CRISPRme performs predictive analysis and result assessment on population and individual specific CRISPR/Cas experiments. 
CRISPRme enumerates on- and off-target accounting simultaneously for substitutions, DNA/RNA bulges and common genetic variants from the 1000 
genomes project. CRISPRme is based on CRISPRitz (Cancellieri, Samuele, et al. &#34;Crispritz: rapid, high-throughput, and variant-aware in silico off-target site identification for crispr genome editing.&#34; Bioinformatics (2019).) 
a software tool for population target analyses. CRISPRme is devoted to individual specific on- and off-target analyses.

Documentation updated up to 07/07/2020

Launch crisprme, NOTE - conda must be active when starting the app:

+ python crisprme_off.py
+ gunicorn -b :8080 crisprme_off:app.server

Generate docs:

+ pdoc crisprme_off.py -o docsCrisprme/ --force --html
&#39;&#39;&#39;
import dash
from dash.dependencies import Input, Output, State
import dash_core_components as dcc
import dash_html_components as html
import dash_daq as daq
import dash_table
from dash.exceptions import PreventUpdate
from os import listdir                      #for getting directories
from os.path import isfile, isdir,join      #for getting directories
import subprocess
import base64                               #for decoding upload content
import io                                   #for decoding upload content
import pandas as pd                         #for dash table
import json                                 #for getting and saving report images list
from os import getcwd
import time                                 #measure time for loading df table
from flask_caching import Cache             #for cache of .targets or .scores
import os
import string                               #for job id
import random                               #for job id
import sys                                  #for sys.exit()
import filecmp                              #check if Params files are equals
import dash_bootstrap_components as dbc
import collections                          #For check if guides are the same in two results
from datetime import datetime               #For time when job submitted
from seq_script import extract_seq, convert_pam
from additional_pages import help_page
from additional_pages import contacts_page
from additional_pages import genomes_page as gen_page
import re                                   #For sort chr filter values
import concurrent.futures                           #For workers and queue
import math
from PostProcess.supportFunctions.loadSample import associateSample
from PostProcess import CFDGraph
from additional_pages import get_genomes
try:
    from GUI import GUImessage as Gmsg
except ImportError:
    pass
import webbrowser as wb     #Open CRISPRme on browser

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

from tkinter import filedialog, END, IntVar, messagebox

#Warning symbol \u26A0
app_location = os.path.realpath(__file__)
app_main_directory = os.path.dirname(app_location) + &#39;/&#39;    #This for scripts
current_working_directory = os.getcwd() + &#39;/&#39;               #This for files

exeggutor = concurrent.futures.ProcessPoolExecutor(max_workers=2)

PAGE_SIZE = 10                    #number of entries in each page of the table in view report
BARPLOT_LEN = 4                   #number of barplots in each row of Populations Distributions
#Columns for dash datatable in REF search
COL_REF = [&#39;Bulge Type&#39;, &#39;crRNA&#39;, &#39;DNA&#39;, &#39;Chromosome&#39;, &#39;Position&#39;, &#39;Cluster Position&#39; ,&#39;Direction&#39;, &#39;Mismatches&#39;, &#39;Bulge Size&#39;, &#39;Total&#39;, &#39;Annotation Type&#39;]
COL_REF_TYPE = [&#39;text&#39;,&#39;text&#39;,&#39;text&#39;,&#39;text&#39;,&#39;numeric&#39;, &#39;numeric&#39;,&#39;text&#39;,&#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;text&#39;]
COL_REF_RENAME = {0:&#39;Bulge Type&#39;, 1:&#39;crRNA&#39;, 2:&#39;DNA&#39;, 3:&#39;Chromosome&#39;, 4:&#39;Position&#39;, 5:&#39;Cluster Position&#39;, 6:&#39;Direction&#39;,
                7:&#39;Mismatches&#39;, 8:&#39;Bulge Size&#39;, 9:&#39;Total&#39;,10:&#39;Correct Guide&#39;, 11:&#39;Annotation Type&#39;}
#Columns for dash datatable in VAR and BOTH search
COL_BOTH = [&#39;Bulge Type&#39;, &#39;crRNA&#39;, &#39;DNA&#39;, &#39;Chromosome&#39;, &#39;Position&#39;, &#39;Cluster Position&#39;,&#39;Direction&#39;, &#39;Mismatches&#39;, &#39;Bulge Size&#39;, &#39;Total&#39;, &#39;PAM Creation&#39;, &#39;Samples Summary&#39;, &#39;Annotation Type&#39;]
COL_BOTH_TYPE = [&#39;text&#39;,&#39;text&#39;,&#39;text&#39;,&#39;text&#39;,&#39;numeric&#39;,&#39;numeric&#39;, &#39;text&#39;,&#39;numeric&#39;, &#39;numeric&#39;, &#39;numeric&#39;, &#39;text&#39;, &#39;text&#39;, &#39;text&#39;]
COL_BOTH_RENAME = {0:&#39;Bulge Type&#39;, 1:&#39;crRNA&#39;, 2:&#39;DNA&#39;, 3:&#39;Chromosome&#39;, 4:&#39;Position&#39;, 5:&#39;Cluster Position&#39;, 6:&#39;Direction&#39;,
        7:&#39;Mismatches&#39;, 8:&#39;Bulge Size&#39;, 9:&#39;Total&#39;, 10:&#39;PAM Creation&#39;, 11 : &#39;Variant Unique&#39;, 12:&#39;Samples&#39;, 13:&#39;Annotation Type&#39;, 14:&#39;Correct Guide&#39;}
GENOME_DATABASE = [&#39;Reference&#39;, &#39;Enriched&#39;, &#39;Samples&#39;, &#39;Dictionary&#39;, &#39;Annotation&#39;]
ONLINE = False              #NOTE change to True for online version, False for offline
if ONLINE:
    DISPLAY_OFFLINE = &#39;none&#39;
    DISPLAY_ONLINE = &#39;&#39;
else:
    DISPLAY_OFFLINE = &#39;&#39;
    DISPLAY_ONLINE = &#39;none&#39;
VALID_CHARS = {&#39;a&#39;, &#39;A&#39;, &#39;t&#39;, &#39;T&#39;, &#39;c&#39;, &#39;C&#39;,&#39;g&#39;, &#39;G&#39;,
            &#34;R&#34;,
            &#34;Y&#34;,
            &#34;S&#34;,
            &#34;W&#34;,
            &#34;K&#34;,
            &#34;M&#34;,
            &#34;B&#34; ,
            &#34;D&#34; ,
            &#34;H&#34; ,
            &#34;V&#34; ,
            &#34;r&#34;,
            &#34;y&#34;,
            &#34;s&#34;,
            &#34;w&#34;,
            &#34;k&#34;,
            &#34;m&#34;,
            &#34;b&#34; ,
            &#34;d&#34; ,
            &#34;h&#34; ,
            &#34;v&#34;
            }
URL = &#39;http://157.27.85.10:8050&#39;       #Change for online version
external_stylesheets = [&#39;https://codepen.io/chriddyp/pen/bWLwgP.css&#39;, dbc.themes.BOOTSTRAP]
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

app.title = &#39;CRISPRme&#39;
app.config[&#39;suppress_callback_exceptions&#39;] = True       #necessary if update element in a callback generated in another callback
app.css.config.serve_locally = True
app.scripts.config.serve_locally = True
CACHE_CONFIG = {
    # try &#39;filesystem&#39; if you don&#39;t want to setup redis
    &#39;CACHE_TYPE&#39;: &#39;filesystem&#39;,
    &#39;CACHE_DIR&#39;: (&#39;Cache&#39;)#os.environ.get(&#39;REDIS_URL&#39;, &#39;localhost:6379&#39;)
}
cache = Cache()
cache.init_app(app.server, config=CACHE_CONFIG)
app_location = os.path.dirname(os.path.abspath(__file__)) + &#39;/&#39;
operators = [[&#39;ge &#39;, &#39;&gt;=&#39;],
             [&#39;le &#39;, &#39;&lt;=&#39;],
             [&#39;lt &#39;, &#39;&lt;&#39;],
             [&#39;gt &#39;, &#39;&gt;&#39;],
             [&#39;ne &#39;, &#39;!=&#39;],
             [&#39;eq &#39;, &#39;=&#39;],
             [&#39;contains &#39;]]     #for filtering

#Populations 1000 gen proj
# population_1000gp = {
#     &#39;EAS&#39;:[&#39;CHB&#39;, &#39;JPT&#39;, &#39;CHS&#39;, &#39;CDX&#39;, &#39;KHV&#39;],
#     &#39;EUR&#39;:[&#39;CEU&#39;, &#39;TSI&#39;, &#39;FIN&#39;, &#39;GBR&#39;, &#39;IBS&#39;],
#     &#39;AFR&#39;:[&#39;YRI&#39;, &#39;LWK&#39;, &#39;GWD&#39;, &#39;MSL&#39;, &#39;ESN&#39;, &#39;ASW&#39;, &#39;ACB&#39;],
#     &#39;AMR&#39;:[&#39;MXL&#39;, &#39;PUR&#39;, &#39;CLM&#39;, &#39;PEL&#39;],
#     &#39;SAS&#39;:[&#39;GIH&#39;, &#39;PJL&#39;, &#39;BEB&#39;, &#39;STU&#39;, &#39;ITU&#39;]
# }
# dict_pop_to_superpop = {&#39;CHB&#39;:&#39;EAS&#39;, &#39;JPT&#39;:&#39;EAS&#39;, &#39;CHS&#39;:&#39;EAS&#39;, &#39;CDX&#39;:&#39;EAS&#39;, &#39;KHV&#39;:&#39;EAS&#39;,
#                     &#39;CEU&#39;:&#39;EUR&#39;, &#39;TSI&#39;:&#39;EUR&#39;, &#39;FIN&#39;:&#39;EUR&#39;, &#39;GBR&#39;:&#39;EUR&#39;, &#39;IBS&#39;:&#39;EUR&#39;,
#                     &#39;YRI&#39;:&#39;AFR&#39;, &#39;LWK&#39;:&#39;AFR&#39;, &#39;GWD&#39;:&#39;AFR&#39;, &#39;MSL&#39;:&#39;AFR&#39;, &#39;ESN&#39;:&#39;AFR&#39;, &#39;ASW&#39;:&#39;AFR&#39;, &#39;ACB&#39;:&#39;AFR&#39;,
#                     &#39;MXL&#39;:&#39;AMR&#39;, &#39;PUR&#39;:&#39;AMR&#39;, &#39;CLM&#39;:&#39;AMR&#39;, &#39;PEL&#39;:&#39;AMR&#39;,
#                     &#39;GIH&#39;:&#39;SAS&#39;, &#39;PJL&#39;:&#39;SAS&#39;, &#39;BEB&#39;:&#39;SAS&#39;, &#39;STU&#39;:&#39;SAS&#39;, &#39;ITU&#39;:&#39;SAS&#39;
# }
#List of all samples
# pop_file = pd.read_excel(os.path.dirname(os.path.realpath(__file__)) + &#39;/PostProcess/20130606_sample_info.xlsx&#39;)
# all_samples = pop_file.Sample.to_list()
# all_pop = pop_file.Population.to_list()
# dict_pop = dict()
# dict_sample_to_pop = dict()
# for  pos, i in enumerate(all_pop):
    # try:
    #     dict_pop[i].append(all_samples[pos])
    # except:
    #     dict_pop[i] = [all_samples[pos]]
    
    # dict_sample_to_pop[all_samples[pos]] = i
# dropdown_all_samples = [{&#39;label&#39;: sam, &#39;value&#39; : sam} for sam in all_samples]
#Dropdown available genomes
def availableGenomes():
    &#39;&#39;&#39;
    Returns a list of dictionaries of the available genomes in the &#39;Genomes&#39; directory.

    ***Returns***

    + **gen_dir** (*list* of {&#39;label&#39;: genome, &#39;value&#39;: genome}): list containing a series of dictionaries, one for each directory (genome) found in
    the &#39;Genomes&#39; directory. Used as input parameter for the &#39;options&#39; element of a Dash Droplist 
    &#39;&#39;&#39;
    onlydir = [f for f in listdir(current_working_directory + &#39;Genomes&#39;) if isdir(join(current_working_directory + &#39;Genomes&#39;, f))]
    onlydir = [x.replace(&#39;_&#39;, &#39; &#39;) for x in onlydir]
    gen_dir = []
    for dir in onlydir:
        gen_dir.append({&#39;label&#39;: dir, &#39;value&#39; : dir})
    return gen_dir

#Dropdown available PAM
def availablePAM():
    &#39;&#39;&#39;
    Returns a list of dictionaries of the available PAMs in the &#39;PAM&#39; directory.

    ***Returns***
    
    + **pam_file** (*list* of {&#39;label&#39;: pam, &#39;value&#39;: pam}): list containing a series of dictionaries, one for each PAM file found in
        the &#39;PAM&#39; directory. Used as input parameter for the &#39;options&#39; element of a Dash Droplist
    &#39;&#39;&#39;
    onlyfile = [f for f in listdir(current_working_directory + &#39;pam&#39;) if isfile(join(current_working_directory + &#39;pam&#39;, f))]
    onlyfile = [x.replace(&#39;.txt&#39;, &#39;&#39;) for x in onlyfile]            #removed .txt for better visualization
    pam_file = []
    for pam_name in onlyfile:
        if &#39;tempPAM&#39; in pam_name:   #Skip the temp pam used for updating dictionaries
            pass
        else:
            pam_file.append({&#39;label&#39;:pam_name, &#39;value&#39;:pam_name})
    return pam_file

#Available mismatches and bulges
if ONLINE:
    set_max_mms = 7
    set_max_bulges = 3
else:
    set_max_mms = 7             #NOTE modify value for increasing/decreasing max mms or bulges available on Dropdown selection
    set_max_bulges = 3

av_mismatches = [{&#39;label&#39;: i, &#39;value&#39;: i} for i in range(0, set_max_mms)]
av_bulges = [{&#39;label&#39;: i, &#39;value&#39;: i} for i in range(0, set_max_bulges)]
av_guide_sequence = [{&#39;label&#39;: i, &#39;value&#39;: i} for i in range(15, 26)]
search_bar = dbc.Row(
    [
        #dbc.Col(dbc.Input(type=&#34;search&#34;, placeholder=&#34;Search&#34;)),
        dbc.Col(dbc.NavLink(
            html.A(&#39;HOME&#39;, href = URL, target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;}), 
            active = True, 
            className= &#39;testHover&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;, &#39;font-size&#39;:&#39;1.5rem&#39;})),
        dbc.Col(dbc.NavLink(
            html.A(&#39;MANUAL&#39;, href = URL + &#39;/user-guide&#39;,target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;}), 
            active = True, 
            className= &#39;testHover&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;, &#39;font-size&#39;:&#39;1.5rem&#39;})),
        dbc.Col(dbc.NavLink(
            html.A(&#39;CONTACTS&#39;, href = URL + &#39;/contacts&#39;, target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;}),
            active = True, 
            className= &#39;testHover&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;, &#39;font-size&#39;:&#39;1.5rem&#39;})),
        dbc.Col(dbc.NavLink(
            html.A(&#39;GENOMES&#39;, href = URL + &#39;/genomes&#39;, target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;}),
            active = True, 
            className= &#39;testHover&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;, &#39;font-size&#39;:&#39;1.5rem&#39;, &#39;display&#39;:DISPLAY_OFFLINE})),
        dbc.Col(dbc.NavLink(
            html.A(&#39;HISTORY&#39;, href = URL + &#39;/history&#39;, target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;}),
            active = True, 
            className= &#39;testHover&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;white&#39;, &#39;font-size&#39;:&#39;1.5rem&#39;, &#39;display&#39;:DISPLAY_OFFLINE}))
    ],
    no_gutters=True,
    className=&#34;ml-auto flex-nowrap mt-3 mt-md-0&#34;,
    align=&#34;center&#34;,
)
PLOTLY_LOGO = &#39;assets/37143442.png&#39;#&#34;https://images.plot.ly/logo/new-branding/plotly-logomark.png&#34;   


navbar = dbc.Navbar(
    [
        html.A(
            # Use row and col to control vertical alignment of logo / brand
            dbc.Row(
                [
                    dbc.Col(html.Img(src=PLOTLY_LOGO, height=&#34;60px&#34;)),
                    dbc.Col(dbc.NavbarBrand(&#34;CRISPRme&#34;, className=&#34;ml-2&#34;, style = {&#39;font-size&#39;: &#39;30px&#39;}))
                ],
                align=&#34;center&#34;,
                no_gutters=True,
            ),
            href=URL,
        ),
        dbc.NavbarToggler(id=&#34;navbar-toggler&#34;),
        dbc.Collapse(search_bar, id=&#34;navbar-collapse&#34;, navbar=True),
    ],
    color=&#34;dark&#34;,
    dark=True,
)

#For multipage
app.layout = html.Div([
    navbar,
    dcc.Location(id=&#39;url&#39;, refresh=False),
    html.Div(id=&#39;page-content&#39;),
    html.P(id = &#39;signal&#39;, style = {&#39;visibility&#39;:&#39;hidden&#39;})
])



#Main Page
def indexPage():
    &#39;&#39;&#39;
    Creates the layout of the main page (&#39;/&#39;). The creation of the main page is put under a function in order to reload the genome and pam dropdown
    if a new genome is added, simply by reloading the page.

    ***Returns***

    + **index_page** (*list*): list of html, dcc and dbc components for the layout.
    &#39;&#39;&#39;
    final_list = []
    final_list.extend([
        html.Div([
            &#39;CRISPRme  performs  predictive analysis and result assessment on population and individual specific CRISPR/Cas experiments.&#39; +  
            &#39; CRISPRme enumerates on- and off-target accounting simultaneously for  substitutions, DNA/RNA bulges and common genetic variants from the 1000 genomes project.&#39;+
            &#39; CRISPRme is based on CRISPRitz [1] a software tool for population target analyses.&#39;  
        + &#39; CRISPRme is devoted to individual specific on- and off-target analyses.&#39;
        ]),
        ])

    final_list.append(
        html.Div(
            [
                # html.P([&#39;Download the offline version here: &#39;, html.A(&#39;InfOmics/CRISPRitz&#39;, href = &#39;https://github.com/InfOmics/CRISPRitz&#39;, target=&#34;_blank&#34;), &#39; or &#39;, html.A(&#39;Pinellolab/CRISPRitz&#39;, href = &#39;https://github.com/pinellolab/CRISPRitz&#39;, target=&#34;_blank&#34;) ])
                html.Br()
            ]
        )
    )
    checklist_div = html.Div(
        [
            dbc.FormGroup(
                [
                    dbc.Checkbox(
                        id=&#34;checkbox-gecko&#34;, className=&#34;form-check-input&#34;, checked = True
                    ),
                    dbc.Label(
                        #html.P([&#39;Activate Gecko &#39;, html.Abbr(&#39;comparison&#39;, title =&#39;The results of your test guides will be compared with results obtained from a previous computed analysis on gecko library&#39;)]) ,
                        html.P(&#39;Compare your results with the GeCKO v2 library&#39;),
                        html_for=&#34;checkbox-gecko&#34;,
                        className=&#34;form-check-label&#34;,
                    ),
                    dbc.Checkbox(
                        id=&#34;checkbox-ref-comp&#34;, className=&#34;form-check-input&#34;
                    ),
                    dbc.Label(
                        html.P(&#39;Compare your results with the corresponding reference genome&#39;),
                        html_for=&#34;checkbox-ref-comp&#34;,
                        className=&#34;form-check-label&#34;,
                    )
                    
                ],
                check = True
            )
        ],
        id = &#39;checklist-test-div&#39;
    )

    modal = html.Div(
        [
            dbc.Modal(
                [
                    dbc.ModalHeader(&#34;WARNING! Missing inputs&#34;),
                    dbc.ModalBody(&#39;The following inputs are missing, please select values before submitting the job&#39;, id = &#39;warning-list&#39;),
                    dbc.ModalFooter(
                        dbc.Button(&#34;Close&#34;, id=&#34;close&#34; , className=&#34;modal-button&#34;)
                    ),
                ],
                id=&#34;modal&#34;,
                centered=True
            ),
        ]
    )

    tab_guides_content = html.Div(
        [
            html.P([
                &#39;Insert crRNA sequence(s), one per line.&#39;, 
                html.P(&#39;Sequences must have the same length and be provided without the PAM sequence&#39;, id = &#39;testP&#39;) ,
            ],
            style = {&#39;word-wrap&#39;: &#39;break-word&#39;}), 

            dcc.Textarea(id = &#39;text-guides&#39;, placeholder = &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;, style = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;, &#39;font-family&#39;:&#39;monospace&#39;, &#39;font-size&#39;:&#39;large&#39;}),
            dbc.FormText(&#39;Note: a maximum number of 1000 sequences can be provided&#39;, color = &#39;secondary&#39;)
        ],
        style = {&#39;width&#39;:&#39;450px&#39;} #NOTE same as text-area
    )
    tab_sequence_content = html.Div(
        [
            html.P([&#39;Search crRNAs by inserting one or more genomic sequences.&#39;, html.P(&#39;Chromosome ranges can also be supplied&#39;)],
            style = {&#39;word-wrap&#39;: &#39;break-word&#39;}), 

            dcc.Textarea(id = &#39;text-sequence&#39;, placeholder = &#39;&gt;sequence 1\nAAGTCCCAGGACTTCAGAAGagctgtgagaccttggc\n&gt;sequence2\nchr1:11,130,540-11,130,751&#39;, style = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;, &#39;font-family&#39;:&#39;monospace&#39;, &#39;font-size&#39;:&#39;large&#39;}),
            dbc.FormText(&#39;Note: a maximum number of 1000 characters can be provided&#39;, color = &#39;secondary&#39;)
        ],
        style = {&#39;width&#39;:&#39;450px&#39;} #NOTE same as text-area
    )
    final_list.append(
        html.Div(
            html.Div(
                [
                    modal,
                    html.Div(
                        [
                            html.Div([
                                html.H3(&#39;STEP 1&#39;, style = {&#39;margin-top&#39;:&#39;0&#39;}),
                                html.Div([
                                    html.P([html.Button(html.P(&#34;Load example&#34;, style={&#39;color&#39;:&#39;rgb(46,140,187)&#39;,&#39;text-decoration-line&#39;: &#39;underline&#39;, &#39;font-size&#39;:&#39;initial&#39;}), id=&#39;example-parameters&#39;,
                                                style={ &#39;border&#39;: &#39;None&#39;, &#39;text-transform&#39;: &#39;capitalize&#39;,&#39;height&#39;:&#39;12&#39;,&#39;font-weight&#39;: &#39;500&#39;, &#39;padding&#39;: &#39;0 0px&#39;,&#39;textcolor&#39;:&#39;blu&#39;}), &#39; - &#39;,
                                    #html.Br(),
                                    html.Button(html.P(children=&#34;Reset&#34;, style={&#39;color&#39;:&#39;rgb(46,140,187)&#39;,&#39;text-decoration-line&#39;: &#39;underline&#39;,&#39;font-size&#39;:&#39;initial&#39;}), id=&#39;remove-parameters&#39;,
                                                style={&#39;border&#39;: &#39;None&#39;, &#39;text-transform&#39;: &#39;capitalize&#39;,&#39;height&#39;:&#39;12&#39;,&#39;font-weight&#39;: &#39;500&#39;, &#39;padding&#39;: &#39;0 0px&#39;})])
                                ], style = {&#39;display&#39;:DISPLAY_ONLINE})
                            ], className = &#39;flex-div-insert-delete-example&#39;), 
                            
                            html.P(html.P(&#39;Select a genome&#39;) ),
                            html.Div(
                                dcc.Dropdown(options = availableGenomes(), clearable = False, id = &#34;available-genome&#34;,) #style = {&#39;width&#39;:&#39;75%&#39;})
                            ),
                            dbc.FormText(&#39;Note: Genomes enriched with variants are indicated with a \&#39;+\&#39; symbol&#39;, color=&#39;secondary&#39;),
                            
                            html.Div(
                                [
                                    html.Div(
                                        [
                                            html.P(html.P(&#39;Select PAM&#39;)),
                                            html.Div(
                                                dcc.Dropdown(options = availablePAM(), clearable = False, id = &#39;available-pam&#39;)
                                            )
                                        ],
                                        style = {&#39;flex&#39;:&#39;0 0 100%&#39;, &#39;margin-top&#39;: &#39;10%&#39;}
                                    )
                                ],
                                id = &#39;div-pam&#39;,
                                className = &#39;flex-div-pam&#39;
                            ),
                            html.Br(),
                            html.Button(&#34;Add New Genome&#34;, id = &#39;add-genome&#39;, style = {&#39;margin-right&#39;:&#39;5px&#39;, &#39;display&#39;:DISPLAY_OFFLINE}),
                            html.Div(&#39;&#39;, id = &#39;genome-job&#39;, style = {&#39;display&#39;:&#39;none&#39;}),
                            html.Button(&#34;Update dictionary&#34;, id = &#39;update-dict&#39;, style = {&#39;margin-left&#39;:&#39;5px&#39;, &#39;display&#39;:DISPLAY_OFFLINE}),
                            html.Div(&#39;&#39;, id = &#39;dict-job&#39;, style = {&#39;display&#39;:&#39;none&#39;}),
                            html.Div(
                                [
                                    html.Ul(
                                        [html.Li(
                                            [html.A(&#39;Contact us&#39;, href = URL + &#39;/contacts&#39;, target=&#34;_blank&#34;),&#39; to request new genomes availability in the dropdown list&#39;],
                                            style = {&#39;margin-top&#39;:&#39;5%&#39;, &#39;display&#39;: DISPLAY_ONLINE}
                                        ),
                                        ],
                                        style = {&#39;list-style&#39;:&#39;inside&#39;}
                                    ),
                                ],
                                style = {&#39;height&#39;:&#39;50%&#39;}
                            ),
                        ],
                        id = &#39;step1&#39;,
                        style = {&#39;flex&#39;:&#39;0 0 30%&#39;, &#39;tex-align&#39;:&#39;center&#39;}
                    ),
                    html.Div(style = {&#39;border-right&#39;:&#39;solid 1px white&#39;}),
                    html.Div(
                        [
                            html.H3(&#39;STEP 2&#39;, style = {&#39;margin-top&#39;:&#39;0&#39;}),
                            html.Div(
                                [
                                    html.Div(
                                        [   html.P(&#39;Select the input type&#39;),
                                            dbc.Tabs(
                                                [
                                                    dbc.Tab(tab_guides_content, label=&#39;Guides&#39;, tab_id= &#39;guide-tab&#39;),
                                                    dbc.Tab(tab_sequence_content, label=&#39;Sequence&#39;, tab_id = &#39;sequence-tab&#39;)
                                                ],
                                                active_tab=&#39;guide-tab&#39;,
                                                id = &#39;tabs&#39;
                                            )
                                        ],
                                        id = &#39;div-guides&#39;
                                    ),
                                    html.Div(
                                        [
                                            html.P(&#39;Allowed mismatches&#39;),
                                            dcc.Dropdown(options = av_mismatches, clearable = False, id = &#39;mms&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            html.P(&#39;Bulge DNA size&#39;),
                                            dcc.Dropdown(options = av_bulges, clearable = False, id = &#39;dna&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            html.P(&#39;Bulge RNA size&#39;),
                                            dcc.Dropdown(options = av_bulges, clearable = False, id = &#39;rna&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            dbc.Fade(
                                                [
                                                    html.P(&#39;crRNA length (without PAM)&#39;),
                                                    dcc.Dropdown(options = av_guide_sequence, clearable = False, id = &#39;len-guide-sequence-ver&#39;, style = {&#39;width&#39;:&#39;60px&#39;})
                                                ],
                                                id = &#39;fade-len-guide&#39;, is_in= False, appear= False
                                            )
                                        ]
                                    )
                                ],
                                className = &#39;flex-step2&#39;
                            )

                        ],
                        id = &#39;step2&#39;,
                        style = {&#39;flex&#39;:&#39;0 0 40%&#39;}
                        
                    ),
                    html.Div(style = {&#39;border-right&#39;:&#39;solid 1px white&#39;}),
                    html.Div(
                        [
                            html.H3(&#39;Advanced Options&#39;, style = {&#39;margin-top&#39;:&#39;0px&#39;}),
                            checklist_div,
                            dcc.Checklist(
                                options = [
                                    {&#39;label&#39;:&#39;Notify me by email&#39;,&#39;value&#39;:&#39;email&#39;, &#39;disabled&#39;:False}
                                ], 
                                id = &#39;checklist-advanced&#39;,
                                style = {&#39;display&#39;: DISPLAY_ONLINE}
                            ),
                            dbc.Fade(
                                [
                                    dbc.FormGroup(
                                        [
                                            dbc.Label(&#34;Email&#34;, html_for=&#34;example-email&#34;),
                                            dbc.Input(type=&#34;email&#34;, id=&#34;example-email&#34;, placeholder=&#34;Enter email&#34;, className=&#39;exampleEmail&#39;)
                                        ]
                                    )
                                ],
                                id = &#39;fade&#39;, is_in= False, appear= False, 
                            ),
                            html.Div(
                                [
                                    html.Button(&#39;Submit&#39;, id = &#39;check-job&#39;, style = {&#39;background-color&#39;:&#39;skyblue&#39;}),
                                    html.Button(&#39;&#39;, id = &#39;submit-job&#39;, style = {&#39;display&#39;:&#39;none&#39;})
                                ],
                                style = {&#39;display&#39;:&#39;inline-block&#39;, &#39;margin&#39;:&#39;0 auto&#39;}   #style=&#34;height:55px; width:150px&#34;
                            )
                        ],
                        id = &#39;step3&#39;,
                        style = {&#39;tex-align&#39;:&#39;center&#39;},
                        className = &#39;flex-step3&#39;
                    )
                ],
                id = &#39;div-steps&#39;,
                style = {&#39;margin&#39;:&#39;1%&#39;},
                className = &#39;flex-div-steps&#39;
            ),
            style = {&#39;background-color&#39;:&#39;rgba(154, 208, 150, 0.39)&#39;, &#39;border-radius&#39;: &#39;10px&#39;, &#39;border&#39;:&#39;1px solid black&#39;},
            id = &#39;steps-background&#39;
        )
    )
    final_list.append(html.Br())
    final_list.append(html.P(&#39;[1] Cancellieri, Samuele, et al. \&#34;Crispritz: rapid, high-throughput, and variant-aware in silico off-target site identification for crispr genome editing.\&#34; Bioinformatics (2019).&#39;))
    final_list.append(
        html.P([&#39;Download CRISPRitz here: &#39;, html.A(&#39;InfOmics/CRISPRitz&#39;, href = &#39;https://github.com/InfOmics/CRISPRitz&#39;, target=&#34;_blank&#34;), &#39; or &#39;, html.A(&#39;Pinellolab/CRISPRitz&#39;, href = &#39;https://github.com/pinellolab/CRISPRitz&#39;, target=&#34;_blank&#34;) ])
    )
    index_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return index_page

#Load Page
final_list = []
final_list.append(
    html.Div(
        html.Div(
            html.Div(
                [
                    html.P(&#39;Job submitted. Copy this link to view the status and the result page &#39;),
                    html.Div(
                        html.P(&#39;link&#39;, id = &#39;job-link&#39;, style = {&#39;margin-top&#39;:&#39;0.75rem&#39;, &#39;font-size&#39;:&#39;large&#39;}),
                        style = {&#39;border-radius&#39;:&#39;5px&#39;,&#39;border&#39;:&#39;2px solid&#39;, &#39;border-color&#39;:&#39;blue&#39; ,&#39;width&#39;:&#39;100%&#39;,&#39;display&#39;:&#39;inline-block&#39;, &#39;margin&#39;:&#39;5px&#39;}
                    ),
                    html.P(&#39;Results will be kept available for 3 days&#39;)
                ],
                style = {&#39;display&#39;:&#39;inline-block&#39;}
            ),
            style = {&#39;display&#39;:&#39;inline-block&#39;,&#39;background-color&#39;:&#39;rgba(154, 208, 150, 0.39)&#39;, &#39;border-radius&#39;: &#39;10px&#39;, &#39;border&#39;:&#39;1px solid black&#39;, &#39;width&#39;:&#39;70%&#39;}
        ),
        style = {&#39;text-align&#39;:&#39;center&#39;}
    )
)

final_list.append(
    html.Div(
        [
            html.H4(&#39;Status report&#39;),
            html.Div(
                [
                    html.Div(
                        html.Ul(
                            [
                                html.Li(&#39;Searching crRNA&#39;),
                                html.Li(&#39;Processing data&#39;),
                                #html.Li(&#39;Annotating result&#39;),
                                html.Li(&#39;Generating report&#39;)
                            ]
                        ),
                        style = {&#39;flex&#39;:&#39;0 0 20%&#39;}
                    ),
                    html.Div(
                        html.Ul(
                            [
                                html.Li(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}, id = &#39;search-status&#39;),
                                html.Li(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}, id = &#39;post-process-status&#39;),
                                #html.Li(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}, id = &#39;annotate-result-status&#39;),
                                html.Li(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}, id = &#39;generate-report-status&#39;)
                            ],
                            style = {&#39;list-style-type&#39;:&#39;none&#39;}
                        )
                    )
                ],
                className = &#39;flex-status&#39;
            ),
            html.Div(
                [
                    dcc.Link(&#39;View Results&#39;, style = {&#39;visibility&#39;:&#39;hidden&#39;}, id = &#39;view-results&#39;, href = URL),
                    html.Div(id = &#39;no-directory-error&#39;)
                ]
            )
        ],
        id = &#39;div-status-report&#39;
    )
)

final_list.append(html.P(&#39;&#39;, id = &#39;done&#39;))


final_list.append(dcc.Interval(id = &#39;load-page-check&#39;, interval=3*1000))
load_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})


#Test page, go to /test-page to see 
def test_page():
    final_list = []
    final_list.append(html.Div(id=&#39;test-div-for-button&#39;))
    final_list.append(
        html.H3(&#39;Genomes&#39;)
    )
    final_list.append(
        html.P(&#39;Select one of the two available Tabs and fill in the field to add a new Genome or to update and existing dictionary.&#39;)
    )

    #Check if an already processing add new genome is currently active. If yes, set the button to be disabled
    already_processing = False
    status_label = &#39;Status: No Job Submitted&#39;
    status_value = 0
    style_disabled = {}
    if isfile(current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39; ):
        already_processing = True
        style_disabled = {&#39;background-color&#39;:&#39;darkgrey&#39;}
        with open(current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39;) as info_status:
            status_general = next(info_status).strip().split(&#39; &#39;) #Get current step number [0] and step name [1] on accessing page for first time
            status_label = &#39;Status: &#39; + status_general[1]
            status_value = int(status_general[0]) * 25

    new_genome_content = html.Div(
        [
            html.Br(),
            html.P(&#39;1) Select a Reference Genome&#39;),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Reference Genome Directory&#39;, id = &#39;button-select-refgenome&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-referencegenome&#39;))
                                ]
                            )  
                        ]
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select PAM File&#39;, id = &#39;button-select-pam&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-pamfile&#39;))
                                ]
                            )  
                        ]
                    ),
                    
                ]
            ),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Annotation File&#39;, id = &#39;button-select-annotation&#39;)), 
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-annotationfile&#39;))
                                ]
                            ),
                            
                        ]
                    ),
                    dbc.Col(
                            dbc.Row(
                                [
                                    dbc.Col(dcc.Input(placeholder = &#39;Select number of max Bulges&#39;, type = &#39;number&#39;, min = 0, id = &#39;input-max-bulges&#39;))
                                ]
                            )
                        )

                ]
            ),
            html.Hr(),
            html.P(&#39;2) (Optional) Enrich the previously selected Reference Genome with samples informations&#39;),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select VCFs Directory&#39;, id = &#39;button-select-vcf&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-vcf&#39;))
                                ]
                            )  
                        ]
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Samples ID File&#39;, id = &#39;button-select-sampleID&#39;)), 
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-sampleIDfile&#39;))
                                ]
                            ),
                            
                        ]
                    )
                ]
            ),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        dbc.Row(
                            [
                                dbc.Col(html.P(&#39;Enriched Genome Name&#39;)),
                                dbc.Col(dcc.Input(placeholder = &#39;Example: 1000genomeproject&#39;, id = &#39;input-enriched-name&#39;))
                            ]
                        )
                    )
                ]
            ),
            html.Hr(),
            dbc.Row(
                [
                    dbc.Col(
                        html.Button(&#39;Start add new genome&#39;, id = &#39;button-add-new-genome&#39;, disabled = already_processing, style = style_disabled)
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                dbc.Col(
                                    html.P(status_label, id = &#39;status-add-new-genome&#39;)
                                )
                            ),
                            dbc.Row(
                                dbc.Col(
                                    html.Div(
                                        [
                                            dbc.Progress(value = status_value, id = &#39;progress-add-new-genome&#39;),
                                            dcc.Interval(interval = 30*1000,id=&#39;interval-add-new-genome&#39;)
                                        ]
                                    )
                                )
                            )
                        ]
                    )
                ]
            )
        ]
    )

    update_dictionary_content = html.Div() #TODO finire con layout simile a quello per aggiungere nuovo genoma

    final_list.append(
        dbc.Tabs(
            [
                dbc.Tab(new_genome_content, label=&#39;Add New Genome&#39;, tab_id= &#39;add-genome-tab&#39;),
                dbc.Tab(update_dictionary_content, label=&#39;Update Dictionary&#39;, tab_id = &#39;update-dictionary&#39;)
            ],
            active_tab=&#39;add-genome-tab&#39;,
            id = &#39;tabs-new-genome-or-dictionary&#39;
        )
    )

    final_list.append(html.Div(id = &#39;div-targetoutput&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
# test_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

#TEST PAGE 2
final_list = []

test_page2 = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

#TEST page3 for new result page
final_list = []

test_page3 = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

#ABOUT PAGE

about_page =  html.Div(help_page.helpPage(), style = {&#39;margin&#39;:&#39;1%&#39;})
#Contacts page
final_list = []
contacts_page =  html.Div(contacts_page.contactPage(), style = {&#39;margin&#39;:&#39;1%&#39;})



##################################################CALLBACKS##################################################
#Test callbacks


#General function for selecting a Directory or a file
def openDialog(n, type_ask, start_dir = &#39;./&#39;):
    if n is None:
        raise PreventUpdate
    root = tk.Tk()
    root.withdraw()
    if type_ask == &#39;D&#39;:
        selected = filedialog.askdirectory(initialdir = current_working_directory + start_dir)
    else:
        selected = filedialog.askopenfilename(initialdir = current_working_directory + start_dir)
    root.destroy()
    if selected == &#39;&#39; or selected == &#39;()&#39;:
        selected = &#39;None&#39;
    return str(selected)

#Callbacks for generating filebrowser for addition of new genome
@app.callback(
    Output(&#39;selected-referencegenome&#39;, &#39;children&#39;),
    [Input(&#39;button-select-refgenome&#39;,&#39;n_clicks&#39;)]
)
def fileDialogRefGenome(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;D&#39;,&#39;Genomes&#39;)

@app.callback(
    Output(&#39;selected-pamfile&#39;, &#39;children&#39;),
    [Input(&#39;button-select-pam&#39;,&#39;n_clicks&#39;)]
)
def fileDialogPam(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;) 

@app.callback(
    Output(&#39;selected-annotationfile&#39;, &#39;children&#39;),
    [Input(&#39;button-select-annotation&#39;,&#39;n_clicks&#39;)]
)
def fileDialogAnnotation(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;,&#39;annotations&#39;) 

@app.callback(
    Output(&#39;selected-vcf&#39;, &#39;children&#39;),
    [Input(&#39;button-select-vcf&#39;,&#39;n_clicks&#39;)]
)
def fileDialogVCF(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;D&#39;)

@app.callback(
Output(&#39;selected-sampleIDfile&#39;, &#39;children&#39;),
[Input(&#39;button-select-sampleID&#39;,&#39;n_clicks&#39;)]
)
def fileDialogSamplesID(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;,&#39;samplesID&#39;)  

#Callback creazione nuovo genoma
@app.callback(
    Output(&#39;div-targetoutput&#39;,&#39;children&#39;),
    [Input(&#39;button-add-new-genome&#39;, &#39;n_clicks&#39;)]
)
def startAddNewGenome(n):
    if n is None:
        raise PreventUpdate
    #TODO: prende gli state dei valori selezionati dall&#39;utente e controlla se sono stati tutti selezionati, altrimenti fa comparire un 
    #avviso che manca qualcosa (cfr. funzione checkInput, ma basta solo avere l&#39;elenco dei campi da compilare)
    #...
    #...

    #input corretti
    #Faccio un subprocess.Popen facendo partire lo script per generare il nuovo genoma
    #Lo script.sh crea un file nella cartella Genomes chiamato &#39;status_creation_nomegenoma.txt&#39; dove nomegenoma Ã¨ ref o enr in base alla
    #selezione dell&#39;utente
    #In questo script faccio echo dei vari step in cui sono in questo momento con l&#39;analisi, in modo poi da leggere questo file e con un interval
    #dire all&#39;utente a che punto siamo
    print(&#39;Button clicked&#39;)
    subprocess.Popen([app_main_directory + &#39;PostProcess/aggiunta_genoma_test_script.sh&#39;, current_working_directory])
    return &#39;&#39;

#Callback per aggiornare la barra progresso
@app.callback(
    [Output(&#39;progress-add-new-genome&#39;, &#39;value&#39;),
    Output(&#39;status-add-new-genome&#39;,&#39;children&#39;),
    Output(&#39;button-add-new-genome&#39;, &#39;disabled&#39;),
    Output(&#39;button-add-new-genome&#39;, &#39;style&#39;)],
    [Input(&#39;interval-add-new-genome&#39;,&#39;n_intervals&#39;),
    Input(&#39;button-add-new-genome&#39;,&#39;n_clicks&#39;)]
)
def updateStatusCreateNewGenome(n, n_button):   
    if n is None and n_button is None:
        raise PreventUpdate
    

    context = dash.callback_context.triggered[0][&#39;prop_id&#39;].split(&#39;.&#39;)[0] #id of input that triggered callback
    if context == &#39;button-add-new-genome&#39;:
        return 0, &#39;Status: Copy Genome&#39;, True,  {&#39;background-color&#39;:&#39;darkgrey&#39;}
    #TODO questa funzione legge il file creato dalla funzione startAddNewGenome e in base allo step in cui siamo (Copia file, indicizzazione, enrichment etc)
    #ritorna in output una valore della barra (eg +25 per ogni step fatto) e lo step a cui siamo (eg Status: Enrichment Genome)
    
    #controlla se esiste il file aggiunta nuovo genoma, e aggiorna la barra e mette il bottone a Disabled = True
    if isfile(current_working_directory + &#39;Genomes/aggiunta_nuovo_genoma.txt&#39;):
        with open(current_working_directory + &#39;Genomes/aggiunta_nuovo_genoma.txt&#39;) as info_status:
            a = next(info_status).strip().split(&#39; &#39;) #Get current step number [0] and step name [1]
            if &#39;Done&#39; == a[1]:
                subprocess.run([&#39;rm&#39;, current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39;])
                return 100, &#39;Status: Done&#39;, False, {}
        return str(int(a[0]) * 25), &#39;Status: &#39; + a[1], True,  {&#39;background-color&#39;:&#39;darkgrey&#39;}
    return 0 , &#39;Status: No Job Submitted&#39;, False, {}
#################################################
#Fade in/out email
@app.callback(
    Output(&#34;fade&#34;, &#34;is_in&#34;),
    [Input(&#34;checklist-advanced&#34;, &#34;value&#34;)],
    [State(&#34;fade&#34;, &#34;is_in&#34;)],
)
def toggle_fade(selected_options, is_in):
    &#39;&#39;&#39;
    Manages the fading of the InputBox for the email when the option &#39;Notify me by email&#39; is selected/deselected.

    ***Args***

    + [**selected_options**] **checklist-advanced** (*value*): list of IDs of the options checked
    + [**is_in**] **fade** (*is_in*): True if the Input email element is displayed, False otherwise

    ***Returns***

    + **fade** (*is_in*): True in order to show the Input email element, False to hide it
    &#39;&#39;&#39;
    if  selected_options is None:
        return False
    if &#39;email&#39; in selected_options:
        return True
    return False

# Insert/Delete example input
@app.callback(
    [Output(&#39;available-genome&#39;, &#39;value&#39;),
     Output(&#39;available-pam&#39;, &#39;value&#39;),
     Output(&#39;text-guides&#39;, &#39;value&#39;),
     Output(&#39;mms&#39;, &#39;value&#39;),
     Output(&#39;dna&#39;, &#39;value&#39;),
     Output(&#39;rna&#39;, &#39;value&#39;),
     Output(&#39;len-guide-sequence-ver&#39;, &#39;value&#39;),
     Output(&#39;text-sequence&#39;, &#39;value&#39;)],
     [Input(&#39;example-parameters&#39;, &#39;n_clicks_timestamp&#39;),
     Input(&#39;remove-parameters&#39;, &#39;n_clicks_timestamp&#39;)]
)
def inExample(nI, nR):
    &#39;&#39;&#39;
    Inserts an example value in all fields to show the user an example result, or reset the input fields. NOT available in OFFLINE version.
    
    ***Args***

    + [**nI**] **example-parameters** (*n_clicks_timestamp*): button that inserts the example values
    + [**nR**] **remove-parameters** (*n_clicks_timestamp*): button that removes the values and resets all the fields

    ***Returns***

    + **available-genome** (*value*): &#39;hg38 ref+hg38 1000genomeproject&#39; as input example, or &#39;&#39; to reset the value
    + **available-pam** (*value*): &#39;20bp-NGG-SpCas9&#39; as input example, or &#39;&#39; to reset the value
    + **text-guides** (*value*): &#39;GAGTCCGAGCAGAAGAAGAA\\nCCATCGGTGGCCGTTTGCCC&#39; as input example, or &#39;&#39; to reset the value
    + **mms** (*value*): &#39;4&#39; as input example, or &#39;&#39; to reset the value
    + **dna** (*value*): &#39;1&#39; as input example, or &#39;&#39; to reset the value
    + **rna** (*value*): &#39;1&#39; as input example, or &#39;&#39; to reset the value
    + **len-guide-sequence-ver** (*value*): &#39;20&#39; as input example, or &#39;&#39; to reset the value
    + **text-sequence** (*value*): &#39;&gt;sequence\\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39; as input example,
    or &#39;&#39; to reset the value
    &#39;&#39;&#39;

    if (nI is None) and (nR is None):
        raise PreventUpdate

    if nI is None:
        nI = 0

    if nR is None:
        nR = 0
    
    if nI &gt; 0:
        if nI &gt; nR:
            return &#39;hg38 ref+hg38 1000genomeproject&#39;, &#39;20bp-NGG-SpCas9&#39;, &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;, &#39;4&#39;, &#39;1&#39;, &#39;1&#39;, &#39;20&#39;, &#39;&gt;sequence\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39;


    if nR &gt; 0:
        if nR &gt; nI:
            return &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;
    
    # return &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;

#If selected genome has a &#39;+&#39;, update advanced options comparison with reference
@app.callback(
    Output(&#39;checkbox-ref-comp&#39;, &#39;checked&#39;),
    [Input(&#39;available-genome&#39;, &#39;value&#39;)]
)
def suggestComparison(value):
    &#39;&#39;&#39;
    Update to Checked the Option &#39;Compare your results with the corresponding reference genome&#39; if an Enriched Genome is selected (&#39;+&#39; is in the
    name of the genome)

    ***Args***

    + [**value**] **available-genome** (*value*): the name of the genome selected by the user in the Dropdown

    ***Returns***

    + **checkbox-ref-comp** [*checked*]: True if an Enriched genome is selected
    &#39;&#39;&#39;
    if value is None:
        raise PreventUpdate
    if &#39;+&#39; in value:
        return True
    raise PreventUpdate 

#Email validity
@app.callback(
    Output(&#39;example-email&#39;, &#39;style&#39;),
    [Input(&#39;example-email&#39;, &#39;value&#39;)]
)
def checkEmailValidity(val):
    &#39;&#39;&#39;
    Checks email validity (i.e. an &#39;@&#39; is present) and changes the border to green or red accordingly.

    ***Args***
    
    + [**val**] **example-email** (*value*): string of the email

    ***Returns***

    + **example-email** (*style*): dictionary of the style for the Input email: change border to red (if no &#39;@&#39; in **val**) or to green
    &#39;&#39;&#39;
    if val is None:
        raise PreventUpdate

    if &#39;@&#39; in val:
        return {&#39;border&#39;:&#39;1px solid #94f033&#39;, &#39;outline&#39;:&#39;0&#39;}
    return {&#39;border&#39;:&#39;1px solid red&#39;}

#Fade in guide len dropdown for sequence tabs version
@app.callback(
    Output(&#39;fade-len-guide&#39;, &#39;is_in&#39;),
    [Input(&#39;tabs&#39;, &#39;active_tab&#39;)],
    [State(&#39;fade-len-guide&#39;, &#39;is_in&#39;)]
)
def resetTab(current_tab, is_in):
    &#39;&#39;&#39;
    Manages the fading of the Dropdown for the guide length when the tab &#39;Sequence&#39; is active.

    ***Args***

    + [**current_tab**] **tabs** (*active_tab*): string of the ID of the current active tab
    + [**is_in**] **fade-len-guide** (*is_in*): True if the Dropdown guide length element is displayed, False otherwise

    ***Returns***

    + **fade-len-guide** (*is_in*): True in order to show the Dropdown guide length element, False to hide it
    &#39;&#39;&#39;
    if current_tab is None:
        raise PreventUpdate

    if current_tab == &#39;guide-tab&#39;:
        return False
    return True


#Check input presence
@app.callback(
    [Output(&#39;submit-job&#39;, &#39;n_clicks&#39;),
    Output(&#39;modal&#39;, &#39;is_open&#39;),
    Output(&#39;available-genome&#39;, &#39;className&#39;),
    Output(&#39;available-pam&#39;, &#39;className&#39;),
    Output(&#39;text-guides&#39;, &#39;style&#39;),
    Output(&#39;mms&#39;, &#39;className&#39;),
    Output(&#39;dna&#39;, &#39;className&#39;),
    Output(&#39;rna&#39;, &#39;className&#39;),
    Output(&#39;len-guide-sequence-ver&#39;, &#39;className&#39;),
    Output(&#39;warning-list&#39;, &#39;children&#39;)],
    [Input(&#39;check-job&#39;,&#39;n_clicks&#39;),
    Input(&#39;close&#39;,&#39;n_clicks&#39;)],
    [State(&#39;available-genome&#39;, &#39;value&#39;),
    State(&#39;available-pam&#39;,&#39;value&#39;),
    State(&#39;text-guides&#39;, &#39;value&#39;),
    State(&#39;mms&#39;,&#39;value&#39;),
    State(&#39;dna&#39;,&#39;value&#39;),
    State(&#39;rna&#39;,&#39;value&#39;),
    State(&#39;len-guide-sequence-ver&#39;,&#39;value&#39;),
    State(&#39;tabs&#39;,&#39;active_tab&#39;),
    State(&#34;modal&#34;, &#34;is_open&#34;)]
)
def checkInput(n, n_close, genome_selected, pam, text_guides, mms, dna, rna, len_guide_seq, active_tab ,is_open):
    &#39;&#39;&#39;
    Checks the presence and correctness of the input fields, changing their border to red if it&#39;s missing and displaying a Modal element with 
    a list of the missing inputs. The callback is triggered when the user clicks on the &#39;Submit&#39; button or when the modal is closed 
    (by the &#39;Close&#39; button or by clicking on-screen when the Modal element is open)
    
    ***Args***

    + [**n**] **check-job** (*n_clicks*): button that starts the job after checking the correctness of the input
    + [**n_close**] **close** (*n_clicks*): button that closes the opened modal
    + [**genome_selected**] **available-genome** (*value*): string of the selected genome from the Dropdown. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**pam**] **available-pam** (*value*): string of the selected PAM from the Dropdown. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**text_guides**] **text-guides** (*value*): string of the input guides from the Textarea. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**mms**] **mms** (*value*): int of the selected mismatch value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**dna**] **dna** (*value*): int of the selected DNA bulge value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**rna**] **rna** (*value*): int of the selected RNA bulge value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**len_guide_seq**] **len-guide-sequence-ver** (*value*): int value of the length of the guides (available when &#39;Sequence&#39; tab is active). `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**active_tab**] **tabs** (*active_tab*): string of the ID of the active tab (&#39;Guide&#39; or &#39;Sequence&#39;)
    + [**is_open**] **modal** (*is_open*): True if the modal is displayed, false otherwise

    ***Returns***

    + **submit-job** (*n_clicks*): reset the click counter (`None`) if some inputs are missing, else put to `1` in order to trigger the `changeUrl()`
    function and proceed with the job
    + **modal** (*is_open*): `True` if some inputs are missing, `False` otherwise
    + **available-genome** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **available-pam** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **text-guides** (*style*): dictionary for the style element (NOTE not updated if input is missing)
    + **mms** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **dna** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **rna** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **len-guide-sequence-ver** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **warning-list** (*children*): html.Div for the Modal component, listing the missing inputs
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    if is_open is None:
        is_open = False
    
    classname_red = &#39;missing-input&#39;
    genome_update = None
    pam_update = None
    text_update = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;}
    mms_update = None
    dna_update = None
    rna_update = None
    len_guide_update = None
    update_style = False
    miss_input_list = []
    
    if genome_selected is None or genome_selected == &#39;&#39;:
        genome_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Genome&#39;)
    if pam is None or pam == &#39;&#39;:
        pam_update = classname_red
        update_style = True
        miss_input_list.append(&#39;PAM&#39;)
    # if text_guides is None or text_guides == &#39;&#39;:
        # text_update = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;,&#39;border&#39;: &#39;1px solid red&#39;}
        # update_style = True
        # miss_input_list.append(&#39;crRNA sequence(s)&#39;)
    if mms is None or str(mms) == &#39;&#39;:
        mms_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Allowed Mismatches&#39;)
    if dna is None or str(dna) == &#39;&#39;:
        dna_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Bulge DNA size&#39;)
    if rna is None or str(rna) == &#39;&#39;:
        rna_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Bulge RNA size&#39;)
    if (len_guide_seq is None or str(len_guide_seq) == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        len_guide_update = classname_red
        update_style = True
        miss_input_list.append(&#39;crRNA length&#39;)
    miss_input = html.Div(
        [
            html.P(&#39;The following inputs are missing:&#39;),
            html.Ul([html.Li(x) for x in miss_input_list]),
            html.P(&#39;Please fill in the values before submitting the job&#39;)
        ]
    )
    
    if not update_style:
        return 1, False, genome_update, pam_update, text_update, mms_update, dna_update, rna_update, len_guide_update, miss_input
    return None, not is_open, genome_update, pam_update, text_update, mms_update, dna_update, rna_update, len_guide_update, miss_input

#Submit Job, change url
@app.callback(
    [Output(&#39;url&#39;, &#39;pathname&#39;),
    Output(&#39;url&#39;,&#39;search&#39;)],
    [Input(&#39;submit-job&#39;,&#39;n_clicks&#39;)],
    [State(&#39;url&#39;, &#39;href&#39;),
    State(&#39;available-genome&#39;, &#39;value&#39;),
    State(&#39;available-pam&#39;,&#39;value&#39;),
    State(&#39;text-guides&#39;, &#39;value&#39;),
    State(&#39;mms&#39;,&#39;value&#39;),
    State(&#39;dna&#39;,&#39;value&#39;),
    State(&#39;rna&#39;,&#39;value&#39;),
    State(&#39;checkbox-gecko&#39;,&#39;checked&#39;),
    State(&#39;checkbox-ref-comp&#39;, &#39;checked&#39;),
    State(&#39;checklist-advanced&#39;, &#39;value&#39;),
    State(&#39;example-email&#39;,&#39;value&#39;),
    State(&#39;tabs&#39;,&#39;active_tab&#39;),
    State(&#39;text-sequence&#39;,&#39;value&#39;),
    State(&#39;len-guide-sequence-ver&#39;, &#39;value&#39;)]
)
def changeUrl(n, href, genome_selected, pam, text_guides, mms, dna, rna, gecko_opt, genome_ref_opt, adv_opts,dest_email, active_tab, text_sequence, len_guide_sequence):      #NOTE startJob
    &#39;&#39;&#39;
    Main function that generates the inputs for the Post/Process/submit_job.final.sh script and launches the search analysis.

    ***Args***
    
    + [**n**] **submit-job** (*n_clicks*): this value comes from the output of the `checkInput()` function. If `1`, it means that the inputs are
    correct, and the function can proceed. If `None` it means that some inputs are missing, so a `raise PreventUpdate` is returned.
    + [**href**] **url** (*href*): string for the href part of the url. NOTE not used
    + [**genome_selected**] **available-genome** (*value*): string for the selected genome
    + [**pam**] **available-pam** (*value*): string for the selected PAM
    + [**text_guides**] **text-guides** (*value*): string for the input guides
    + [**mms**] **mms** (*value*): int for the mismatch selected
    + [**dna**] **dna** (*value*): int for the DNA bulge selected
    + [**rna**] **rna** (*value*): int for the RNA bbulge selected
    + [**gecko_opt**] **checkbox-gecko** (*checked*): bool for the GeCKO Checkbox 
    + [**genoma_ref_opt**] **checkbox-ref-comp** (*checked*): bool for the reference genome comparison
    + [**adv_opts**] **checklist-advanced** (*value*): list of advanced options selected (NOTE only email)
    + [**dest_email**] **example-email** (*value*): string of the input email
    + [**active_tab**] **tabs** (*active_tab*): string of the ID of the active tab (&#39;Guide&#39; or &#39;Sequence&#39;)
    + [**text_sequence**] **text-sequence** (*value*): string of the input sequence
    + [**len_guide_sequence**] **len-guide-sequence-ver** (*value*): int of the selected guide len (available only if &#39;Sequence&#39; tab is active)

    ***Returns***

    + **url** (*pathname*): string &#39;/load&#39; to go to the Load Page
    + **url** (*search*): string &#39;?job=&#39; + the job ID, to check the status of the specific job 

    ***Details***
    
    + 1) (NOTE already done in `checkInput()`) The function checks the validity of the input parameters.
    + 2) In order to differentiante various analysis submissions, an ID is given to each analysis (Job ID), consisting of a string of 10 alphanumeric
    characters (A-Z 0-9). If a generated ID is already assigned, retry and compute another one. Every 7 iterations, add +1 to the length of the
    ID, up to a maximum of 20 chars. Then the JobID directory is created and inside is created a `queue.txt` file in order to implement a job queue
    + 3) The parameters used as input for the submit_job.final.sh script are created based on user input:
        + Email: the email address, link for the results and start date are written in `Genomes/JobID/email.txt`
        + PAM: get PAM len and direction (beginning or end), in order to write the correct files for pam and guides used in Crispritz.
        + Guides: if the &#39;Sequence&#39; tab is selected, the input is processed in the `extract_seq` module, that returns a list of guides. Non valid 
        characters are then eliminated, along with the exceeding guides (only 1000 guides are acceptable). The guides are then modified by adding
        N characters, following PAM type input (check Crispritz), and saved into file `Genomes/JobID/guides.txt`. The PAM is also saved in the 
        `Genomes/JobID/pam.txt` file, following the Crispritz standard
        + Indexing: if the selected Genome-PAM has no index in `genome_library`, set a flag to calculate the index when submitting the job. The PAM
        used for indexing is `Genomes/JobID/pam_indexing.txt`
        + Params file: the informations about the job are saved into the `Params.txt` file
        + Annotation: based on the selected genome reference part, the annotation is chosen from the `annotations` directory
        + Sample: based on the enriched genome selected, the sampleID file is chosen from the `samplesID` directory 
        + Dictionary: based on the enriched genome selected, the Dictionary for sample extraction is selected from the `dictionaries` directory
    + 4) If the input is equal to an already calculated analysis, then the function modify the job id to the one of the already existing analysis
    (even if it&#39;s completed/currently submitted/in queue), update the `email` file and the `log` file (in order to reset the 3 days availability on the server)
    + Launch the submit_job.final.sh script using `exeggutor`, to a max of 2 concurrent jobs, the others are put into a queue
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    
    # 1) Check input, else give simple input
    if genome_selected is None or genome_selected == &#39;&#39;:
        genome_selected = &#39;hg38_ref&#39;
    if pam is None or pam == &#39;&#39;:
        pam = &#39;20bp-NGG-SpCas9&#39;
    if text_guides is None or text_guides == &#39;&#39;:
        text_guides = &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;
    else:
        text_guides = text_guides.strip()
        if ( not all(len(elem) == len(text_guides.split(&#39;\n&#39;)[0]) for elem in text_guides.split(&#39;\n&#39;))):
            text_guides = selectSameLenGuides(text_guides)
    if (len_guide_sequence is None or str(len_guide_sequence) == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        len_guide_sequence = 20
    if (text_sequence is None or text_sequence == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        text_sequence = &#39;&gt;sequence\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39;
    
    # 2) Get random string for job id
    n_it = 10
    len_id = 10
    for i in range(n_it):
        assigned_ids = [o for o in os.listdir(current_working_directory + &#39;Results/&#39;) if os.path.isdir(os.path.join(current_working_directory + &#39;Results/&#39;,o))]
        job_id = &#39;&#39;.join(random.choices(string.ascii_uppercase + string.digits, k = len_id))
        if job_id not in assigned_ids:
            break
        if i &gt; 7:
            i = 0
            len_id += 1 
            if len_id &gt; 20:
                break
    result_dir = current_working_directory + &#39;Results/&#39; + job_id
    subprocess.run([&#39;mkdir &#39; + result_dir], shell = True)
    #NOTE test command per queue
    subprocess.run([&#39;touch &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/queue.txt&#39;], shell = True)

    # 3) Set parameters
    generate_index_ref = False
    generate_index_enr = False
    search_index = True
    search = True
    annotation = True
    report =  True
    gecko_comp = False
    ref_comparison = False
    send_email = False
    if adv_opts is None:
        adv_opts = []
    if gecko_opt:
        gecko_comp = True
    if genome_ref_opt:
        ref_comparison = True
    if &#39;email&#39; in adv_opts and dest_email is not None and len(dest_email.split(&#39;@&#39;)) &gt; 1 and dest_email.split(&#39;@&#39;)[-1] != &#39;&#39;:
        send_email = True
        with open(result_dir + &#39;/email.txt&#39;, &#39;w&#39;) as e:
            e.write(dest_email + &#39;\n&#39;)
            e.write(URL + &#39;/load?job=&#39; + job_id + &#39;\n&#39;)
            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
            #e.write(&#39;Job done. Parameters: etc etc&#39;)
            e.close()
    
    
    genome_selected = genome_selected.replace(&#39; &#39;, &#39;_&#39;)
    genome_ref = genome_selected.split(&#39;+&#39;)[0]              # + char to separate ref and enr, eg Human_Genome_ref+Human_Genome_1000_genome_project
    if genome_ref == genome_selected:
        ref_comparison = False
    #NOTE Indexed genomes names are PAM + _ + bMax + _ + genome_selected
    
    pam_len = 0
    with open(current_working_directory + &#39;pam/&#39; + pam + &#39;.txt&#39;) as pam_file:
        pam_char = pam_file.readline()
        index_pam_value = pam_char.split(&#39; &#39;)[-1]
        if int(pam_char.split(&#39; &#39;)[-1]) &lt; 0:
            end_idx = int(pam_char.split(&#39; &#39;)[-1]) * (-1)
            pam_char = pam_char.split(&#39; &#39;)[0][0 : end_idx]
            pam_len = end_idx
            pam_begin = True
        else:
            end_idx = int(pam_char.split(&#39; &#39;)[-1])
            pam_char = pam_char.split(&#39; &#39;)[0][end_idx * (-1):]
            pam_len = end_idx
            pam_begin = False
    
    if &#39;sequence-tab&#39; in active_tab:
        #Extract sequence and create the guides
        guides = []
        for name_and_seq in text_sequence.split(&#39;&gt;&#39;):
            if &#39;&#39; == name_and_seq:
                continue
            name = name_and_seq[:name_and_seq.find(&#39;\n&#39;)]
            seq = name_and_seq[name_and_seq.find(&#39;\n&#39;):]
            seq = seq.strip().split()
            seq = &#39;&#39;.join(seq)
            # name, seq = name_and_seq.strip().split(&#39;\n&#39;)    
            if &#39;chr&#39; in seq:
                extracted_seq = extract_seq.extractSequence(name, seq, genome_ref.replace(&#39; &#39;, &#39;_&#39;))
            else:
                extracted_seq = seq.strip()
            
            guides.extend(convert_pam.getGuides(extracted_seq, pam_char, len_guide_sequence, pam_begin))
            text_guides = &#39;\n&#39;.join(guides).strip()
    
    text_guides = text_guides.upper()
    for g in text_guides.split(&#39;\n&#39;):
        for c in g:
            if c not in VALID_CHARS:
                text_guides = text_guides.replace(c,&#39;&#39;)
    if len(text_guides.split(&#39;\n&#39;)) &gt; 1000:
        text_guides = &#39;\n&#39;.join(text_guides.split(&#39;\n&#39;)[:1000]).strip()
    len_guides = len(text_guides.split(&#39;\n&#39;)[0])
    #Adjust guides by adding Ns to make compatible with Crispritz
    if (pam_begin):
        pam_to_file = pam_char + (&#39;N&#39; * len_guides) + &#39; &#39; + index_pam_value
        pam_to_indexing = pam_char + (&#39;N&#39; * 25) + &#39; &#39; + index_pam_value
    else:
        pam_to_file = (&#39;N&#39; * len_guides) + pam_char + &#39; &#39; + index_pam_value
        pam_to_indexing = (&#39;N&#39; * 25) + pam_char + &#39; &#39; + index_pam_value

    save_pam_file = open(result_dir + &#39;/pam.txt&#39;, &#39;w&#39;)
    save_pam_file.write(pam_to_file)
    save_pam_file.close()
    pam = result_dir + &#39;/pam.txt&#39;
        
    guides_file = result_dir + &#39;/guides.txt&#39;
    if text_guides is not None and text_guides != &#39;&#39;:
        save_guides_file = open(result_dir + &#39;/guides.txt&#39;, &#39;w&#39;)
        if (pam_begin):
            text_guides = &#39;N&#39; * pam_len + text_guides.replace(&#39;\n&#39;, &#39;\n&#39; + &#39;N&#39; * pam_len)
        else:
            text_guides = text_guides.replace(&#39;\n&#39;, &#39;N&#39; * pam_len + &#39;\n&#39;) + &#39;N&#39; * pam_len
        save_guides_file.write(text_guides)
        save_guides_file.close()     

    if (int(dna) == 0 and int(rna) == 0):
        search_index = False
    max_bulges = rna
    if (int(dna) &gt; int(rna)):
        max_bulges = dna

    if (search_index):
        search = False

    #Check if index exists, otherwise set generate_index to true
    genome_indices_created =  [f for f in listdir(current_working_directory + &#39;genome_library&#39;) if isdir(join(current_working_directory + &#39;genome_library&#39;, f))]
    genome_idx = &#39;&#39;
    genome_idx_ref = &#39;&#39;
    for gidx in genome_indices_created:
        if pam_char in gidx and genome_selected in gidx:
            if int(gidx.split(&#39;_&#39;)[1]) &gt;= int(max_bulges):
                if &#39;+&#39; in gidx:
                    genome_idx = gidx
                genome_idx_ref = gidx.split(&#39;+&#39;)[0]
                
    if genome_idx == &#39;&#39;:
        if int(max_bulges) &gt; 0:
            generate_index_enr = True
            with open(result_dir + &#39;/pam_indexing.txt&#39;, &#39;w+&#39;) as pam_id_file:
                pam_id_file.write(pam_to_indexing)
        genome_idx = pam_char + &#39;_&#39; + str(max_bulges) + &#39;_&#39; + genome_selected
    if genome_idx_ref == &#39;&#39;:
        if int(max_bulges) &gt; 0:
            generate_index_ref = True
            with open(result_dir + &#39;/pam_indexing.txt&#39;, &#39;w+&#39;) as pam_id_file:
                pam_id_file.write(pam_to_indexing)
        genome_idx_ref = pam_char + &#39;_&#39; + str(max_bulges) + &#39;_&#39; + genome_selected.split(&#39;+&#39;)[0]

    if genome_ref == genome_selected:
        generate_index_enr = False
    # genome_idx = pam_char + &#39;_&#39; + &#39;2&#39; + &#39;_&#39; + genome_selected   
    # genome_idx_ref = genome_idx.split(&#39;+&#39;)[0]
    
    #Create Params.txt file
    with open(result_dir + &#39;/Params.txt&#39;, &#39;w&#39;) as p:           
        p.write(&#39;Genome_selected\t&#39; + genome_selected + &#39;\n&#39;)         
        p.write(&#39;Genome_ref\t&#39; + genome_ref + &#39;\n&#39;)
        if search_index:
            p.write(&#39;Genome_idx\t&#39; + genome_idx + &#39;\n&#39;)
        else:
            p.write(&#39;Genome_idx\t&#39; + &#39;None\n&#39;)
        p.write(&#39;Pam\t&#39; + pam_char + &#39;\n&#39;)
        p.write(&#39;Max_bulges\t&#39; + str(max_bulges) + &#39;\n&#39;)
        p.write(&#39;Mismatches\t&#39; + str(mms) + &#39;\n&#39;)
        p.write(&#39;DNA\t&#39; + str(dna) + &#39;\n&#39;)
        p.write(&#39;RNA\t&#39; + str(rna) + &#39;\n&#39;)
        p.write(&#39;Gecko\t&#39; + str(gecko_comp) + &#39;\n&#39;)
        p.write(&#39;Ref_comp\t&#39; + str(ref_comparison) + &#39;\n&#39;)
        p.close()

    # 4) Check if input parameters (mms, bulges, pam, guides, genome) are the same as a previous search
    all_result_dirs = [f for f in listdir(current_working_directory + &#39;Results&#39;) if isdir(join(current_working_directory + &#39;Results&#39;, f))]
    all_result_dirs.remove(job_id)
    #all_result_dirs.remove(&#39;test&#39;)
    for check_param_dir in all_result_dirs:
        if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/Params.txt&#39;):
            #if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;):
                #with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;) as log:
                    #if (&#39;Job\tDone&#39; in log.read()):
            if (filecmp.cmp(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/Params.txt&#39;, result_dir + &#39;/Params.txt&#39; )):
                    guides1 = open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/guides.txt&#39;).read().split(&#39;\n&#39;)
                    guides2 = open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides.txt&#39;).read().split(&#39;\n&#39;)
                    if (collections.Counter(guides1) == collections.Counter(guides2)):
                        if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;):
                            adj_date = False
                            with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;) as log:
                                log_content = log.read().strip()
                                if (&#39;Job\tDone&#39; in log_content):
                                    adj_date = True
                                    log_content = log_content.split(&#39;\n&#39;)
                                    new_date = subprocess.Popen([&#39;echo $(date)&#39;], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell = True)
                                    out, err = new_date.communicate()
                                    rewrite = &#39;\n&#39;.join(log_content[:-1]) + &#39;\nJob\tDone\t&#39; + out.decode(&#39;UTF-8&#39;).strip()
                            if adj_date:
                                with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39; ,&#39;w+&#39;) as log:
                                    log.write(rewrite)
                                    #Send mail
                                if send_email:
                                    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    #Send mail with file in job_id dir with link to job already done, note that job_id directory will be deleted
                                    subprocess.call([&#39;python &#39; + app_main_directory + &#39;send_mail.py &#39; + current_working_directory + &#39;Results/&#39; + job_id ], shell = True)

                            elif send_email:
                                #Job is not finished, add this user email to email.txt and when job is done send to both
                                if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39;):
                                    with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;a+&#39;) as e:
                                        e.write(&#39;--OTHEREMAIL--&#39;)
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                else:
                                    with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    

                            subprocess.call([&#39;rm -r &#39; + current_working_directory + &#39;Results/&#39; + job_id], shell = True)
                            return &#39;/load&#39;,&#39;?job=&#39; + check_param_dir
                        else:
                            #We may have entered a jobdir that was in queue
                            if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/queue.txt&#39;):
                                if send_email:
                                    if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39;):
                                        with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;a+&#39;) as e:
                                            e.write(&#39;--OTHEREMAIL--&#39;)
                                            e.write(dest_email + &#39;\n&#39;)
                                            e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    else:
                                        with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                            e.write(dest_email + &#39;\n&#39;)
                                            e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                return &#39;/load&#39;,&#39;?job=&#39; + check_param_dir

    #Annotation
    if (not search and not search_index):
        annotation = False      

    #Generate report
    if (not search and not search_index):
        report = False         
    
    genome_type = &#39;ref&#39;     #Indicates if search is &#39;ref&#39;, &#39;var&#39; or &#39;both&#39;
    if &#39;+&#39; in genome_selected:
        genome_type = &#39;var&#39;
    if ref_comparison:
        genome_type = &#39;both&#39;    

    #Get annotation file, already with the absolute path. TODO currently only one annotation per genome
    #Also get dictionary and sample dictionary files
    annotation_file = [f for f in listdir(current_working_directory + &#39;annotations/&#39;) if isfile(join(current_working_directory + &#39;annotations/&#39;, f)) and f.startswith(genome_ref)][0]
    
    if genome_type == &#39;ref&#39;:
        sample_list = None
        dictionary_directory = None
    else:
        sample_list = current_working_directory + &#39;samplesID/samples_&#39; + genome_selected + &#39;.txt&#39;
        dictionary_directory = current_working_directory + &#39;dictionaries/dictionary_&#39; + genome_selected

    command = app_main_directory + &#39;PostProcess/./submit_job.final.sh &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39; &#39; + current_working_directory +  &#39;Genomes/&#39; + genome_selected + &#39; &#39; + current_working_directory + &#39;Genomes/&#39; + genome_ref + &#39; &#39; + current_working_directory + &#39;genome_library/&#39; + genome_idx + (
        &#39; &#39; + pam + &#39; &#39; + guides_file + &#39; &#39; + str(mms) + &#39; &#39; + str(dna) + &#39; &#39; + str(rna) + &#39; &#39; + str(search_index) + &#39; &#39; + str(search) + &#39; &#39; + str(annotation) + (
            &#39; &#39; + str(report) + &#39; &#39; + str(gecko_comp) + &#39; &#39; + str(ref_comparison) + &#39; &#39; + current_working_directory +  &#39;genome_library/&#39; + genome_idx_ref + &#39; &#39; + str(send_email) + &#39; &#39;  + current_working_directory +  &#39;annotations/&#39; + annotation_file + 
            &#39; &#39; + genome_type + &#39; &#39; + app_main_directory + &#39; &#39; + str(dictionary_directory) + &#39; &#39; + str(sample_list) + &#39; &#39; + str(generate_index_ref) + &#39; &#39; + str(generate_index_enr) + &#39; &#39; + current_working_directory))

    exeggutor.submit(subprocess.run, command, shell=True)
    return &#39;/load&#39;,&#39;?job=&#39; + job_id

#When url changed, load new page
@app.callback(
    [Output(&#39;page-content&#39;, &#39;children&#39;),
    Output(&#39;job-link&#39;, &#39;children&#39;)],
    [Input(&#39;url&#39;, &#39;href&#39;), Input(&#39;url&#39;,&#39;pathname&#39;), Input(&#39;url&#39;,&#39;search&#39;)],[State(&#39;url&#39;,&#39;hash&#39;)]
)
def changePage( href, path, search, hash_guide):
    &#39;&#39;&#39;
    Change the page layout based on the URL.

    ***Args***

    + [**href**] **url** (*href*): string containing the whole address, eg &#39;http://127.0.0.1:8080/result?job=QV99PN6XDL#CCATCGGTGGCCGTTTGCCCNNNnewX00&#39;
    + [**path**] **url** (*pathname*): string containing the page, eg &#39;/result&#39;
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**hash_guide**] **url** (*hash*): string containing the view result query, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewX00&#39;

    ***Returns***

    + **page-content** (*children*): the layout of the page, based on the URL. 
        + &#39;/&#39;: returns the index page (main page)
        + &#39;/load&#39;: returns the load page. Called after submitting a job
        + &#39;/result&#39;: returns the result page. Based on the job ID in the **search** parameter, the user can also access to:
            + &#39;#GUIDEnew&#39;: returns the table visualizing the targets based on Bulge and Mismatch values
            + &#39;-Sample-&#39;: returns the table visualizing the targets for each sample
            + &#39;-Pos-&#39;: returns the table visualizing the targets based on the selected chromosome position
        + &#39;/user-guide&#39;: returns the help page
        + &#39;/contacts&#39;: returns the contacts page
        + &#39;/history&#39;: returns the history page. Available only offline
        + &#39;/genomes&#39;: returns the genomes page. Available only offline
    + **job-link** (*children*): the link displayed to the user in the &#39;/load&#39; page, used to access the status of the job. By saving this URL the
    the user can monitor the status of the job and see the corresponding &#39;/result&#39; page
    &#39;&#39;&#39;

    if path == &#39;/load&#39;:
        return load_page, URL + &#39;/load&#39; + search 
    if path == &#39;/result&#39;:
        job_id = search.split(&#39;=&#39;)[-1]
        if hash_guide is None or hash_guide == &#39;&#39;:
            return resultPage(job_id), URL + &#39;/load&#39; + search
        if &#39;new&#39; in hash_guide:         #TODO cambiare nome alla pagina delle guide
            return guidePagev3(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        if &#39;-Sample-&#39; in hash_guide:   
            return samplePage(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        if &#39;-Pos-&#39; in hash_guide:
            return clusterPage(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        return resultPage(job_id), URL + &#39;/load&#39; + search
    if path == &#39;/test-page&#39;:
        return test_page(), URL + &#39;/load&#39; + search
    if path == &#39;/test-page2&#39;:
        return test_page2, URL + &#39;/load&#39; + search
    if path == &#39;/test-page3&#39;:
        return test_page3, URL + &#39;/load&#39; + search
    if path == &#39;/user-guide&#39;:
        return about_page, URL + &#39;/load&#39; + search
    if path == &#39;/contacts&#39;:
        return contacts_page, URL + &#39;/load&#39; + search
    if path == &#39;/history&#39;:
        if ONLINE:
            return indexPage(), &#39;&#39;
        return historyPage(), URL + &#39;/load&#39; + search
    if path == &#39;/genomes&#39;:
        if ONLINE:
            return indexPage(), &#39;&#39;
        genomes_page = html.Div(gen_page.genomesPage(current_working_directory), style = {&#39;margin&#39;:&#39;1%&#39;})
        return genomes_page, URL + &#39;/load&#39; + search
    return indexPage(), &#39;&#39;

#Check end job
@app.callback(
    [Output(&#39;view-results&#39;, &#39;style&#39;),
    Output(&#39;search-status&#39;, &#39;children&#39;),
    Output(&#39;generate-report-status&#39;, &#39;children&#39;),
    Output(&#39;post-process-status&#39;, &#39;children&#39;),
    Output(&#39;view-results&#39;,&#39;href&#39;),
    Output(&#39;no-directory-error&#39;, &#39;children&#39;)],
    [Input(&#39;load-page-check&#39;, &#39;n_intervals&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def refreshSearch(n, dir_name):
    &#39;&#39;&#39;
    The Interval component of the &#39;/load&#39; page calls this function every 3 seconds. The function checks the status of the submitted job by means
    of the log and output file created and updated by the submit_job.final.sh script, and notifies the user about the current status (&#39;To Do&#39;, &#39;Done&#39; etc.) 
    When the job is completed, a link directing to the &#39;/result&#39; page is shown. If the job doesn&#39;t exists or is in the queue,
    a notification will appear. 

    ***Args***

    + [**n**] **load-page-check** (*n_intervals*): element of the Interval component that shows the number of time it has been fired
    + [**dir_name**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **view-results** (*style*): dictionary for the style element of the link that redirects to the &#39;/result&#39; page. If the job is completed
    then the {&#39;visibility&#39;:&#39;visible&#39;} is returned, else {&#39;visibility&#39;:&#39;visible&#39;} 
    + **search-status** (*children*): html.P() that contains the status of the search phase. Can be:
        + To Do, red
        + Done, green
        + Currently ongoing, orange
        + Not Available, red
    + **generate-report-status** (*children*): html.P() that contains the status of the generate report. Can be as above
    + **post-process-status** (*children*): html.P() that contains the status of the post process phase. Can be as above
    + **view-results** (*href*): link that redirects to the &#39;/result&#39; page
    + **no-directory-error** (*children*): Alert component that notify the user that the result is not present in the server, or is in the queue
    &#39;&#39;&#39;

    if n is None:
        raise PreventUpdate    
    
    onlydir = [f for f in listdir(current_working_directory + &#39;Results&#39;) if isdir(join(current_working_directory + &#39;Results&#39;, f))]
    current_job_dir = current_working_directory + &#39;Results/&#39; +  dir_name.split(&#39;=&#39;)[-1] + &#39;/&#39;
    if dir_name.split(&#39;=&#39;)[-1] in onlydir:
        onlyfile = [f for f in listdir(current_job_dir) if isfile(join(current_job_dir, f))]
        if os.path.exists(current_job_dir + &#39;guides.txt&#39;):
            with open(current_job_dir + &#39;guides.txt&#39;) as guides:
                n_guides = len(guides.read().strip().split(&#39;\n&#39;))
        else:
            n_guides = -1
        if &#39;log.txt&#39; in onlyfile:
            with open(current_job_dir + &#39;log.txt&#39;) as log:
                all_done = 0
                
                search_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                report_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                post_process_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                current_log = log.read()

                if (&#39;Search-index\tDone&#39; in current_log and &#39;Search\tDone&#39; in current_log):
                    search_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done from output.txt
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;Indexing_Reference&#39; in line:
                            search_status = html.P(&#39;Indexing Reference Genome...&#39; + &#39; &#39; + &#39;Step [1/2]&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                        if &#39;Indexing_Enriched&#39; in line:
                            search_status = html.P(&#39;Indexing Enriched Genome...&#39; + &#39; &#39; + &#39;Step [2/2]&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                        if &#39;Search_output&#39; in line:
                            if &#39;both&#39; in line:
                                last_percent = line.rfind(&#39;%&#39;)
                                if last_percent &gt; 0:
                                    last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                    search_status_message = last_percent + &#39;%&#39;
                                else:
                                    search_status_message = &#39;Searching...&#39;

                                steps = &#39;Step [1/2]&#39;
                                if &#39;Search_output_ref&#39; in line:
                                    steps = &#39;Step [2/2]&#39;
                                
                            else:
                                last_percent = line.rfind(&#39;%&#39;)
                                if last_percent &gt; 0:
                                    last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                    search_status_message = last_percent + &#39;%&#39;
                                else:
                                    search_status_message = &#39;Searching...&#39;
                                steps = &#39;&#39;
                            search_status = html.P(search_status_message + &#39; &#39; + steps, style = {&#39;color&#39;:&#39;orange&#39;})

                if (&#39;Report\tDone&#39; in current_log):
                    report_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;Generate_report&#39; in line:
                            if n_guides &lt; 0:
                                report_status = html.P(&#39;Generating Report...&#39;, style = {&#39;color&#39;:&#39;orange&#39;}) 
                            else:
                                status_message = round((len(line.split(&#39;\n&#39;)) - 1) / n_guides, 2)
                                report_status = html.P(str(status_message * 100) + &#39;%&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                if (&#39;PostProcess\tDone&#39; in current_log):
                    post_process_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;PostProcess_output&#39; in line:
                            line = line.split(&#39;\n&#39;)
                            if line[-1] == &#39;PostProcess_output&#39;:
                                post_process_status = html.P(&#39;Processing data...&#39;, style = {&#39;color&#39;:&#39;orange&#39;})    
                            else:
                                if &#39;Annotating...&#39; in line:
                                    last_percent = line[-1].rfind(&#39;%&#39;)
                                    if last_percent &gt; 0:
                                        last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                        status_message = last_percent + &#39;%&#39;
                                    else:
                                        status_message = &#39;Annotating...&#39;
                                else:
                                    status_message = line[-1]
                                post_process_status = html.P(status_message, style = {&#39;color&#39;:&#39;orange&#39;})
                if all_done == 3 or &#39;Job\tDone&#39; in current_log:
                    return {&#39;visibility&#39;:&#39;visible&#39;},  search_status, report_status, post_process_status ,&#39;/result?job=&#39; + dir_name.split(&#39;=&#39;)[-1], &#39;&#39;
                else:
                    return {&#39;visibility&#39;:&#39;hidden&#39;},  search_status, report_status, post_process_status,&#39;&#39;, &#39;&#39;
        elif &#39;queue.txt&#39; in onlyfile:
            return {&#39;visibility&#39;:&#39;hidden&#39;},  html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}),&#39;&#39;, dbc.Alert(&#34;Job submitted. Current status: in queue&#34;, color = &#34;info&#34;)
    return {&#39;visibility&#39;:&#39;hidden&#39;},  html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}) ,&#39;&#39;, dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;)

#Perform expensive loading of a dataframe and save result into &#39;global store&#39;
#Cache are in the Cache directory
@cache.memoize()
def global_store(value):
    &#39;&#39;&#39;
    Caching of files, mainly the ones for the &#39;Show Targets&#39; tables, to improve loading speed. NOTE that if two files have the same name, then the
    generated cache will be the same, so a regular cleaning of the &#39;Cache&#39; directory is mandatory.

    ***Args***

    + **value**: string of the job ID to load 

    ***Returns***

    + **df**: dataframe for the &#39;Show Targets&#39; table
    &#39;&#39;&#39;
    if value is None:
        return &#39;&#39;
    target = [f for f in listdir(current_working_directory + &#39;Results/&#39; + value) if isfile(join(current_working_directory + &#39;Results/&#39;+value, f)) and f.endswith(&#39;scores.txt&#39;) ]
    if not target:
        target = [f for f in listdir(current_working_directory + &#39;Results/&#39; + value) if isfile(join(current_working_directory + &#39;Results/&#39;+value, f)) and f.endswith(&#39;targets.txt&#39;) ]
    
    df = pd.read_csv(current_working_directory + &#39;Results/&#39; +value + &#39;/&#39; + target[0], sep = &#39;\t&#39;)
    df.rename(columns = {&#34;#Bulge type&#34;:&#39;BulgeType&#39;, &#39;#Bulge_type&#39;:&#39;BulgeType&#39;,&#39;Bulge Size&#39;: &#39;BulgeSize&#39;, &#39;Bulge_Size&#39;: &#39;BulgeSize&#39;, &#39;Doench 2016&#39;:&#39;Doench2016&#39;,&#39;Doench_2016&#39;:&#39;Doench2016&#39;}, inplace = True)
    return df


#Send the data when next or prev button is clicked on the result table
@app.callback(
    Output(&#39;result-table&#39;, &#39;data&#39;),
    [Input(&#39;result-table&#39;, &#34;page_current&#34;),
     Input(&#39;result-table&#39;, &#34;page_size&#34;),
     Input(&#39;result-table&#39;, &#34;sort_by&#34;),
     Input(&#39;result-table&#39;, &#39;filter_query&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_table(page_current, page_size, sort_by, filter, search, hash_guide):
    &#39;&#39;&#39;
    La funzione ritorna uno split dei risultati in base ad un filtering o a un sort da parte dell&#39;utente. Inoltre aggiorna i risultati
    visualizzati quando il bottone next page / prev page Ã¨ cliccato. (Codice preso dalla pagina dash datatable sul sorting con python)
    Inoltre carica i file targets, o scores se presente, e lo trasforma in un dataframe, cambiando il nome delle colonne per farle corrispondere
    all&#39;id delle colonne della tabella nella pagina.
    Se non ci sono targets ritorna un avviso di errore
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = hash_guide.split(&#39;#&#39;)[1]
    value = job_id
    if search is None:
        raise PreventUpdate

    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    #filtering_expressions.append([&#39;{crRNA} = &#39; + guide])     
    df = global_store(value)
    dff = df[df[&#39;crRNA&#39;] == guide]

    sort_by.insert(0, {&#39;column_id&#39; : &#39;Mismatches&#39;, &#39;direction&#39;: &#39;asc&#39;})
    sort_by.insert(1, {&#39;column_id&#39; : &#39;BulgeSize&#39;, &#39;direction&#39;: &#39;asc&#39;})
    #sort_by.insert(2, {&#39;column_id&#39;: &#39;CFD&#39;, &#39;direction&#39;:&#39;desc&#39;})
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)].sort_values([col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False)
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    #NOTE sort_by: [{&#39;column_id&#39;: &#39;BulgeType&#39;, &#39;direction&#39;: &#39;asc&#39;}, {&#39;column_id&#39;: &#39;crRNA&#39;, &#39;direction&#39;: &#39;asc&#39;}]
    #sort_by.insert(0, {&#39;column_id&#39; : &#39;Mismatches&#39;, &#39;direction&#39;: &#39;asc&#39;})
    #sort_by.insert(0, {&#39;column_id&#39; : &#39;BulgeSize&#39;, &#39;direction&#39;: &#39;asc&#39;})
    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Check if results are not 0
    warning_no_res = &#39;&#39;
    with open(job_directory + job_id + &#39;.targets.txt&#39;) as t:
        no_result = False
        t.readline()
        last_line = t.readline()
        if (last_line == &#39;&#39; or last_line == &#39;\n&#39;):
            no_result = True

    if (no_result):
        warning_no_res = dbc.Alert(&#34;No results were found with the given parameters&#34;, color = &#34;warning&#34;)

     
    return dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)


#For filtering
def split_filter_part(filter_part):
    &#39;&#39;&#39;
    Split the input filter, used for Dash DataTables. See https://dash.plotly.com/datatable/filtering
    &#39;&#39;&#39;
    for operator_type in operators:
        for operator in operator_type:
            if operator in filter_part:
                name_part, value_part = filter_part.split(operator, 1)
                name = name_part[name_part.find(&#39;{&#39;) + 1: name_part.rfind(&#39;}&#39;)]

                value_part = value_part.strip()
                v0 = value_part[0]
                if (v0 == value_part[-1] and v0 in (&#34;&#39;&#34;, &#39;&#34;&#39;, &#39;`&#39;)):
                    value = value_part[1: -1].replace(&#39;\\&#39; + v0, v0)
                else:
                    try:
                        value = float(value_part)
                    except ValueError:
                        value = value_part

                # word operators need spaces after them in the filter string,
                # but we don&#39;t want these later
                return name, operator_type[0].strip(), value

    return [None] * 3


#Read the uploaded file and converts into bit
def parse_contents(contents):
    &#39;&#39;&#39;
    Read the uploaded file and converts into bit
    &#39;&#39;&#39;
    content_type, content_string = contents.split(&#39;,&#39;)
    decoded = base64.b64decode(content_string)
    return decoded

#Load the table/children under the tab value
@app.callback(
    Output(&#39;div-tab-content&#39;, &#39;children&#39;),
    [Input(&#39;tabs-reports&#39;, &#39;value&#39;),
    Input(&#39;general-profile-table&#39;,&#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-genome-type&#39;, &#39;children&#39;)]
)
def updateContentTab(value, sel_cel, all_guides, search, genome_type):
    &#39;&#39;&#39;
    Load the layout based on the selected Tab in the &#39;/result&#39; page

    ***Args***

    + [**value**] **tabs-reports** (*value*): string representing the ID of the active Tab
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**genome_type**] **div-genome-type** (*children*): string containing the type of the search (&#39;ref&#39;, &#39;var&#39; or &#39;both&#39;)

    ***Returns***

    + **div-tab-content** (*children*): return the layout based on the selected Tab:
        + &#39;tab-summary-by-guide&#39;: show the general table of the targets divided by Bulge and Mismatch values
        + &#39;tab-summary-by-sample&#39;: show the general table of the targets divided by sample
        + &#39;tab-summary-by-position&#39;: show the general table of the targets divided by chromosome and position
        + &#39;tab-summary-graphical&#39;: show the graphical report. A total of 10 Buttons, one for each mms value, are created, but only some of them
        are set to be visible (the number of mms selected by the user)
    &#39;&#39;&#39;

    if value is None or sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
        genome_selected = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        max_bulges = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1]

    fl = []
    fl.append(html.Br())
    fl.append(html.H5(&#39;Focus on: &#39; + guide))

    if value == &#39;tab-summary-by-guide&#39;: #BUG se cambio guida selezionata due volte mi cambia il mms mettendo a 0, provare con un div nascosto
        #Show Summary by Guide table
        fl.append(
            html.P(
                [&#39;Summary table counting the number of targets found in the Enriched Genome for each combination of Bulge Type, Bulge Size and Mismatch. Select \&#39;Show Targets\&#39; to view the corresponding list of targets. &#39;, 
                # html.A(&#39;Click here&#39;, href = URL + &#39;/data/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.zip&#39; ,target = &#39;_blank&#39;, id = &#39;download-full-list&#39; ), &#39; to download the full list of targets.&#39;
                ]
                )
        )
        fl.append(
            html.Div(
                html.Button(html.A(&#39;Download Full list of targets&#39;, href = URL + &#39;/data/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.zip&#39; ,target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;black&#39;} )),
                style = {&#39;display&#39;:DISPLAY_ONLINE}
            )
        )
        fl.append(
            html.Div(
                html.Button(&#39;Open Result Directory&#39;, id = &#39;button-open-result-directory&#39;),
                style = {&#39;display&#39;:DISPLAY_OFFLINE}
            )
        )
        fl.append(html.Div(guide,id = &#39;div-open-result-directory&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
        fl.append(html.Br())
        df = pd.read_pickle(job_directory + job_id + &#39;.summary_by_guide.&#39; + guide + &#39;.txt&#39;)
        if genome_type == &#39;both&#39;:
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Reference&#39;] == 0) &amp; (df[&#39;Targets in Enriched&#39;] == 0))  ].index, inplace = True)
        elif genome_type == &#39;var&#39;: 
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Enriched&#39;] == 0))  ].index, inplace = True)
            del df[&#39;Targets in Reference&#39;]
        else:
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Reference&#39;] == 0))  ].index, inplace = True)
        more_info_col = []
        total_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
            total_col.append(df[&#39;Bulge Size&#39;])

        #Swap pam creation and Combined column
        if genome_type == &#39;both&#39;:   #TODO fixare per var e ref
            df[&#39;Combined&#39;] = df[&#39;Targets in Reference&#39;] + df[&#39;Targets in Enriched&#39;]
            #[&#39;Guide&#39; &#39;Bulge Type&#39; &#39;Bulge Size&#39; &#39;Mismatches&#39; &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39; &#39;PAM Creation&#39; &#39;Combined&#39;]
            df = df[[&#39;Guide&#39; , &#39;Bulge Type&#39;, &#39;Mismatches&#39;, &#39;Bulge Size&#39; , &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Combined&#39;, &#39;PAM Creation&#39;]]
        df[&#39;&#39;] = more_info_col
        df[&#39;Total&#39;] = df[&#39;Bulge Size&#39;] + df[&#39;Mismatches&#39;]
        if genome_type == &#39;both&#39; and genome_type == &#39;var&#39;:
            df = df.sort_values([&#39;Total&#39;, &#39;Targets in Enriched&#39;], ascending = [True, False])
        else:
            df = df.sort_values(&#39;Total&#39;, ascending = True)
        del df[&#39;Total&#39;]
        del df[&#39;Guide&#39;]
        fl.append(html.Div(
                generate_table(df, &#39;table-summary-by-guide&#39;, genome_type, guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        return fl
    elif value == &#39;tab-summary-by-sample&#39;:
        #Show Summary by Sample table
        fl.append(
            html.P(&#39;Summary table counting the number of targets found in the Enriched Genome for each sample. Filter the table by selecting the Population or Superpopulation desired from the dropdowns.&#39;)
        )
        if genome_type == &#39;both&#39;:
            col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
        else:
            col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            df.drop([&#39;Class&#39;], axis = 1, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        
        population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
        super_populations = [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp.keys()]
        populations = []
        for k in population_1000gp.keys():
            for i in population_1000gp[k]:
                populations.append({&#39;label&#39;:i, &#39;value&#39;:i})
        fl.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = super_populations, id = &#39;dropdown-superpopulation-sample&#39;, placeholder = &#39;Select a Super Population&#39;))),
                                dbc.Col(html.Div(dcc.Dropdown(options = populations, id = &#39;dropdown-population-sample&#39;, placeholder = &#39;Select a Population&#39;))),
                                #dbc.Col(html.Div(dcc.Dropdown( id = &#39;dropdown-sample&#39;, placeholder = &#39;Select a Sample&#39;))),
                                dbc.Col(html.Div(dcc.Input(id = &#39;input-sample&#39;, placeholder = &#39;Select a Sample&#39; ))),
                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-population-sample&#39;)))
                            ]
                        ),
                    ],
                    style = {&#39;width&#39;:&#39;50%&#39;}
                )
        )
        fl.append(html.Div(&#39;None,None,None&#39;,id = &#39;div-sample-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;})) #Folr keep current filter:  Superpop,Pop
        fl.append(html.Div(
                generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}, id = &#39;div-table-samples&#39;
            )
        )
        fl.append(
            html.Div(
                [
                    html.Button(&#39;Prev&#39;, id = &#39;prev-page-sample&#39;),
                    html.Button(&#39;Next&#39;, id = &#39;next-page-sample&#39;)
                ],
                style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        fl.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-table-samples&#39;))
        return fl
    elif value == &#39;tab-summary-by-position&#39;:
        #Show Summary by position table
        fl.append(
            html.P(&#39;Summary table containing all the targets found in a specific position of the genome. For each position, the enriched target with the lowest Mismatch + Bulge count is shown (if no target was found in the Enriched Genome, the correspondig reference one is shown), along with his Mismatch and Bulge Size values.&#39; + 
            &#39; The subtable \&#39;Targets in Cluster by Mismatch Value\&#39; represents the number of targets found in that position for a particular Mismatch-Bulge Size pair.&#39;)
        )

        fl.append(
            html.P(&#39;Filter the table by selecting the chromosome of interest and writing the start and/or end position of the region to view.&#39;)
        )
        #Dropdown chromosomes
        try:
            onlyfile = [f for f in listdir(current_working_directory + &#39;Genomes/&#39; + genome_selected) if (isfile(join(current_working_directory + &#39;Genomes/&#39; + genome_selected, f)) and (f.endswith(&#39;.fa&#39;) or f.endswith(&#39;.fasta&#39;)))]
        except:
            onlyfile = [&#39;chr&#39; + str(i) + &#39;.fa&#39; for i in range(1,23)]
            onlyfile.append(&#39;chrX.fa&#39;)
            onlyfile.append(&#39;chrY.fa&#39;)                                              #NOTE in case no chr in GENOMES/ i put 22 chr + X Y M
            onlyfile.append(&#39;chrM.fa&#39;)
        onlyfile = [x[:x.rfind(&#39;.&#39;)] for x in onlyfile]            #removed .fa for better visualization
        chr_file = []
        chr_file_unset = []
        for chr_name in onlyfile:
            chr_name = chr_name.replace(&#39;.enriched&#39;, &#39;&#39;)
            if &#39;_&#39; in chr_name:
                chr_file_unset.append(chr_name)
            else:
                chr_file.append(chr_name)
        #Show first &#39;normal&#39; chromosomes (chr1) then the others (chr1_KI270706v1_random)
        chr_file.sort(key = lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split(r&#39;(\d+)&#39;, s)])
        chr_file_unset.sort(key = lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split(r&#39;(\d+)&#39;, s)])
        chr_file += chr_file_unset
        chr_file = [{&#39;label&#39;: chr_name, &#39;value&#39; : chr_name} for chr_name in chr_file]
        
        # Colonne tabella: chr, pos, target migliore, min mm, min bulges, num target per ogni categoria di mm e bulge, show targets; ordine per total, poi mm e poi bulge
        start_time = time.time()
        df = pd.read_csv( job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)   
        df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        fl.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = chr_file, id = &#39;dropdown-chr-table-position&#39;, placeholder = &#39;Select a chromosome&#39;))),
                                dbc.Col(html.Div(dcc.Input(placeholder = &#39;Start Position&#39;, id = &#39;input-position-start&#39;))),
                                dbc.Col(html.Div(dcc.Input(placeholder = &#39;End Position&#39;, id = &#39;input-position-end&#39;))),
                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-position&#39;)))
                            ]
                        ),
                    ],
                    style = {&#39;width&#39;:&#39;50%&#39;}
                )
        )
        fl.append(html.Div(&#39;None,None,None&#39;,id = &#39;div-position-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;})) #Folr keep current filter:  chr,pos_start,pos_end
        start_time = time.time()
        fl.append(html.Div(
                generate_table_position(df, &#39;table-position&#39;, 1 , int(mms), int(max_bulges), guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}, id = &#39;div-table-position&#39;
            )
        )
        fl.append(
            html.Div(
                [
                    html.Button(&#39;Prev&#39;, id = &#39;prev-page-position&#39;),
                    html.Button(&#39;Next&#39;, id = &#39;next-page-position&#39;)
                ],
                style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        fl.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-table-position&#39;))
        fl.append(html.Div(mms + &#39;-&#39; + max_bulges, id = &#39;div-mms-bulges-position&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
        return fl
    else:
        #Show Report images
        samp_style = {}
        if genome_type == &#39;ref&#39;:
            samp_style = {&#39;display&#39;:&#39;none&#39;}
        
        fl.append(html.Br())
        
        fl_buttons = []
        for i in range (10):
            if (i &lt;= int(mms)): #TODO change into (i &lt;= (int(mms) + int(max_bulges)))
                fl_buttons.append(
                    html.Button(str(i) + &#39; mm&#39;,id = &#39;btn&#39; + str(i)),       
                )
            else:
                fl_buttons.append(
                    html.Button(str(i) + &#39; mm&#39;,id = &#39;btn&#39; + str(i), style = {&#39;display&#39;:&#39;none&#39;}), #Hide buttons for mms non selected
                )
        
        fl.append(html.Br())

        radar_img = &#39;summary_single_guide_&#39; + guide + &#39;_&#39; + str(0) + &#39;mm.png&#39;

        barplot_img = &#39;summary_histogram_&#39; + guide + &#39;_&#39; + str(0) + &#39;mm.png&#39;
        try:            #NOTE serve per non generare errori se il barplot non Ã¨ stato fatto
            barplot_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + barplot_img, &#39;rb&#39;).read()).decode())
        except:
            barplot_src = &#39;&#39;
        try:
            barplot_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + barplot_img
        except:
            barplot_href = &#39;&#39;

        try:
            radar_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + radar_img, &#39;rb&#39;).read()).decode())
        except:
            radar_src = &#39;&#39;
        try:
            radar_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + radar_img
        except:
            radar_href = &#39;&#39;
        
        if genome_type != &#39;ref&#39;:
            population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
        
            super_populations = [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp.keys()]
            populations = []
            for k in population_1000gp.keys():
                for i in population_1000gp[k]:
                    populations.append({&#39;label&#39;:i, &#39;value&#39;:i})
        else:
            super_populations = []
            populations = [] 

        fl.append(
            html.Div(
                [   dbc.Row(
                        [
                            dbc.Col(
                                [
                                    html.P(&#39;Select Mismatch Value&#39;),
                                    dbc.Row(
                                        html.Div(fl_buttons),
                                    )
                                ]
                            ),
                            dbc.Col(
                                [
                                    html.P(&#39;Select Individual Data&#39;, style = samp_style ),
                                    dbc.Row([
                                    dbc.Col(html.Div(dcc.Dropdown(options = super_populations, id = &#39;dropdown-superpopulation-sample&#39;, placeholder = &#39;Select a Super Population&#39;, style = samp_style))),
                                    dbc.Col(html.Div(dcc.Dropdown(options = populations, id = &#39;dropdown-population-sample&#39;, placeholder = &#39;Select a Population&#39;, style = samp_style))),
                                    dbc.Col(html.Div(dcc.Dropdown( id = &#39;dropdown-sample&#39;, placeholder = &#39;Select a Sample&#39;, style = samp_style))),
                                    ])
                                ]
                            )
                        ]
                    ),
                ]
            )
        )
        fl.append(html.Hr())
        fl.append(
                html.Div(
                    [
                        dbc.Row(
                            [
                                dbc.Col([    #Guide part
                                    html.Div(
                                        [
                                    
                                            dbc.Row(html.Br()),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.A(
                                                            html.Img(src = radar_src, id = &#39;barplot-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                                                            target=&#34;_blank&#34;,
                                                            href = radar_href
                                                        ),
                                                        width = 10
                                                    )
                                                ]
                                            ),
                                            dbc.Row(html.Br()),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.A(
                                                            html.Img(src = barplot_src,id = &#39;radar-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                                                            target=&#34;_blank&#34;,
                                                            href = barplot_href
                                                        ),
                                                        width = 10
                                                    )
                                                ]
                                            )
                                            
                                        ],
                                        id = &#39;div-guide-image&#39;
                                    )
                                ]),
                                dbc.Col([    #Sample part
                                    html.Div(
                                        [
                                        
                                        ],
                                        id = &#39;div-sample-image&#39;
                                    )
                                ])
                            ]
                        )
                    ]
                
                )
            )
            
        
        fl.append(html.Br())
        fl.append(html.Br())

        #TODO codice per l&#39;integrazione del CFD graph. When .CFDGraph.txt will be integrated, remove the try/except
        
        cfd_path = job_directory + job_id +&#39;.CFDGraph.txt&#39;
        if not isfile(cfd_path): #No file found
            return fl
        
        fl.extend(
            CFDGraph.CFDGraph(cfd_path)
        )

        return fl
    # guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;State&#39;]
        # return guide + value
    raise PreventUpdate


#Open in browser the result directory
@app.callback(
    Output(&#39;div-open-result-directory&#39;, &#39;children&#39;),
    [Input(&#39;button-open-result-directory&#39;, &#39;n_clicks&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-open-result-directory&#39;, &#39;children&#39;)]
)
def openResultDirectory(n, search, guide):
    &#39;&#39;&#39;
    Opens a new tab where the final list of off-targets is shown (NOT available when ONLINE mode is selected)

    ***Args***

    + [**n**] **button-open-result-directory** (*n_cliks*): number of times the button was pressed
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**guide**] **div-open-result-directory** (*children*): string of the currently selected guide

    ***Returns***

    + Opens a new tab showing the off-target list of jobID.targets.GUIDE.txt final file
    &#39;&#39;&#39;
    if n is None or ONLINE:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]  #TODO decidere se aprire tutta la cartella, solo il file, e nel secondo caso creare copia submit job che non rimuova .targets.GUIDE.txt
    wb.open_new_tab(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.txt&#39;)
    raise PreventUpdate


#Select figures on mms value, sample value
@app.callback(
    [Output(&#39;div-guide-image&#39;, &#39;children&#39;),
    Output(&#39;div-sample-image&#39;, &#39;children&#39;)],
    [Input(&#39;btn0&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn1&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn2&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn3&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn4&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn5&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn6&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn7&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn8&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn9&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;),
    Input(&#39;dropdown-population-sample&#39;, &#39;value&#39;),
    Input(&#39;dropdown-sample&#39;, &#39;value&#39;),
    Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;)]
)
def updateImagesTabs(n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, superpopulation, population, sample, sel_cel, search, all_guides):
    &#39;&#39;&#39;
    Loads the images on the Graphical Report based on the selected mismatch value and/or sample, population, superpopulation value.

    ***Args***

    + [**n_**] **btn_** (*n_clicks_timestam*): string of the timestamp of the last time the button was pressed.
    + [**superpopulation**] **dropdown-superpopulation-sample** (*value*): string of the selected superpopulation
    + [**population**] **dropdown-population-sample** (*value*): string of the selected population
    + [**sample**] **dropdown-sample** (*value*): string of the selected sample
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table

    ***Returns***

    + **div-guide-image** (*children*): returns barplot and radarchart of the selected guide
    + **div-sample-image** (*children*): returns radarchart specific for sample/pop/superpop of the selected guide

    ***Details***

    + The function sort all the timestamps of the buttons (can be up to 10 buttons, one for each mms value) and select the one that was clicked last.
    Since it is not possible in the current Dash version to create callbacks of components that are not available in the app.layout, but the buttons
    are created dynamically (we do not know how many mms the user selects), we create 10 buttons and show only the ones corresponding to the number
    of selected mms, the others are hidden using `{&#39;display&#39;:&#39;none&#39;}`. In this way we can create this callback even when we do not know how may mms
    the user will set.
    + If the image for a specific sample/pop/superpop is not available, the function calls `crispritz.py generate-report` in order to create the image 
    + The corresponding image is then loaded from the `assets/Img/jobID` directory, in order to be also available to be opened in a new tab (by
    clicking on it)
    &#39;&#39;&#39;

    if sel_cel is None :
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    
    guide_images = []
    sample_images = []
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        gecko_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Gecko&#39; in s)).split(&#39;\t&#39;)[-1]

    gecko_string = &#39;&#39;
    if gecko_comp == &#39;True&#39;:
        gecko_string = &#39;-gecko&#39;
    
    #Initialize to 0 Buttons not pressed
    if not n0:
        n0 = 0
    if not n1:
        n1 = 0
    if not n2:
        n2 = 0
    if not n3:
        n3 = 0
    if not n4:
        n4 = 0
    if not n5:
        n5 = 0
    if not n6:
        n6 = 0
    if not n7:
        n7 = 0
    if not n8:
        n8 = 0
    if not n9:
        n9 = 0
    btn_group = []
    btn_group.append(n0)
    btn_group.append(n1)
    btn_group.append(n2)
    btn_group.append(n3)
    btn_group.append(n4)
    btn_group.append(n5)
    btn_group.append(n6)
    btn_group.append(n7)
    btn_group.append(n8)
    btn_group.append(n9)
    
    #Check last pressed button
    if max(btn_group) == n0:
        mm_show = 0
    if max(btn_group) == n1:
        mm_show = 1
    if max(btn_group) == n2:
        mm_show = 2
    if max(btn_group) == n3:
        mm_show = 3
    if max(btn_group) == n4:
        mm_show = 4
    if max(btn_group) == n5:
        mm_show = 5
    if max(btn_group) == n6:
        mm_show = 6
    if max(btn_group) == n7:
        mm_show = 7
    if max(btn_group) == n8:
        mm_show = 8
    if max(btn_group) == n9:
        mm_show = 9
    if max(btn_group) == 0:
        mm_show = 0
    radar_img = &#39;summary_single_guide_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;

    barplot_img = &#39;summary_histogram_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;
    try:            #NOTE if the image is not available, show nothing
        barplot_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + barplot_img, &#39;rb&#39;).read()).decode())
    except:
        barplot_src = &#39;&#39;
    try:
        barplot_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + barplot_img
    except:
        barplot_href = &#39;&#39;

    try:
        radar_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + radar_img, &#39;rb&#39;).read()).decode())
    except:
        radar_src = &#39;&#39;
    try:
        radar_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + radar_img
    except:
        radar_href = &#39;&#39;
    
    guide_images.extend([
        
        dbc.Row(html.Br()),
        dbc.Row(
            [
                dbc.Col(
                    html.A(
                        html.Img(src = radar_src, id = &#39;radar-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                        target=&#34;_blank&#34;,
                        href = radar_href
                    ),
                    width = 10
                )
            ]
        ),
        dbc.Row(html.Br()),
        dbc.Row(
            [
                dbc.Col(
                    html.A(
                        html.Img(src = barplot_src,id = &#39;barplot-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                        target=&#34;_blank&#34;,
                        href = barplot_href
                    ),
                    width = 10
                )
            ]
        )
    ])
    class_images = [(sample, &#39;Samples&#39;), (population, &#39;Population&#39;), (superpopulation, &#39;Superpopulation&#39;)]
    
    #If the user selects a sample/pop/superpop not already processed, call crispritz generate-report and create the image
    for c in class_images:
        if c[0]:
            try:
                first_img_source = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;, &#39;rb&#39;).read()).decode())
            except:
                #create image from annotation file of samples
                subprocess.call([&#39;cd &#39;+job_directory +&#39;;&#39;+
                &#39; crispritz.py generate-report &#39; + guide + &#39; -mm &#39; + str(mm_show) + &#39; -annotation &#39; + job_id + &#39;.sample_annotation.&#39; + guide +
                &#39;.&#39; + c[1].lower() + &#39;.txt &#39;+ gecko_string +&#39; -ws -sample &#39; + c[0]], shell = True)
                
                copy_img = subprocess.Popen([&#39;cp &#39; + job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png assets/Img/&#39; + job_id], shell = True)
                copy_img.wait() #BUG se metto il copia link, mi si ricarica la pagina, forse il problema non c&#39;Ã¨ se uso gnicorn
                first_img_source = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;, &#39;rb&#39;).read()).decode())
            try:
                first_img_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;
            except:
                first_img_href = &#39;&#39;
            sample_images.append(dbc.Row(html.Br()))

            sample_images.append(
                dbc.Row(
                [
                    dbc.Col(
                        html.A(
                            html.Img(src = first_img_source, width=&#34;100%&#34;, height=&#34;auto&#34;),
                            target=&#34;_blank&#34;,
                            href = first_img_href
                        ),
                        width = 10
                    ),
                ],
                no_gutters=True 
            ),
            )
    return guide_images, sample_images


def generate_table(dataframe, id_table, genome_type, guide=&#39;&#39;, job_id=&#39;&#39;, max_rows=2600):
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Guide section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **genome_type**: string containing the type of the search (&#39;ref&#39;, &#39;var&#39; or &#39;both&#39;)
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Guide section
    &#39;&#39;&#39;
    if genome_type == &#39;both&#39;:
        header = [html.Tr([
            html.Th(&#39;Bulge Type&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Mismatches&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Bulge Size&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Targets found in Genome&#39;, colSpan = str(3), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;PAM Creation&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;&#39;, rowSpan = &#39;2&#39;),
            ])
        ]
    # &#39;Bulge Type&#39; &#39;Mismatches&#39; &#39;Bulge Size&#39; &#39;Targets in Reference&#39; &#39;Targets in Enriched&#39; &#39;Combined&#39; &#39;PAM Creation&#39; &#39;&#39;
    
        header.append(html.Tr([html.Th(x, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for x in [&#39;Reference&#39;, &#39;Enriched&#39;,&#39;Combined&#39;]]))
    else:
        header = [html.Tr([html.Th(col, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns])]
    return html.Table(
        # Header
        # [html.Tr([html.Th(col) if col != &#39;Targets in Enriched&#39; else html.Th(html.Abbr(col, title = &#39;Counting of targets that are generated by the insertion of a IUPAC nucleotide of a sample&#39;, 
        # style = {&#39;text-decoration&#39;:&#39;underline&#39;})) for col in dataframe.columns])] +
        # [html.Tr([html.Th(col, rowSpan = 2) if &#39;Targets&#39; not in col or &#39;Combined&#39; not in col else html.Th(&#39;Targets&#39;) for col in dataframe.columns])] +
        header  + 
        # Body
        [html.Tr([
            html.Td(html.A(dataframe.iloc[i][col],  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;new&#39; + dataframe.iloc[i][&#39;Bulge Type&#39;] + str(dataframe.iloc[i][&#39;Bulge Size&#39;]) + str(dataframe.iloc[i][&#39;Mismatches&#39;]) , target = &#39;_blank&#39; ), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) if col == &#39;&#39; else  html.Td(dataframe.iloc[i][col],style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns
        ]) for i in range(min(len(dataframe), max_rows))],
        style = {&#39;display&#39;:&#39;inline-block&#39;},
        id = id_table
    )

def generate_table_samples(dataframe, id_table, page ,guide=&#39;&#39;, job_id=&#39;&#39;, max_rows=10):
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Sample section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **page**: int containing the current page of the table
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Sample section
    &#39;&#39;&#39;
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    return html.Table(
        # Header
        # [html.Tr([html.Th(col) if col != &#39;Targets in Enriched&#39;  else html.Th(html.Abbr(col, title = &#39;Counting of targets that are generated by the insertion of a IUPAC nucleotide of a sample&#39;,
        # style = {&#39;text-decoration&#39;:&#39;underline&#39;})) for col in dataframe.columns]) ] +  
        [html.Tr([html.Th(col) for col in dataframe.columns]) ] +
        # Body
        [html.Tr([
            html.Td(html.A(dataframe.iloc[i + (page - 1)*max_rows][col],  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;-Sample-&#39; + dataframe.iloc[i  + (page - 1)*max_rows][&#39;Sample&#39;] , target = &#39;_blank&#39; )) if col == &#39;&#39; else  html.Td(dataframe.iloc[i + (page - 1)*max_rows][col]) for col in dataframe.columns
        ]) for i in range(min(rows_remaining, max_rows))],
        style = {&#39;display&#39;:&#39;inline-block&#39;},
        id = id_table
    )

def generate_table_position(dataframe, id_table, page, mms, bulges, guide = &#39;&#39;, job_id = &#39;&#39;, max_rows = 10): #NOTE v2 della tabella posizioni       #TODO modifica layout righe per allinearle
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Position section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **page**: int containing the current page of the table
    + **mms**: int value of the max allowed mismatched
    + **bulges**: int value of the max allowed bulges
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Position section
    &#39;&#39;&#39;
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    header = [html.Tr([
        html.Th(&#39;Chromosome&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Position&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Best Target&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Min Mismatch&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Min Bulge&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Bulge&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Targets in Cluster by Mismatch Value&#39;, colSpan = str(mms +1), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;&#39;, rowSpan = &#39;2&#39;),
        ])
    ]
    mms_header = []
    for mm in range (mms +1):
        mms_header.append(html.Th(str(mm) + &#39; MM&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}))
    header.append(html.Tr(mms_header))
    
    data = []
    for i in range(min(rows_remaining, max_rows)):
        first_cells = [
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Chromosome&#39;], rowSpan = str(bulges +1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Position&#39;], rowSpan = str(bulges +1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Best Target&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Min Mismatch&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Min Bulge&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;0 Bulge&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;, &#39;padding-left&#39;:&#39;0&#39;})
        ]
        
        mm_cells = [html.Td(dataframe.iloc[i + (page - 1)*max_rows][col], style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns[5:5+mms+1]]
        data.append(html.Tr(first_cells + mm_cells + [html.Td(
                html.A(&#39;Show Targets&#39;,  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;-Pos-&#39; + str(dataframe.iloc[i + (page - 1)*max_rows][&#39;Chromosome&#39;]) + &#39;-&#39; +  str(dataframe.iloc[i + (page - 1)*max_rows][&#39;Position&#39;]) , target = &#39;_blank&#39;), 
                rowSpan = str(bulges+1), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
            ]))
        for b in range (bulges):
            data.append(
                html.Tr(
                    [html.Th(str(b +1) + &#39; Bulge&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;} )]
                    +
                    [html.Td(dataframe.iloc[i + (page - 1)*max_rows][col]) for col in dataframe.columns[5 + (b +1) *(mms +1) : 5 + (b +1) *(mms+1) + mms +1]]
                )
            )
    
    return html.Table(header + data, style = {&#39;display&#39;:&#39;inline-block&#39;}, id = id_table)


#Callback to update the population tab based on superpopulation selected
@app.callback(
    [Output(&#39;dropdown-population-sample&#39;, &#39;options&#39;),
    Output(&#39;dropdown-population-sample&#39;, &#39;value&#39;)],
    [Input(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def updatePopulationDrop(superpop, search):
    &#39;&#39;&#39;
    Update the Dropdown containing the Population list based on the selected Superpopulation.

    ***Args***

    + [**superpop**] **dropdown-superpopulation-sample** (*value*): string of the selected Superpopulation
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **dropdown-population-sample** (*options*): list of dictionaries for the option element of the Population dropdown
    + **dropdown-population-sample** (*value*): currently selected value (reinitialized to be empty)
    &#39;&#39;&#39;
    if superpop is None or superpop == &#39;&#39;:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
    return [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp[superpop]], None 

#Callback to update the sample based on population selected
@app.callback(
    [Output(&#39;dropdown-sample&#39;,&#39;options&#39;),
    Output(&#39;dropdown-sample&#39;,&#39;value&#39;)],
    [Input(&#39;dropdown-population-sample&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def updateSampleDrop(pop, search):
    &#39;&#39;&#39;
    Update the Dropdown containing the Sample list based on the selected Population.

    ***Args***

    + [**pop**] **dropdown-population-sample** (*value*): string of the selected Population
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **dropdown-sample** (*options*): list of dictionaries for the option element of the Sample dropdown
    + **dropdown-sample** (*value*): currently selected value (reinitialized to be empty)
    &#39;&#39;&#39;
    if pop is None or pop == &#39;&#39;:
        return [], None
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    dict_pop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[3]
    return [{&#39;label&#39;: sam, &#39;value&#39; : sam} for sam in dict_pop[pop]], None 

#Callback to update the hidden div filter
@app.callback(
    Output(&#39;div-sample-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-population-sample&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;),
    State(&#39;dropdown-population-sample&#39;, &#39;value&#39;),
    State(&#39;input-sample&#39;, &#39;value&#39;)]
)
def updateSampleFilter(n, superpopulation, population, sample):
    &#39;&#39;&#39;
    Update the filter (superpop,pop,sample) for the filtering of the Summary by Sample table

    ***Args***

    + [**n**] **button-filter-population-sample** (*n_clicks*): int for the number of times the button was clicked
    + [**superpopulation**] **dropdown-superpopulation-sample** (*value*): string containing the selected Superpopulation
    + [**population**] **dropdown-population-sample** (*value*): string containing the selected Population
    + [**sample**] **input-sample** (*value*): string containing the Sample, given in input by the user

    ***Returns***

    + **div-simple-filter-query** (**children**): string in the format of &#39;superpop,pop,sample&#39;, or &#39;None&#39; if a parameter was not provided (eg
    &#39;EU,TSI,None&#39;)
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    return str(superpopulation) + &#39;,&#39; + str(population) + &#39;,&#39; + str(sample).replace(&#39; &#39;,&#39;&#39;).upper()

#Callback to view next/prev page on sample table
@app.callback(
    [Output(&#39;div-table-samples&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-table-samples&#39;, &#39;children&#39;)],
    [Input(&#39;prev-page-sample&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-sample&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-sample-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-filter-population-sample&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;selected_cells&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;div-current-page-table-samples&#39;, &#39;children&#39;)]
)
def filterSampleTable( nPrev, nNext, filter_q, n, search, sel_cel, all_guides, current_page):
    &#39;&#39;&#39;
    Filtering/changing page of the table in the Summary by Sample tab.

    ***Args***
    + [**nPrev**] **prev-page-sample** (*n_clicks_timestamp*): int timestamp of last click on Previous Page button
    + [**nNext**] **next-page-sample** (*n_clicks_timestamp*): int timestamp of last click on Next Page button
    + [**filter_q**] **div-sample-filter-query** (*children*): string of the filter query
    + [**n**] **button-filter-population-sample** (*n_clicks_timestamp*): int timestamp of the Apply Filter button
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**current_page**] **div-current-page-table-samples** (*children*): string containing the current page of the table (eg &#39;1/15&#39;)

    ***Returns***

    + **div-table-samples** (*children*): html.Table with filtering applied and/or next/previous page of data
    + **div-current-page-table-samples** (*children*): string of the currently displayed page
    &#39;&#39;&#39;
    if sel_cel is None:
        raise PreventUpdate
    if nPrev is None and nNext is None and n is None:
        raise PreventUpdate

    if nPrev is None:
        nPrev = 0
    if nNext is None:
        nNext = 0
    if n is None:
        n = 0
    
    sup_pop = filter_q.split(&#39;,&#39;)[0]
    pop = filter_q.split(&#39;,&#39;)[1]
    samp = filter_q.split(&#39;,&#39;)[2]
    if sup_pop == &#39;None&#39;:
        sup_pop = None
    if pop == &#39;None&#39;:
        pop = None
    if samp == &#39;None&#39; or samp == &#39;NONE&#39;:
        samp = None
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    btn_sample_section = []
    btn_sample_section.append(n)
    btn_sample_section.append(nPrev)
    btn_sample_section.append(nNext)
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    if genome_type == &#39;both&#39;:
        col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
    else:
        col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]       
    if max(btn_sample_section) == n:              #Last button pressed is filtering, return the first page of the filtered table
        if genome_type == &#39;both&#39;:
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
        else:
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        if (sup_pop is None or sup_pop == &#39;&#39;) and (pop is None or pop == &#39;&#39;) and (samp is None or samp == &#39;&#39;):   #No filter value selected
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), &#39;1/&#39; + str(max_page)
        if samp is None or samp == &#39;&#39;:
            if pop is None or pop == &#39;&#39;:
                df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
            else:
                df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
        else:
            df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        return generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), &#39;1/&#39; + str(max_page)
    else:
        if max(btn_sample_section) == nNext:
            current_page = current_page + 1
            if genome_type == &#39;both&#39;:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
                df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            #Active filter
            if pop or sup_pop or samp:
                if samp is None or samp == &#39;&#39;:
                    if pop is None or pop == &#39;&#39;:
                        df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
                    else:
                        df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)

            if ((current_page - 1) * 10) &gt; len(df): 
                current_page = current_page -1
                if current_page &lt; 1:
                    current_page = 1
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, current_page, guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
        
        else:   #Go to previous page
            current_page = current_page - 1
            if current_page &lt; 1:
                current_page = 1
            if genome_type == &#39;both&#39;:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
                df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if pop or sup_pop or samp:
                if samp is None or samp == &#39;&#39;:
                    if pop is None or pop == &#39;&#39;:
                        df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
                    else:
                        df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, current_page, guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
    raise PreventUpdate


#Callback to update the hidden div filter position
@app.callback(
    Output(&#39;div-position-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-position&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-chr-table-position&#39;, &#39;value&#39;),
    State(&#39;input-position-start&#39;, &#39;value&#39;),
    State(&#39;input-position-end&#39;, &#39;value&#39;)]
)
def updatePositionFilter(n, chr, pos_start, pos_end):
    &#39;&#39;&#39;
    Update the filter (chr,start,end) for the filtering of the Summary by Position table

    ***Args***

    + [**n**] **button-filter-population-sample** (*n_clicks*): int for the number of times the button was clicked
    + [**chr**] **dropdown-chr-table-position** (*value*): string containing the selected chromosome
    + [**pos_start**] **input-position-start** (*value*): string containing the start position
    + [**pos_end**] **input-position-end** (*value*): string containing the end position

    ***Returns***

    + **div-position-filter-query** (**children**): string in the format of &#39;chr,start,end&#39;, or &#39;None&#39; if a parameter was not provided (eg
    &#39;chr4,1010,None&#39;)
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    if pos_start == &#39;&#39;:
        pos_start = &#39;None&#39;
    if pos_end == &#39;&#39;:
        pos_end = &#39;None&#39;
    return str(chr) + &#39;,&#39; + str(pos_start) + &#39;,&#39; + str(pos_end)

#Callback to filter chr from Summary by Position table, and to show next/prev page
@app.callback(
    [Output(&#39;div-table-position&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-table-position&#39;, &#39;children&#39;)],
    [Input(&#39;prev-page-position&#39;,&#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-position&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-position-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-filter-position&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;selected_cells&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;div-current-page-table-position&#39;, &#39;children&#39;),
    State(&#39;div-mms-bulges-position&#39;, &#39;children&#39;)]
)
def filterPositionTable(nPrev, nNext, filter_q, n, search, sel_cel, all_guides, current_page, mms_bulge):
    &#39;&#39;&#39;
    Filtering/changing page of the table in the Summary by Position tab.

    ***Args***
    + [**nPrev**] **prev-page-position** (*n_clicks_timestamp*): int timestamp of last click on Previous Page button
    + [**nNext**] **next-page-position** (*n_clicks_timestamp*): int timestamp of last click on Next Page button
    + [**filter_q**] **div-position-filter-query** (*children*): string of the filter query
    + [**n**] **button-filter-position** (*n_clicks_timestamp*): int timestamp of the Apply Filter button
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**current_page**] **div-current-page-table-samples** (*children*): string containing the current page of the table (eg &#39;1/15&#39;)
    + [**mms_bulge**] **div-mms-bulge-position** (*children*): string containing the value of the max mismatch and bulge value (eg. &#39;6-2&#39;)

    ***Returns***

    + **div-table-position** (*children*): html.Table with filtering applied and/or next/previous page of data
    + **div-current-page-table-position** (*children*): string of the currently displayed page    
    &#39;&#39;&#39;

    if sel_cel is None:
        raise PreventUpdate
    if nPrev is None and nNext is None and n is None:
        raise PreventUpdate
    
    if nPrev is None:
        nPrev = 0
    if nNext is None:
        nNext = 0
    if n is None:
        n = 0

    filter_q = filter_q.split(&#39;,&#39;)
    chr = filter_q[0]
    if chr == &#39;None&#39;:
        chr = None
    pos_begin = filter_q[1]
    if pos_begin == &#39;None&#39;:
        pos_begin = None
    pos_end = filter_q[2]
    if pos_end == &#39;None&#39;:
        pos_end = None
    
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    mms = int(mms_bulge.split(&#39;-&#39;)[0])
    max_bulges = int(mms_bulge.split(&#39;-&#39;)[1])
    btn_position_section = []
    btn_position_section.append(n)
    btn_position_section.append(nPrev)
    btn_position_section.append(nNext)
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    if max(btn_position_section) == n:              #Last button pressed is filtering, return the first page of the filtered table
        if pos_begin is None or pos_begin == &#39;&#39;:
            pos_begin = 0
        if pos_end == &#39;&#39;:
            pos_end = None
        if pos_end:
            if int(pos_end) &lt; int(pos_begin):
                pos_end = None
        df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
        
        df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        if chr is None or chr == &#39;&#39;:
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, 1, mms, max_bulges,guide, job_id ), &#39;1/&#39; + str(max_page)
        if pos_end is None:
            df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
        else:
            df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        return generate_table_position(df, &#39;table-position&#39;, 1, mms, max_bulges,guide, job_id ), &#39;1/&#39;+ str(max_page)
    else:
        
        if max(btn_position_section) == nNext:
            current_page = current_page + 1
            if chr:
                if pos_begin is None or pos_begin == &#39;&#39;:
                    pos_begin = 0
                if pos_end == &#39;&#39;:
                    pos_end = None
                if pos_end:
                    if int(pos_end) &lt; int(pos_begin):
                        pos_end = None
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)#, nrows = current_page * 10)   
            df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if chr:
                if pos_end is None:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
            if ((current_page - 1) * 10) &gt; len(df): 
                current_page = current_page -1
                if current_page &lt; 1:
                    current_page = 1
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, current_page, mms, max_bulges,guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
        else:                       #Go to previous page
            current_page = current_page - 1
            if current_page &lt; 1:
                current_page = 1

            if chr:
                if pos_begin is None or pos_begin == &#39;&#39;:
                    pos_begin = 0
                if pos_end == &#39;&#39;:
                    pos_end = None
                if pos_end:
                    if int(pos_end) &lt; int(pos_begin):
                        pos_end = None
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)#, nrows = current_page * 10)   
            df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if chr:
                if pos_end is None:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
            
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, current_page, mms, max_bulges,guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)


#If the input guides are different len, select the ones with same length as the first
def selectSameLenGuides(list_guides):
    &#39;&#39;&#39;
    If the user provide guides with different lengths, the function select the first guide, calculate its length, and discards all the guides with
    different lengths.

    ***Args***:

    + **list_guides**: list of the input guides

    ***Returns***

    + **same_len_guides**: list of guides with the same length
    &#39;&#39;&#39;
    selected_length = len(list_guides.split(&#39;\n&#39;)[0])
    same_len_guides_list = []
    for guide in list_guides.split(&#39;\n&#39;):
        if len(guide) == selected_length:
            same_len_guides_list.append(guide)
    same_len_guides = &#39;\n&#39;.join(same_len_guides_list).strip()
    return same_len_guides

def resultPage(job_id):
    &#39;&#39;&#39;
    The function creates the layout for the Result Page, with the general summary table at the top, the popup Population histogram section, the 
    Tabs for the three different summaries and report (Guide, Sample, Position, Graphical Sumamary).
    
    ***Args***

    + **job_id**: string containing the jobbID of the current job

    ***Returns***

    + **result_page**: list of Dash Components for the layout of the page
    &#39;&#39;&#39;
    value = job_id
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    if (not isdir(job_directory)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))

    #Load informations from the Params file
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
        bulge_dna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;DNA&#39; in s)).split(&#39;\t&#39;)[-1]
        bulge_rna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;RNA&#39; in s)).split(&#39;\t&#39;)[-1]
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        max_bulges = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1]

    genome_name = genome_type_f
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
        genome_name = genome_name.split(&#39;_&#39;)[0] + &#39; Variants&#39;
    else:
        genome_name = genome_name.split(&#39;_&#39;)[0] + &#39; Reference&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    mms = int(mms[0])    
    
    #load acfd for each guide 
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/acfd.txt&#39;) as a:
        all_scores = a.read().strip().split(&#39;\n&#39;)
    
    list_error_guides = []
    if os.path.exists(current_working_directory + &#39;Results/&#39; + value + &#39;/guides_error.txt&#39;):
        with open(current_working_directory + &#39;Results/&#39; + value + &#39;/guides_error.txt&#39;) as error_g:
            for e_g in error_g:
                list_error_guides.append(e_g.strip())

    #Columns for the main table
    col_targetfor = &#39;(&#39;
    for i in range(1, mms + int(max_bulges)):
        col_targetfor = col_targetfor + str(i) + &#39;-&#39;
    col_targetfor = col_targetfor + str(mms + int(max_bulges))
    col_targetfor = col_targetfor + &#39; Mismatches + Bulges)&#39;
    
    columns_profile_table = [ 
        {&#39;name&#39;:[&#39;&#39;, &#39;Guide&#39;], &#39;id&#39;:&#39;Guide&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;CFD&#39;], &#39;id&#39;:&#39;CFD&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Doench 2016&#39;], &#39;id&#39;:&#39;Doench 2016&#39;, &#39;type&#39;:&#39;text&#39;},    #Doench, only for REF or VAR
        {&#39;name&#39;:[&#39;Doench 2016&#39;, &#39;Reference&#39;], &#39;id&#39;:&#39;Reference&#39;, &#39;type&#39;:&#39;text&#39;},        #REF Doench, only for Both
        {&#39;name&#39;:[&#39;Doench 2016&#39;, &#39;Enriched&#39;], &#39;id&#39;:&#39;Enriched&#39;, &#39;type&#39;:&#39;text&#39;},          #VAR Doench, only for Both
        {&#39;name&#39;:[&#39;&#39;, &#39;On-Targets Reference&#39;], &#39;id&#39;:&#39;On-Targets Reference&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;On-Targets Enriched&#39;], &#39;id&#39;:&#39;On-Targets Enriched&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39;], &#39;id&#39;:&#39;Samples in Class 0 - 0+ - 1 - 1+&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Genome&#39;], &#39;id&#39;:&#39;Genome&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;Off-targets for Mismatch (MM) + Bulge (B) Value&#39;, &#39;Total&#39;], &#39;id&#39;:&#39;Total&#39;, &#39;type&#39;:&#39;text&#39;}
        ]    #Column of headers . Remove the entries accordingly when checking type of genome
    
    for i in range (1, mms + int(max_bulges) + 1):
        columns_profile_table.append({&#39;name&#39;:[&#39;Off-targets for Mismatch (MM) + Bulge (B) Value&#39;, str(i) + &#39; MM + B&#39;], &#39;id&#39;: str(i) + &#39; MM + B&#39;, &#39;type&#39;:&#39;text&#39;})
    remove_indices = set()
    
    if &#39;NO SCORES&#39; in all_scores:
        # remove_indices.update([1,2,3,4])    #Remove CFD and Doench header
        remove_indices.update(&#39;CFD&#39;, &#39;Doench 2016&#39;, &#39;Reference&#39;, &#39;Enriched&#39;)
    
    if genome_type == &#39;ref&#39;:
        # remove_indices.update([3,4,6,7])
        remove_indices.update([&#39;Reference&#39;, &#39;Enriched&#39;, &#39;On-Targets Enriched&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39; ])
    elif genome_type == &#39;both&#39;:
        # remove_indices.update([6])
        remove_indices.update([&#39;Doench 2016&#39;,&#39;On-Targets Enriched&#39;])
    else:
        # remove_indices.update([3,4,5,7])
        remove_indices.update([&#39;Reference&#39;, &#39;Enriched&#39;, &#39;On-Targets Reference&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39;])
    
    #Remove headers not used in selected search result
    columns_profile_table = [i for j, i in enumerate(columns_profile_table) if columns_profile_table[j][&#39;id&#39;] not in remove_indices]      
    
    final_list = []    
    if list_error_guides:   #If some guides were not processed due to too many targets
        final_list.append(
            dbc.Alert(
                [
                    &#39;Warning: Some guides have too many targets! &#39;,
                    html.A(&#34;Click here&#34;, href= URL + &#34;/data/&#34; + job_id + &#39;/guides_error.txt&#39;, className=&#34;alert-link&#34;),
                    &#39; to view them&#39;
                ], color=&#39;warning&#39;)
        )
    final_list.append(
        html.H3(&#39;Result Summary - &#39; + genome_name + &#39; - Mismatches &#39; + str(mms) + &#39; - DNA &#39; + bulge_dna + &#39; - RNA &#39; + bulge_rna)
    )
   
    add_to_description = html.P(
        &#39;General summary for the given guides. For each guide, the number of Off-Targets found for each Mismatch + Bulge value is shown.&#39;
    )
    if genome_type == &#39;both&#39;:
        add_to_description = html.P(
            [
                &#39;General summary for the given guides. For each guide, the number of &#39;,  
                html.Span(
                    &#34;Samples for each Class is provided&#34;,
                    id=&#34;tooltip-sample-class&#34;,
                    style={&#34;textDecoration&#34;: &#34;underline&#34;, &#34;cursor&#34;: &#34;pointer&#34;}
                ),
                &#39;, along with the number of Off-Targets found for each Mismatch + Bulge value, for both Reference and Enriched Genomes.&#39;,
                dbc.Tooltip(
                    [
                        html.Div([html.P([html.B(&#39;Class 0:&#39;), &#39; Samples that does not have any On-Targets&#39;]),
                        html.P([html.B(&#39;Class 0+:&#39;), &#39; Samples that have a subset of the Reference Genome On-Targets&#39;]),
                        html.P([html.B(&#39;Class 1:&#39;), &#39; Samples that have the same On-Targets as the Reference Genome&#39;]),
                        html.P([html.B(&#39;Class 1+:&#39;), &#39; Samples that creates at least a new On-Target, that is not present in the Reference Genome&#39;])], 
                        style = {&#39;display&#39;:&#39;inline-block&#39;})
                    ],
                    target=&#34;tooltip-sample-class&#34;, style = {&#39;font-size&#39;: &#39;12px&#39;}
                )
            ]
        )
    final_list.append(add_to_description)
    final_list.append(
        html.Div(
            dash_table.DataTable(
                id = &#39;general-profile-table&#39;,
                columns = columns_profile_table,
                merge_duplicate_headers=True,
                #fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                selected_cells = [{&#39;row&#39;:0, &#39;column&#39;:0}],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                page_current= 0,
                page_size= PAGE_SIZE,
                page_action=&#39;custom&#39;,
                #virtualization = True,
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,

                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                style_table={
                    &#39;max-height&#39;: &#39;260px&#39;,
                    &#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data={
                    &#39;whiteSpace&#39;: &#39;pre&#39;,
                    &#39;height&#39;: &#39;auto&#39;,
                    &#39;font-size&#39;:&#39;1.30rem&#39;
                },
                style_data_conditional = [
                    {
                        &#39;if&#39;: {
                                &#39;column_id&#39; :&#39;Genome&#39;
                            },
                            &#39;font-weight&#39;:&#39;bold&#39;,
                            &#39;textAlign&#39;: &#39;center&#39;
                            
                    }
                ]
            )
            ,id = &#39;div-general-profile-table&#39;)
    )

    final_list.append(html.Br())

    if genome_type == &#39;ref&#39;:
        final_list.append(
        dcc.Tabs(id=&#34;tabs-reports&#34;, value=&#39;tab-summary-by-guide&#39;, children=[
            dcc.Tab(label=&#39;Summary by Guide&#39;, value=&#39;tab-summary-by-guide&#39;),
            dcc.Tab(label=&#39;Summary by Position&#39;, value=&#39;tab-summary-by-position&#39;),
            dcc.Tab(label=&#39;Graphical Summary&#39;, value=&#39;tab-summary-graphical&#39;),
        ])
    )
    else:
        #Barplot for population distributions
        final_list.append(
            html.Div(
                [
                    dbc.Row(
                        [
                            dbc.Col(html.Button(&#34;Show/Hide Target Distribution in SuperPopulations&#34;, id=&#34;btn-collapse-populations&#34;)),
                        ]
                    ),
                    dbc.Collapse(
                        dbc.Card(dbc.CardBody(
                            html.Div(id = &#39;content-collapse-population&#39;)
                        )),
                        id=&#34;collapse-populations&#34;,
                    ),
                ]
            )
        )
        final_list.append(html.Br())
        final_list.append(
            dcc.Tabs(id=&#34;tabs-reports&#34;, value=&#39;tab-summary-by-guide&#39;, children=[
                dcc.Tab(label=&#39;Summary by Guide&#39;, value=&#39;tab-summary-by-guide&#39;),
                dcc.Tab(label=&#39;Summary by Sample&#39;, value=&#39;tab-summary-by-sample&#39;),
                dcc.Tab(label=&#39;Summary by Position&#39;, value=&#39;tab-summary-by-position&#39;),
                dcc.Tab(label=&#39;Graphical Summary&#39;, value=&#39;tab-summary-graphical&#39;),
            ])
        )
    final_list.append(html.Div(id = &#39;div-tab-content&#39;))

    final_list.append(html.Div(genome_type, style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-genome-type&#39;))
    result_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return result_page

#Update color on selected row
@app.callback(
    Output(&#39;general-profile-table&#39;, &#39;style_data_conditional&#39;),
    [Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;)]
)
def colorSelectedRow(sel_cel, all_guides):
    &#39;&#39;&#39;
    Update the background color of the row of the main table when the user clicks on a cell. Also change to bold the &#39;Reference&#39; and &#39;Enriched&#39;
    labels.

    ***Args***

    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table

    ***Returns***

    + **general-profile-table** (*style_data_conditional*): dictionary of the style for the main table
    &#39;&#39;&#39;
    if sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    #Change background color of all the rows that have the &#39;Guide&#39; column equal to the selected guide (guides are unique)
    return [
        {
            &#39;if&#39;: {
                    &#39;filter_query&#39;: &#39;{Guide} eq &#34;&#39; + guide + &#39;&#34;&#39;
                },
                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;
            },
            {
            &#39;if&#39;: {
                    &#39;column_id&#39; :&#39;Genome&#39;
                },
                &#39;font-weight&#39;:&#39;bold&#39;,
                &#39;textAlign&#39;: &#39;center&#39;      
            }
    ]

# Filtering e sorting e load data per la pagina principale delle guide
@app.callback(
    [Output(&#39;general-profile-table&#39;, &#39;data&#39;),
    Output(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [Input(&#39;general-profile-table&#39;, &#34;page_current&#34;),
     Input(&#39;general-profile-table&#39;, &#34;page_size&#34;),
     Input(&#39;general-profile-table&#39;, &#39;sort_by&#39;),
     Input(&#39;general-profile-table&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]    
)
def update_table_general_profile(page_current, page_size, sort_by, filter, search):
    &#39;&#39;&#39;
    The function loads the data to be shown into the table. 

    ***Args***

    + [**page_current**] **general-profile-table** (*page_current*): int of the current page to show
    + [**page_size**] **general-profile-table** (*page_size*): int of the maximum number of row for each page
    + [**sort_by**] **general-profile-table** (*sort_by*): list dictionaries of column IDs and sorting direction
    + [**filter**] **general-profile-table** (*filter_query*): list dictionaries for the data filtering
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **general-profile-table** (*data*): dictionary of the data to be shown
    + **general-profile-table** (*selected_cells*): dictionary containing the selected cell, default at first row
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        mms = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1])
        max_bulges = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1])
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    
    #Get error guides
    list_error_guides = []
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides_error.txt&#39;):
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides_error.txt&#39;) as error_g:
            for e_g in error_g:
                list_error_guides.append(e_g.strip())
    
    #Get guide from guide.txt
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides.txt&#39;) as g:
        guides = g.read().strip().split(&#39;\n&#39;)
        guides.sort()

    #load acfd for each guide 
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/acfd.txt&#39;) as a:
        all_scores = a.read().strip().split(&#39;\n&#39;)
    
    #Load scores
    if &#39;NO SCORES&#39; not in all_scores:
        all_scores.sort()
        acfd = [float(a.split(&#39;\t&#39;)[1]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        doench = [int(a.split(&#39;\t&#39;)[2]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        if genome_type == &#39;both&#39;:
            doench_enr = [int(a.split(&#39;\t&#39;)[3]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        acfd  = [int(round((100/(100 + x))*100)) for x in acfd] 

    #Get target counting from summary by guide
    column_on_target = []
    column_off_target_ref = []
    column_sample_class = []
    column_total = []
    if genome_type == &#39;ref&#39; or genome_type == &#39;var&#39;:
        for g in guides:
            one_to_n_mms = []
            df_profile = pd.read_pickle(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.summary_by_guide.&#39; + g + &#39;.txt&#39;)
            on_t_ref = int(df_profile[(df_profile.Mismatches == 0) &amp; (df_profile[&#39;Bulge Type&#39;] == &#39;X&#39;)].iloc[0][&#39;Targets in Reference&#39;])
            try: #For VAR, read enriched values
                on_t_enr = int(df_profile[(df_profile.Mismatches == 0) &amp; (df_profile[&#39;Bulge Type&#39;] == &#39;X&#39;)].iloc[0][&#39;Targets in Enriched&#39;]) 
                column_on_target.append(str(on_t_enr))
            except: #For REF, read only reference values
                column_on_target.append(str(on_t_ref))
            
            for i in range (1, mms + 1 + int(max_bulges)):         #For column Targets for 1-2 Total (Mismatches + Bulges), sum values for row with same total
                try:    #For VAR
                    one_to_n_mms.append(sum(df_profile[((df_profile[&#39;Mismatches&#39;] + df_profile[&#39;Bulge Size&#39;]) == i)][&#39;Targets in Enriched&#39;].to_list()))
                except: #For REF
                    one_to_n_mms.append(sum(df_profile[((df_profile[&#39;Mismatches&#39;] + df_profile[&#39;Bulge Size&#39;]) == i)][&#39;Targets in Reference&#39;].to_list()))
            column_total.append(int(sum(one_to_n_mms)))
            column_off_target_ref.append([int(x) for x in one_to_n_mms])  #[[1, 5, 10], [3, 7, 20]]       each internal list is the number of off-target for a guide, divided by value (from 1 to mm+max_bulge)
    else:
        #NOTE  USO IL CONTEGGIO PRESO DA jobid.general_target_count.txt
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.general_target_count.txt&#39;) as general_count:
            header_general = next(general_count) #skip header
            general_count_content = general_count.read().strip().split(&#39;\n&#39;)
            general_count_content.sort(key = lambda x : x[0])
        guides = []
        column_on_target_old = dict()      #will contain GUIDE -&gt; 3(1 - 2), then later, in column_on_target, only the 1 will be kept
        for tmp in general_count_content:
            tmp = tmp.split(&#39;\t&#39;)   #[GUIDE, total_onT (onT_ref - onTvar), total_offT_ref ( - - - ), total_offT_var ( - - -)]
            guides.append(tmp[0])
            column_on_target_old[tmp[0]] = tmp[1]      #tmp[1] =  3(1 - 2)
            a = tmp[2].replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).replace(&#39;-&#39;,&#39;&#39;).replace(&#39;  &#39;,&#39; &#39;).strip().split(&#39; &#39;) # ottengo in a[0] il total, da a[1:] il numero di targets per 1 2 3 ... Total del REF
            b = tmp[3].replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).replace(&#39;-&#39;,&#39;&#39;).replace(&#39;  &#39;,&#39; &#39;).strip().split(&#39; &#39;) # ottengo in a[0] il total, da a[1:] il numero di targets per 1 2 3 ... Total del VAR
            column_total.append(a[0] + &#39;\n&#39; + b[0] + &#39;\n&#39; + str(int(a[0]) + int(b[0])))
            column_off_target_ref.append(
                [a[x] + &#39;\n&#39; + b[x] + &#39;\n&#39; + str(int(a[x]) + int(b[x])) for x in range(len(a))][1:]     #[1:] to skip total value
            )   # in the end i obtain [ [&#39;1\n3\n5&#39;, &#39;12\n21\n54&#39;] , [&#39;0\n3\n4&#39;, &#39;12\n25\n34&#39;]], one list per guide, inside each list string for each total value
            
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.SampleClasses.txt&#39;) as samp_classes:
            header_classes = next(samp_classes).strip().split(&#39;\t&#39;)[1:]     #List of Guides
            for line in samp_classes:
                if &#39;Total for Class&#39; in line:       #Last line
                    value_classes = line.strip().split(&#39;\t&#39;)[1:]           #List of values of classes for each guide
        #NOTE just for changing &#39;-&#39; to &#39; - &#39;
        for pos_vc, vc in enumerate(value_classes):
            value_classes[pos_vc] = &#39; - &#39;.join(vc.split(&#39;-&#39;))
        
        dict_classes = dict(zip(header_classes, value_classes))
        column_on_target = []
        for g in guides:
            column_sample_class.append(dict_classes[g]) 
            column_on_target.append(column_on_target_old[g].split(&#39;(&#39;)[-1].split(&#39;-&#39;)[0])

    data_guides = dict()
    data_guides[&#39;Guide&#39;] = guides
    if &#39;NO SCORES&#39; not in all_scores:
        data_guides[&#39;CFD&#39;] = acfd
        if genome_type == &#39;both&#39;:
            data_guides[&#39;Reference&#39;] = doench
            data_guides[&#39;Enriched&#39;] = doench_enr
        else:
            data_guides[&#39;Doench 2016&#39;] = doench

    if genome_type == &#39;ref&#39; or genome_type == &#39;both&#39;:
        data_guides[&#39;On-Targets Reference&#39;] = column_on_target
        data_guides[&#39;Genome&#39;] = &#39;REFERENCE&#39;     #NOTE if genome_type == &#39;both&#39;, it will be updated
    else:
        data_guides[&#39;On-Targets Enriched&#39;] = column_on_target
        data_guides[&#39;Genome&#39;] = &#39;ENRICHED&#39;

    if genome_type == &#39;both&#39;:
        data_guides[&#39;Samples in Class 0 - 0+ - 1 - 1+&#39;] = column_sample_class
        data_guides[&#39;Genome&#39;] = &#39;REFERENCE\nENRICHED\nCOMBINED&#39;
    data_guides[&#39;Total&#39;] = column_total
    for i in range (1, mms + int(max_bulges) + 1):  #add count target for each total value
        data_guides[str(i) + &#39; MM + B&#39;] = [str(x[i-1]) for x in column_off_target_ref]      #NOTE i-1 since i starts from 1

    dff = pd.DataFrame(data_guides)
    
    if &#39;NO SCORES&#39; not in all_scores:
        try:
            dff = dff.sort_values([&#39;CFD&#39;, &#39;Doench 2016&#39;], ascending = [False, False])
        except: #for BOTH
            dff = dff.sort_values([&#39;CFD&#39;, &#39;Enriched&#39;], ascending = [False, False])
    else:
        try:
            dff = dff.sort_values(&#39;On-Targets Reference&#39;, ascending = True)
        except:
            dff = dff.sort_values(&#39;On-Targets Enriched&#39;, ascending = True)

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    return data_to_send, [{&#39;row&#39;:0, &#39;column&#39;:0}]


#Open/close barplot for population distribution
@app.callback(
    Output(&#34;collapse-populations&#34;, &#34;is_open&#34;),
    [Input(&#34;btn-collapse-populations&#34;, &#34;n_clicks&#34;)],
    [State(&#34;collapse-populations&#34;, &#34;is_open&#34;)],
)
def toggleCollapseDistributionPopulations(n, is_open):
    &#39;&#39;&#39;
    Open/Close the section containing the Population Distributions barplots.

    ***Args***

    + [**n**] **btn-collapse-populations** (*n_clicks*): int for the number of times the button was clicked
    + [**is_open**] **collapse-populations** (*is_open*): bool for the status of the component (True: is open, False: is closed)

    ***Returns***

    + **collapse-populations** (*is_open*): True to show, False to hide
    &#39;&#39;&#39;
    if n:
        return not is_open
    return is_open

#Load barplot of population distribution for selected guide
@app.callback(
    Output(&#39;content-collapse-population&#39;, &#39;children&#39;),
    [Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;url&#39;,&#39;search&#39;)]
)
def loadDistributionPopulations(sel_cel, all_guides, job_id):
    &#39;&#39;&#39;
    Load the barplot images from the &#39;assets&#39; directory.

    ***Args***

    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **content-collapse-population** (*children*): list of Dash Components with the images of the Populations Distribution
    &#39;&#39;&#39;
    if sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    job_id = job_id.split(&#39;=&#39;)[-1]

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1])
        max_bulges = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1])

    distributions = [dbc.Row(html.P(&#39;On- and Off-Targets distributions in the Reference and Enriched Genome. For the Enriched Genome, the targets are divided into 5 SuperPopulations (EAS, EUR, AFR, AMR, SAS).&#39;, style = {&#39;margin-left&#39;:&#39;0.75rem&#39;}))]

    for i in range(math.ceil((mms + max_bulges + 1) / BARPLOT_LEN)):
        all_images = []
        for mm in range (i * BARPLOT_LEN, (i + 1) * BARPLOT_LEN ):
            if mm &lt; (mms + max_bulges + 1):
                try:
                    all_images.append(
                        dbc.Col(  
                            [   
                                html.A(
                                    html.Img(
                                        src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/populations_distribution_&#39; + guide + &#39;_&#39; + str(mm) + &#39;total.png&#39;, &#39;rb&#39;).read()).decode()),
                                        id = &#39;distribution-population&#39; + str(mm), width=&#34;100%&#34;, height=&#34;auto&#34;
                                    ),
                                    target=&#34;_blank&#34;,
                                    href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + &#39;populations_distribution_&#39; + guide + &#39;_&#39; + str(mm) + &#39;total.png&#39;
                                ),
                                html.Div(html.P(&#39;Distribution &#39; + str(mm) + &#39; Mismatches + Bulges &#39;, style = {&#39;display&#39;:&#39;inline-block&#39;} ),style = {&#39;text-align&#39;:&#39;center&#39;})
                            ]
                        )
                    )
                except:
                    all_images.append(
                        dbc.Col(
                            [
                                html.Div(html.P(&#39;No Targets found with &#39; + str(mm) + &#39; Mismatches + Bulges&#39; , style = {&#39;display&#39;:&#39;inline-block&#39;}), style = {&#39;text-align&#39;:&#39;center&#39;}),
                                # html.Div(html.P(&#39;Distribution &#39; + str(mm) + &#39; Mismatches + Bulges &#39;, style = {&#39;display&#39;:&#39;inline-block&#39;} ),style = {&#39;text-align&#39;:&#39;center&#39;})
                            ],
                            align = &#39;center&#39;
                        )
                    )
            else:
                all_images.append(dbc.Col(html.P(&#39;&#39;)))
        
        distributions.append(
            html.Div(
                [
                    dbc.Row(
                        all_images
                    )
                ]
            )
        )
    return distributions

@cache.memoize()
def global_store_subset(value, bulge_t, bulge_s, mms, guide):
    &#39;&#39;&#39;
    Caching of files for the subset table in the &#39;Show Targets&#39; link of the Summary by Guide tabe, to improve loading speed. NOTE that if two 
    files have the same name, then the generated cache will be the same, so a regular cleaning of the &#39;Cache&#39; directory is mandatory.

    ***Args***

    + **value**: string of the job ID to load 
    + **bulge_t**: string of the type of bulge selected
    + **bulge_s**: string of the number of bulges selected
    + **mms**: string of the number of mismatches selected
    + **guide**: string of the selected guide

    ***Returns***

    + **df**: dataframe for the subset table of the &#39;Show Targets&#39; table of the Summary by Guide
    &#39;&#39;&#39;
    if value is None:
        return &#39;&#39;
    #Skiprows = 1 to skip header of file
    df = pd.read_csv( current_working_directory + &#39;Results/&#39; + value + &#39;/&#39; + value + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;, header = None) #, skiprows = 1)
    return df

#&#39;Show target&#39; page of the Summary by Guide tab
def guidePagev3(job_id, hash):
    &#39;&#39;&#39;
    Creates the layout for the &#39;Show Targets&#39; page of the Summary by Guide tab.

    ***Args***

    + **job_id**: string of the jobID
    + **hash**: string containing the informations about the selected &#39;Show Targets&#39; row, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewDNA10&#39;

    ***Returns***

    + list of Dash Components containing the layout of the page
    &#39;&#39;&#39;
    guide = hash[:hash.find(&#39;new&#39;)]
    mms = hash[-1:]
    bulge_s = hash[-2:-1]
    if &#39;DNA&#39; in hash:
        bulge_t = &#39;DNA&#39;
    elif &#39;RNA&#39; in hash:
        bulge_t = &#39;RNA&#39;
    else:
        bulge_t = &#39;X&#39;
    add_header = &#39; - Mismatches &#39; + str(mms)
    if bulge_t != &#39;X&#39;:
        add_header += &#39; - &#39; + str(bulge_t) + &#39; &#39; + str(bulge_s) 
    value = job_id
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    style_hide_reference = {&#39;display&#39;:&#39;none&#39;}
    value_hide_reference = []
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
        style_hide_reference = {}
        value_hide_reference = [&#39;hide-ref&#39;]
    final_list = []
    final_list.append(html.H3(&#39;Selected Guide: &#39; + guide + add_header))
    final_list.append(
        html.P(
            [
                &#39;List of Targets found for the selected guide. Select a row to view other possible configurations of the target, along with the corresponding samples list.&#39;, # &#39;Select a row to view the target IUPAC character scomposition. The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
                dcc.Checklist(options = [{&#39;label&#39;: &#39;Hide Reference Targets&#39;, &#39;value&#39;: &#39;hide-ref&#39;}], id=&#39;hide-reference-targets&#39;, value = value_hide_reference, style = style_hide_reference),
                html.Div(
                    [   
                        html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbyguide&#39;), 
                        dcc.Interval(interval = 5*1000, id = &#39;interval-sumbyguide&#39;)
                    ]
                )
            ]
        )
    )
    if genome_type == &#39;ref&#39;:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_REF, COL_REF_TYPE)]    
        file_to_grep = &#39;.Annotation.targets.txt&#39;#&#39;.top_1.txt&#39;
    else:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
        file_to_grep = &#39;.samples.annotation.txt&#39;
    
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide_grep_result = job_directory + job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide + &#39;.txt&#39;
    put_header = &#39;head -1 &#39; + job_directory + job_id + file_to_grep + &#39; &gt; &#39; + guide_grep_result + &#39; ; &#39;
    final_list.append(
        html.Div(job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbyguide-targets&#39;)
    )
    
    if not os.path.exists(guide_grep_result):    #Example    job_id.X.0.4.guide.txt #NOTE HEADER NON SALVATO
        subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + job_directory + job_id + file_to_grep + &#39; | LC_ALL=C grep -F &#39; + bulge_t + &#39; | awk \&#39;$8==&#39; + mms + &#39; &amp;&amp; $9==&#39; + bulge_s + &#39;\&#39;&gt; &#39; + guide_grep_result], shell = True)
        subprocess.Popen([&#39;zip &#39; + guide_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + guide_grep_result], shell = True)
    global_store_subset(job_id, bulge_t, bulge_s, mms,guide)
    
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-subset-target&#39;, 
                columns=cols, 
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_cell_conditional=[
                    {
                        &#39;if&#39;: {&#39;column_id&#39;: &#39;Samples&#39;},
                        &#39;textAlign&#39;: &#39;left&#39;
                    }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                style_data_conditional = [
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                            },
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;
                        },
                ]            
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    final_list.append(html.Br())
    final_list.append(
        html.Div(
            id = &#39;div-second-table-subset-targets&#39;
        )
    )
    
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

#Update primary table of &#39;Show targets&#39; of Summary by Guide
@app.callback(
    Output(&#39;table-subset-target&#39;, &#39;data&#39;),
    [Input(&#39;table-subset-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-subset-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-subset-target&#39;, &#34;sort_by&#34;),
     Input(&#39;table-subset-target&#39;, &#39;filter_query&#39;),
     Input(&#39;hide-reference-targets&#39;, &#39;value&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_table_subset(page_current, page_size, sort_by, filter, hide_reference, search, hash_guide):
    &#39;&#39;&#39;
    Function that returns the data to be shown in the &#39;Show Targets&#39; table of the Summary by Guide. 

    ***Args***

    + [**page_current**] **table-subset-target** (*page_current*): int of the current page to show
    + [**page_size**] **table-subset-target** (*page_size*): int of the maximum number of row for each page
    + [**sort_by**] **table-subset-target** (*sort_by*): list dictionaries of column IDs and sorting direction
    + [**filter**] **table-subset-target** (*filter_query*): list dictionaries for the data filtering
    + [**hide_reference**] **hide-reference-targets** (*value*): if the value is not None, then the Reference targets are removed from the shown data
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**hash_guide**] **url** (*hash*): string containing the informations about the selected &#39;Show Targets&#39; row, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewDNA10&#39;
    
    ***Returns***

    + **table-subset-target** (*data*): dictionary of the data to be shown
    
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
    
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    value = job_id
    if search is None:
        raise PreventUpdate
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    #filtering_expressions.append([&#39;{crRNA} = &#39; + guide])   
    guide = hash_guide[1:hash_guide.find(&#39;new&#39;)]
    mms = hash_guide[-1:]
    bulge_s = hash_guide[-2:-1]
    if &#39;DNA&#39; in hash_guide:
        bulge_t = &#39;DNA&#39;
    elif &#39;RNA&#39; in hash_guide:
        bulge_t = &#39;RNA&#39;
    else:
        bulge_t = &#39;X&#39;  
    df = global_store_subset(value, bulge_t, bulge_s, mms, guide)
    dff = df
    if genome_type == &#39;ref&#39;:
        dff.rename(columns = COL_REF_RENAME, inplace = True)
    else:
        dff.rename(columns = COL_BOTH_RENAME , inplace = True)

    if &#39;hide-ref&#39; in hide_reference or genome_type == &#39;var&#39;:
        dff.drop( df[(df[&#39;Samples&#39;] == &#39;n&#39;)].index, inplace = True)
    
    try:    #For VAR and BOTH
        del dff[&#39;Variant Unique&#39;]
    except: #For REF
        pass

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)
        if col_name == &#39;Samples Summary&#39;:
            col_name = &#39;Samples&#39;
        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
   
    cells_style = [
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                            &#39;if&#39;: {
                                    &#39;filter_query&#39;: &#39;{Cluster Position} eq &#34;&#39; + guide + &#39;&#34;&#39;, 
                                    #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                                    #&#39;column_id&#39; :&#39;{Total}&#39;
                                },
                                #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                                
                        },
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send#, cells_style + style_data_table

#Create second table for subset targets page, and show corresponding samples    -&gt; CHANGED, now show IUPAC scomposition
@app.callback(
    [Output(&#39;div-second-table-subset-targets&#39;, &#39;children&#39;),
    Output(&#39;table-subset-target&#39;, &#39;style_data_conditional&#39;)],
    [Input(&#39;table-subset-target&#39;, &#39;active_cell&#39;)],
    [State(&#39;table-subset-target&#39;, &#39;data&#39;),
    State(&#39;table-subset-target&#39;, &#39;columns&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;table-subset-target&#39;, &#39;style_data_conditional&#39;),
    State(&#39;table-subset-target&#39;, &#39;selected_cells&#39;)]
)
def loadFullSubsetTable(active_cel, data, cols, search, style_data, sel_cell):
    #NOTE tabella secondaria della scomposizione ora non serve, non cancello il codice ma uso PreventUpdate per non azionare la funzione
    if False:
        raise PreventUpdate
    if active_cel is  None:
        raise PreventUpdate
    fl = []
    job_id = search.split(&#39;=&#39;)[-1]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
    
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    if genome_type == &#39;ref&#39;:
        raise PreventUpdate
    #fl.append(html.Br())
    fl.append(html.Hr())
    #Table for IUPAC scomposition
    #fl.append(html.Br())
    fl.append(&#39;List of all the configurations for the selected target.&#39;)
    fl.append(html.Br())
    cols.append({&#34;name&#34;: &#39;Samples&#39;, &#34;id&#34;: &#39;Samples&#39;, &#39;type&#39;:&#39;text&#39;, &#39;hideable&#39;:True})  

       
    fl.append(
        html.Div(
            dash_table.DataTable(
                id=&#39;second-table-subset-targets&#39;, 
                columns=cols, 
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                },
                style_cell_conditional=[
                    {
                        &#39;if&#39;: {&#39;column_id&#39;: &#39;Samples&#39;},
                        &#39;textAlign&#39;: &#39;left&#39;
                    }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                style_data_conditional = [
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                        }
                ]         
            )
        )
    )

    pos_cluster = data[int(sel_cell[0][&#39;row&#39;])][&#39;Cluster Position&#39;]
    chrom = data[int(sel_cell[0][&#39;row&#39;])][&#39;Chromosome&#39;]
    cells_style = [
                       style_data[0],
                        {
                            &#39;if&#39;: {
                                    &#39;filter_query&#39;: &#39;{Cluster Position} eq &#34;&#39; + str(pos_cluster) + &#39;&#34;&#39;,
                                    ##&#39;filter_query&#39;: &#39;{Chromosome} eq &#34;&#39; + str(chrom) + &#39;&#34;&#39;,
                                    #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                                    #&#39;column_id&#39; :&#39;{Total}&#39;
                                },
                                #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                                
                        }
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    return  fl, cells_style

#Filter etc for second tabe
@app.callback(
    [Output(&#39;second-table-subset-targets&#39;, &#39;data&#39;),                         #Table showing iupac scomposition
    Output(&#39;second-table-subset-targets&#39;, &#39;style_data_conditional&#39;)],
    [Input(&#39;second-table-subset-targets&#39;, &#34;page_current&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#34;page_size&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#34;sort_by&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#39;filter_query&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;),
     State(&#39;table-subset-target&#39;, &#39;active_cell&#39;),
    State(&#39;table-subset-target&#39;, &#39;data&#39;)]
)
def update_table_subsetSecondTable(page_current, page_size, sort_by, filter, search, hash_guide, active_cel, data):
    #NOTE tabella secondaria della scomposizione ora non serve, non cancello il codice ma uso PreventUpdate per non azionare la funzione
    if False:
        raise PreventUpdate
    if active_cel is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]

    guide = hash_guide[1:hash_guide.find(&#39;new&#39;)]
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    if search is None:
        raise PreventUpdate

    if genome_type == &#39;ref&#39;:
        raise PreventUpdate    

    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    bulge_t =  data[active_cel[&#39;row&#39;]][&#39;Bulge Type&#39;]
    bulge_s = str(data[active_cel[&#39;row&#39;]][&#39;Bulge Size&#39;])
    mms = str(data[active_cel[&#39;row&#39;]][&#39;Mismatches&#39;])
    chrom = str(data[active_cel[&#39;row&#39;]][&#39;Chromosome&#39;])
    pos = str(data[active_cel[&#39;row&#39;]][&#39;Cluster Position&#39;])
    # annotation_type = str(data[active_cel[&#39;row&#39;]][&#39;Annotation Type&#39;])

    scomposition_file = job_directory + job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide + &#39;.&#39; + chrom + &#39;.&#39; + pos + &#39;.scomposition.txt&#39;
    file_to_grep = &#39;.samples.annotation.txt&#39;

    if not os.path.exists(scomposition_file):    #Example    job_id.X.0.4.GUIDE.chrom.position.scomposition.txt
        # subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + pos + &#39; &amp;&amp; $4==\&#34;&#39; + chrom + &#39;\&#34; &amp;&amp; $8==&#39; + mms + &#39; &amp;&amp; $9==&#39; + bulge_s +&#39;\&#39; &gt; &#39; + scomposition_file], shell = True)
        subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + pos + &#39; &amp;&amp; $4==\&#34;&#39; + chrom + &#39;\&#34; &amp;&amp; $9==&#39; + bulge_s + &#39; &amp;&amp; $13!=\&#34;n\&#34;&#39; +&#39;\&#39; &gt; &#39; + scomposition_file], shell = True)
    
    if os.path.getsize(scomposition_file) &gt; 0:          #Check if result grep has at least 1 result
        df = pd.read_csv(scomposition_file, header = None, sep = &#39;\t&#39;)
        # df[&#39;Annotation Type&#39;] = annotation_type
    else:
        raise PreventUpdate
     
    df.rename(columns = COL_BOTH_RENAME , inplace = True)
    df.drop(df[(~( df[&#39;Cluster Position&#39;] == int(data[active_cel[&#39;row&#39;]][&#39;Cluster Position&#39;]))) | (~( df[&#39;Chromosome&#39;] == data[active_cel[&#39;row&#39;]][&#39;Chromosome&#39;]))].index, inplace = True)
    dff = df
    
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
   

    cells_style = [
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                        }
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send, cells_style

@cache.memoize()
def global_store_general(path_file_to_load):
    &#39;&#39;&#39;
    Caching dei file targets per una miglior performance di visualizzazione
    &#39;&#39;&#39;
    if &#39;scomposition&#39; in path_file_to_load:
        rows_to_skip = 0
    else:
        rows_to_skip = 0        #Skip header
    if path_file_to_load is None:
        return &#39;&#39;
    if os.path.getsize(path_file_to_load) &gt; 0: 
        df = pd.read_csv( path_file_to_load , sep = &#39;\t&#39;, header = None, skiprows = rows_to_skip)
    else:
        df = None
    #df.rename(columns = {&#34;#Bulge type&#34;:&#39;Bulge Type&#39;, &#34;#Bulge_type&#34;:&#39;Bulge Type&#39;, &#39;Bulge_Size&#39;:&#39;Bulge Size&#39;}, inplace = True)
    return df

#Return the targets found for the selected sample
def samplePage(job_id, hash):
    guide = hash[:hash.find(&#39;-Sample-&#39;)]
    sample = hash[hash.rfind(&#39;-&#39;) + 1:]
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    final_list = []
    final_list.append(
        #html.P(&#39;List of Targets found for the selected Sample - &#39; + sample + &#39; - and guide - &#39; + guide + &#39; -&#39;)
        html.H3(&#39;Selected Sample: &#39; + sample)
    )
    final_list.append(
        html.P(
            [
                &#39;List of Targets found for the selected sample.&#39;, #&#39;The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
                html.Div(
                    [   
                        html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbysample&#39;), 
                        dcc.Interval(interval = 5*1000, id = &#39;interval-sumbysample&#39;)
                    ]

                )
            ]
        )
    )
        
    file_to_grep = &#39;.samples.annotation.txt&#39;
    sample_grep_result = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + sample + &#39;.&#39; + guide + &#39;.txt&#39;
    put_header = &#39;head -1 &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + file_to_grep + &#39; &gt; &#39; + sample_grep_result + &#39; ; &#39;
    final_list.append(
        html.Div(job_id + &#39;.&#39; + sample + &#39;.&#39; + guide,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbysample-targets&#39;)
    )
    # print(&#39;qui sample before grep&#39;)
    # print(&#39;esiste sample?&#39;, str(os.path.exists(sample_grep_result)))

    if not os.path.exists(sample_grep_result):    #Example    job_id.HG001.guide.txt #NOTE HEADER NON SALVATO
        subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | LC_ALL=C grep -F &#39; + sample + &#39; &gt; &#39; + sample_grep_result], shell = True)
        subprocess.Popen([&#39;zip &#39; + sample_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + sample_grep_result],shell = True)
    
    cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
    
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-sample-target&#39;, 
                columns=cols, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                # css= [{ &#39;selector&#39;: &#39;td.row--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.row--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

#Filter and sorting sample targets
@app.callback(
    Output(&#39;table-sample-target&#39;, &#39;data&#39;),
    [Input(&#39;table-sample-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-sample-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-sample-target&#39;, &#39;sort_by&#39;),
     Input(&#39;table-sample-target&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]    
)
def update_table_sample(page_current, page_size, sort_by, filter, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Sample-&#39;)]
    sample = hash[hash.rfind(&#39;-&#39;) + 1:]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + sample + &#39;.&#39; + guide + &#39;.txt&#39;)
    if dff is None:
        raise PreventUpdate
    
    dff.rename(columns = COL_BOTH_RENAME , inplace = True)
    del dff[&#39;Correct Guide&#39;]         #NOTE Drop the Correct Guide column
    del dff[&#39;Variant Unique&#39;]
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Calculate sample count
    dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    for row in data_to_send:
        summarized_sample_cell = dict()
        for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
            if s == &#39;n&#39;:
                break
            try:
                summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
            except:
                summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
        if summarized_sample_cell:
            row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
        else:
            row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send

#Return the targets for the selected cluster
def clusterPage(job_id, hash):
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    style_hide_reference = {&#39;display&#39;:&#39;none&#39;}
    value_hide_reference = []
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
        style_hide_reference = {}
        value_hide_reference = [&#39;hide-ref&#39;, &#39;hide-cluster&#39;]
    final_list = []
    final_list.append(
        html.H3(&#39;Selected Position: &#39; + chromosome + &#39; - &#39; + position)
    )
    
    
    if genome_type == &#39;ref&#39;:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_REF, COL_REF_TYPE)]
        file_to_grep = &#39;.targets.cluster.txt&#39;       
    else:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
        file_to_grep = &#39;.total.cluster.txt&#39;
    # print(&#39;qui cluster before grep&#39;)
    
    cluster_grep_result = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.txt&#39;
    put_header = &#39;head -1 &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + file_to_grep + &#39; &gt; &#39; + cluster_grep_result + &#39; ; &#39;
    # print(&#39;esiste cluster?&#39; , str(os.path.exists(cluster_grep_result)) )
    if not os.path.exists(cluster_grep_result):    #Example    job_id.chr3_100.guide.txt
        #Grep annotation for ref
        if genome_type == &#39;ref&#39;:#NOTE HEADER NON SALVATO
            get_annotation = subprocess.Popen([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.Annotation.targets.txt&#39; + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39;&#39;], shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = get_annotation.communicate()
            annotation_type = out.decode(&#39;UTF-8&#39;).strip().split(&#39;\t&#39;)[-1]
            subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34; {print $0\&#34;\\t&#39; + annotation_type + &#39;\&#34;}\&#39; &gt; &#39; + cluster_grep_result], shell = True)
        else:  
            # print(&#39;qui cluster in grep&#39;)     #NOTE HEADER NON SALVATO       
            subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39; &gt; &#39; + cluster_grep_result], shell = True)  #NOTE top1 will have sample and annotation, other targets will have &#39;.&#39;-&gt; 18/03 all samples and annotation are already writter for all targets
        subprocess.Popen([&#39;zip &#39; + cluster_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + cluster_grep_result], shell = True)
    final_list.append(
        html.Div(job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide ,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbyposition-targets&#39;)
    ) 

    scomposition_file = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.scomposition.txt&#39;
    file_to_grep = &#39;.samples.annotation.txt&#39;

    iupac_scomposition_visibility = {&#39;display&#39;:&#39;none&#39;}
    if genome_type != &#39;ref&#39;:                   
        iupac_scomposition_visibility = {}
        if not os.path.exists(scomposition_file):    #Example    job_id.chr_pos.guide.scomposition.txt
            subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34; &amp;&amp; $13!=\&#34;n\&#34;\&#39; &gt; &#39; + scomposition_file], shell = True)

    final_list.append(html.P(
        [
            html.P(&#39;List of all the configurations for the target in the selected position.&#39;, style = iupac_scomposition_visibility),
            dcc.Checklist(
                options = [{&#39;label&#39;: &#39;Hide Reference Targets&#39;, &#39;value&#39;: &#39;hide-ref&#39;}, {&#39;label&#39;: &#39;Show only TOP1 Target&#39;, &#39;value&#39;: &#39;hide-cluster&#39;}], 
                id=&#39;hide-reference-targets&#39;, value = value_hide_reference, style = style_hide_reference
            ),
            html.Div(
                [   
                    html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbyposition&#39;), 
                    dcc.Interval(interval = 5*1000, id = &#39;interval-sumbyposition&#39;)
                ]

            )
        ]
    )
    )
    
    cols_for_scomposition = cols.copy()
    cols_for_scomposition.append({&#34;name&#34;: &#39;Samples&#39;, &#34;id&#34;: &#39;Samples&#39;, &#39;type&#39;:&#39;text&#39;, &#39;hideable&#39;:True})
    final_list.append(
        html.Div(
            dash_table.DataTable(
                id = &#39;table-scomposition-cluster&#39;,          #TABLE that represent scomposition of iupac of selected target, take rows from top_1.samples.txt
                columns=cols_for_scomposition, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            style = iupac_scomposition_visibility
        )
    )

    final_list.append(html.Hr())

    #Cluster Table
    final_list.append(
        &#39;List of Targets found for the selected position. Other possible configurations of the target are listed in the table above, along with the corresponding samples list.&#39;, # The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
    )
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-position-target&#39;, 
                columns=cols, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    # final_list.append(html.Div(&#39;&#39;, id =&#39;target-to-highlight&#39;))
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})

# #Save the first scomposition target from the second table, in order to highlight it in the first table
# @app.callback(
#     Output(&#39;target-to-highlight&#39;,&#39;children&#39;),
#     [Input(&#39;table-scomposition-cluster&#39;, &#39;data&#39;)],
#     [State(&#39;target-to-highlight&#39;,&#39;children&#39;)]
# )
# def saveFirstScomposedTarget(data_scomp, current_target):
#     if current_target != &#39;&#39; or current_target is None:
#         raise PreventUpdate
#     if data_scomp is None or not data_scomp:
#         raise PreventUpdate
#     return data_scomp[0][&#39;DNA&#39;]

# #update the Color of the top1 scomposed target in the first table
# @app.callback(
#     Output(&#39;table-position-target&#39;, &#39;style_data_conditional&#39;),
#     [Input(&#39;target-to-highlight&#39;, &#39;children&#39;)]
# )
# def highlightSummaryTarget(to_highlight):
#     if to_highlight is None or to_highlight == &#39;&#39;:
#         raise PreventUpdate
#     return [{&#39;if&#39;: {&#39;filter_query&#39;: &#39;{DNA} eq &#39; + to_highlight}, &#39;font-weight&#39;:&#39;bold&#39;}]

#Filter/sort cluster
#Filter and sorting sample targets
@app.callback(
    Output(&#39;table-position-target&#39;, &#39;data&#39;),
    [Input(&#39;table-position-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-position-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-position-target&#39;, &#39;sort_by&#39;),
     Input(&#39;table-position-target&#39;, &#39;filter_query&#39;),
     Input(&#39;hide-reference-targets&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]    
)
def update_table_cluster(page_current, page_size, sort_by, filter, hide_reference, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +  &#39;.txt&#39;)
    if dff is None:
        raise PreventUpdate

    if genome_type == &#39;ref&#39;:
        dff.rename(columns = COL_REF_RENAME, inplace = True)
    else:                           
        dff.rename(columns =COL_BOTH_RENAME , inplace = True)

    if genome_type != &#39;ref&#39;:
        # add_samples = [dff[&#39;Samples&#39;][0]] * dff.shape[0]
        # check_minmms = dff[&#39;Min Mismatches&#39;]
        # if dff[&#39;Variant Unique&#39;][0] != &#39;y&#39; and dff[&#39;PAM Creation&#39;][0] == &#39;n&#39;:
        #     for pos_minmms, minmms in enumerate(check_minmms):
        #         if minmms == &#39;-&#39;:
        #             add_samples[pos_minmms] = &#39;n&#39;
        # dff[&#39;Samples&#39;] = add_samples
        del dff[&#39;Variant Unique&#39;]
        # dff.drop(dff.head(1).index, inplace=True)       #Remove first target, that is the top1 with no iupac (lowest mm of scomposed target) and is 
                                                    #needed only for summary by guide, not the show target part
                                                    #NOTE 18/03 removed all the iupac char, the first line is needed to be shown
    # dff[&#39;Annotation Type&#39;] = list(dff[&#39;Annotation Type&#39;])[0]
    del dff[&#39;Correct Guide&#39;]
    
    if &#39;hide-ref&#39; in hide_reference or genome_type == &#39;var&#39;:
        dff.drop( dff[(dff[&#39;Samples&#39;] == &#39;n&#39;)].index, inplace = True)

    if &#39;hide-cluster&#39; in hide_reference:
        dff = dff.head(1)

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;): 
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send


#Filter/sort IUPAC decomposition table for cluster page
@app.callback(
    Output(&#39;table-scomposition-cluster&#39;,&#39;data&#39;),
    [Input(&#39;table-scomposition-cluster&#39;, &#34;page_current&#34;),
     Input(&#39;table-scomposition-cluster&#39;, &#34;page_size&#34;),
     Input(&#39;table-scomposition-cluster&#39;, &#39;sort_by&#39;),
     Input(&#39;table-scomposition-cluster&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_iupac_scomposition_table_cluster(page_current, page_size, sort_by, filter, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    if genome_type == &#39;ref&#39;:       
        raise PreventUpdate
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.scomposition.txt&#39;)
    if dff is None:
        raise PreventUpdate
    
    # #Grep annotation
    # file_to_grep = &#39;.Annotation.targets.txt&#39;
    # get_annotation = subprocess.Popen([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39;&#39;], shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # out, err = get_annotation.communicate()
    # annotation_type = out.decode(&#39;UTF-8&#39;).strip().split(&#39;\t&#39;)[-1]
    
    # if genome_type == &#39;var&#39;:           
    #     dff.rename(columns = {0:&#39;Bulge Type&#39;, 1:&#39;crRNA&#39;, 2:&#39;DNA&#39;, 3:&#39;Chromosome&#39;, 4:&#39;Position&#39;, 5:&#39;Cluster Position&#39;, 6:&#39;Direction&#39;,
    #     7:&#39;Mismatches&#39;, 8:&#39;Bulge Size&#39;, 9:&#39;Total&#39;, 10:&#39;Min Mismatches&#39;, 11:&#39;Max Mismatches&#39;, 12:&#39;Samples&#39;, 13:&#39;Correct Guide&#39;, 14:&#39;Annotation Type&#39;,15:&#39;Top Subcluster&#39;}, inplace = True)
    # else:
    dff.rename(columns = COL_BOTH_RENAME , inplace = True)
    # dff.drop(dff.columns[[-1,]], axis=1, inplace=True)         #NOTE Drop the Correct Guide column
    del dff[&#39;Correct Guide&#39;]
    #dff[&#39;Annotation Type&#39;] = annotation_type
    del dff[&#39;Variant Unique&#39;]
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break     #If a target have n, it means it&#39;s REF, because either all have samples or the single target is REF
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send

#Generate download link sumbyguide
@app.callback(
    [Output(&#39;download-link-sumbyguide&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbyguide&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbyguide&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbyguide-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkGuide(n, file_to_load, search): #file to load = job_id.RNA.1.0.guide
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False

# Generate download link sumbysample
@app.callback(
    [Output(&#39;download-link-sumbysample&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbysample&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbysample&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbysample-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkSample(n, file_to_load, search): #file to load = job_id.HG001.guide
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False

#Generate download link sumbyposition
@app.callback(
    [Output(&#39;download-link-sumbyposition&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbyposition&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbyposition&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbyposition-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkPosition(n, file_to_load, search): #file to load = 
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False

############################ Genome Database Page Callbacks ##########################

@app.callback(
    Output(&#39;genomes-table&#39;, &#39;data&#39;),
    [Input(&#39;genomes-table&#39;, &#34;page_current&#34;),
     Input(&#39;genomes-table&#39;, &#34;page_size&#34;),
     Input(&#39;genomes-table&#39;, &#39;sort_by&#39;),
     Input(&#39;genomes-table&#39;, &#39;filter_query&#39;)])
def updateGenomePageTable(page_current, page_size, sort_by, filter):
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = get_genomes.get_genomes(current_working_directory)
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    page = page_current
    size = page_size
    return dff.iloc[page * size: (page + 1) * size].to_dict(&#39;records&#39;)


############################ History Page ##########################

def get_results():
    &#39;&#39;&#39;
    Get a dataframe of the Results directory
    &#39;&#39;&#39;
    results_dirs = [join(current_working_directory + &#39;/Results/&#39;, f) for f in listdir(current_working_directory + &#39;/Results/&#39;) if isdir(join(current_working_directory + &#39;/Results/&#39;, f)) and isfile(current_working_directory + &#39;/Results/&#39; + f + &#39;/Params.txt&#39;)]
    results_dirs.sort(key = os.path.getctime)   #Sorted older first
    results_dirs = [os.path.basename(f) for f in results_dirs]
    col = [&#39;Job ID&#39;, &#39;Genome&#39;, &#39;PAM&#39;, &#39;Mismatches&#39;, &#39;DNA Bulges&#39;, &#39;RNA Bulges&#39;, &#39;Gecko Comparison&#39;, &#39;Reference Comparison&#39;, &#39;Date&#39;, &#39;Load&#39;]
    a = pd.DataFrame(columns = col)
    for job in results_dirs:
        if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/Params.txt&#39;):
            with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/Params.txt&#39;) as p:
                all_params = p.read()
                mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
                genome_selected = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
                genome_selected = genome_selected.replace(&#39;_&#39;,&#39; &#39;)
                if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/log.txt&#39;):
                    with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/log.txt&#39;) as lo:
                        all_log = lo.read()
                    job_start = (next(s for s in all_log.split(&#39;\n&#39;) if &#39;Job\tStart&#39; in s)).split(&#39;\t&#39;)[-1]
                    try:
                        job_end = (next(s for s in all_log.split(&#39;\n&#39;) if &#39;Job\tDone&#39; in s)).split(&#39;\t&#39;)[-1]
                    except:
                        link_load = URL + &#39;/load?job=&#39; + job
                    else:
                        link_load = URL + &#39;/result?job=&#39; + job
                else:
                    job_start = &#39;n/a&#39;
                    link_load = URL + &#39;/load?job=&#39; + job
                dna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;DNA&#39; in s)).split(&#39;\t&#39;)[-1]
                rna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;RNA&#39; in s)).split(&#39;\t&#39;)[-1]
                pam = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Pam&#39; in s)).split(&#39;\t&#39;)[-1]
                gecko = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Gecko&#39; in s)).split(&#39;\t&#39;)[-1]
                if gecko == &#39;True&#39;:
                    gecko = &#39;Yes&#39;
                else:
                    gecko = &#39;No&#39;
                comparison = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
                if comparison == &#39;True&#39;:
                    comparison = &#39;Yes&#39;
                else:
                    comparison = &#39;No&#39;
                if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/guides.txt&#39;):
                    with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/guides.txt&#39;) as g:
                        n_guides = str(len(g.read().strip().split(&#39;\n&#39;)))
                else:
                    n_guides =&#39;n/a&#39;
                
                a = a.append({&#39;Job ID&#39;:job, &#39;Genome&#39;:genome_selected, &#39;Mismatches&#39;:mms, &#39;DNA Bulges&#39;:dna,
                &#39;RNA Bulges&#39;:rna, &#39;PAM&#39;:pam,&#39;Gecko Comparison&#39;:gecko,&#39;Reference Comparison&#39;:comparison, &#39;Date&#39;:job_start, &#39;Load&#39;: link_load, &#39;Delete&#39;:&#39;&#39;}, ignore_index = True)
    a = a.sort_values([&#39;Mismatches&#39;,&#39;DNA Bulges&#39;,&#39;RNA Bulges&#39;],ascending = [True, True, True])
    return a

def generate_table_results(dataframe, page, max_rows = 10):
    &#39;&#39;&#39;
    Generate table for History page
    &#39;&#39;&#39;
    fl = []
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    header = html.Thead(
            html.Tr([html.Th(col,style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) if col != &#39;Load&#39; and col != &#39;Delete&#39; else html.Th(&#39;&#39;,style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})  for col in dataframe.columns])
        )
    body_history = []
    add_button = 0
    for i in range(min(rows_remaining, max_rows)):
        add_button += 1
        row_hist = []
        for col in dataframe.columns:
            if col == &#39;Load&#39;:
                row_hist.append(
                        html.Td(html.A(&#39;Load&#39;, target = &#39;_blank&#39;, href = dataframe.iloc[i + (page - 1)*max_rows][col]), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                )
            elif col == &#39;Delete&#39;:
                row_hist.append(
                    html.Td(html.Button(&#39;Delete&#39;, id = &#39;button-delete-history-&#39;+str(i), **{&#39;data-jobid&#39;:dataframe.iloc[i + (page - 1)*max_rows][&#39;Job ID&#39;]}),style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                )
            else:
                row_hist.append(
                        html.Td(dataframe.iloc[i + (page - 1)*max_rows][col], style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                    )
        body_history.append(html.Tr(row_hist))
    fl.append(
        html.Table([
            header,
            html.Tbody(body_history)
        ], style = {&#39;display&#39;:&#39;inline-block&#39;},)
    )
    
    for i in range(add_button, 10): #Add hidden buttons for callback removeJobId compatibility
        fl.append(html.Button(
            str(i), id = &#39;button-delete-history-&#39;+str(i),**{&#39;data-jobid&#39;:&#39;None&#39;}, style = {&#39;display&#39;:&#39;none&#39;}
            ))
    return fl


def historyPage():
    &#39;&#39;&#39;
    Create the History page
    &#39;&#39;&#39;
    results = get_results()
    final_list = []

    final_list.append(
        html.Div(
            [
                html.H3(&#39;Results History&#39;),
                html.P(&#39;List of available results. Click on the \&#39;Load\&#39; link to open the corresponding result in a new page.&#39;)
            ]
        )
    )
    final_list.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = availableGenomes(), id = &#39;dropdown-genomes-history&#39;, placeholder = &#39;Select a Genome&#39;))),
                                dbc.Col(html.Div(dcc.Dropdown(options = availablePAM(), id = &#39;dropdown-pam-history&#39;, placeholder = &#39;Select a PAM&#39;))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_mismatches, id = &#39;dropdown-mms-history&#39;, placeholder = &#39;Select a Mismatch value&#39; ))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_bulges, id = &#39;dropdown-dna-history&#39;, placeholder = &#39;Select a DNA Bulge value&#39; ))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_bulges, id = &#39;dropdown-rna-history&#39;, placeholder = &#39;Select a RNA Bulge value&#39; ))),


                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-history&#39;)))
                            ]
                        ),
                    ],
                )
        )
    final_list.append(html.Div(&#39;None,None&#39;,id = &#39;div-history-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;}))

    final_list.append(
            html.Div(
                generate_table_results(results,1),
                id = &#39;div-history-table&#39;,
                style = {&#39;text-align&#39;: &#39;center&#39;}
            ),
    )
    final_list.append(
        html.Div(id = &#39;div-remove-jobid&#39;, style = {&#39;display&#39;:&#39;none&#39;})
    )
    final_list.append(
        html.Div(
            [
                html.Br(),
                html.Button(&#39;Prev&#39;, id = &#39;prev-page-history&#39;),
                html.Button(&#39;Next&#39;, id = &#39;next-page-history&#39;)
            ],
            style = {&#39;text-align&#39;: &#39;center&#39;}
        )
    )
    max_page = len(results.index)
    max_page = math.floor(max_page / 10) + 1
    final_list.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-history&#39;))
    page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return page

#Callback to update the hidden div filter of history page
@app.callback(
    Output(&#39;div-history-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-history&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-genomes-history&#39;, &#39;value&#39;),
    State(&#39;dropdown-pam-history&#39;, &#39;value&#39;)]
)
def updateHistoryFilter(n, genome, pam):
    if n is None:
        raise PreventUpdate
    return str(genome) + &#39;,&#39; + str(pam)


def supportFilterHistory(result_df, genome_f, pam_f):
    if genome_f is not None:
        result_df.drop(result_df[(result_df[&#39;Genome&#39;] != genome_f)].index, inplace = True)
    if pam_f is not None:
        keep_values = []
        for index, row in result_df.iterrows():
            if row.PAM not in pam_f:
                keep_values.append(index)
        result_df.drop(labels= keep_values, inplace = True)

    max_page = len(result_df.index)
    max_page = math.floor(max_page / 10) + 1
    return result_df, max_page

#Remove Results and Apply Filtering
@app.callback(
    [Output(&#39;div-history-table&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-history&#39;, &#39;children&#39;)],
    [Input(&#39;button-delete-history-0&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-1&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-2&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-3&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-4&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-5&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-6&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-7&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-8&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-9&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;prev-page-history&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-history&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-history-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-delete-history-0&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-1&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-2&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-3&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-4&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-5&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-6&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-7&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-8&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-9&#39;, &#39;data-jobid&#39;),
    State(&#39;button-filter-history&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-current-page-history&#39;, &#39;children&#39;)
    ]
)
def removeJobIDandFilter(n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, nPrev, nNext, filter_q, jID0, jID1, jID2, jID3, jID4, jID5, jID6, jID7, jID8, jID9, n, search, current_page):
    #Get last pressed button
    if not n0:
        n0 = 0
    if not n1:
        n1 = 0
    if not n2:
        n2 = 0
    if not n3:
        n3 = 0
    if not n4:
        n4 = 0
    if not n5:
        n5 = 0
    if not n6:
        n6 = 0
    if not n7:
        n7 = 0
    if not n8:
        n8 = 0
    if not n9:
        n9 = 0
    if not nPrev:
        nPrev = 0
    if not nNext:
        nNext = 0
    if not n:
        n = 0
    btn_group = []
    btn_group.append(n0)
    btn_group.append(n1)
    btn_group.append(n2)
    btn_group.append(n3)
    btn_group.append(n4)
    btn_group.append(n5)
    btn_group.append(n6)
    btn_group.append(n7)
    btn_group.append(n8)
    btn_group.append(n9)
    btn_group.append(nPrev)
    btn_group.append(nNext)
    btn_group.append(n)
    
    genome_filter = filter_q.split(&#39;,&#39;)[0]
    pam_filter = filter_q.split(&#39;,&#39;)[1]
    if genome_filter == &#39;None&#39;:
        genome_filter = None
    if pam_filter == &#39;None&#39;:
        pam_filter = None
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    results = get_results()
    selectedID = &#39;&#39;

    if max(btn_group) == 0:
        selectedID = &#39;&#39;
    elif max(btn_group) == n0:
        selectedID = jID0
    elif max(btn_group) == n1:
        selectedID = jID1
    elif max(btn_group) == n2:
        selectedID = jID2
    elif max(btn_group) == n3:
        selectedID = jID3
    elif max(btn_group) == n4:
        selectedID = jID4
    elif max(btn_group) == n5:
        selectedID = jID5
    elif max(btn_group) == n6:
        selectedID = jID6
    elif max(btn_group) == n7:
        selectedID = jID7
    elif max(btn_group) == n8:
        selectedID = jID8
    elif max(btn_group) == n9:
        selectedID = jID9
    elif max(btn_group) == n:    #Filter Button selected, return the first page of the filtered table
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        return generate_table_results(results,1), &#39;1/&#39; + str(max_page)
    elif max(btn_group) == nNext:   #Next Button of the table
        current_page = current_page + 1
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        if ((current_page - 1) * 10) &gt; len(results): 
            current_page = current_page -1
            if current_page &lt; 1:
                current_page = 1
        return generate_table_results(results,current_page), str(current_page) + &#39;/&#39; + str(max_page)
    elif max(btn_group) == nPrev:   #Go to previous page
        current_page = current_page - 1
        if current_page &lt; 1:
            current_page = 1
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        return generate_table_results(results,current_page), str(current_page) + &#39;/&#39; + str(max_page)

    if selectedID == &#39;&#39;:
        raise PreventUpdate
    result_removed = Gmsg.deleteResultConfirm(selectedID)
    if result_removed:      #If the result was removed, update the table
        results, max_page = supportFilterHistory(get_results(), genome_filter, pam_filter)
        return generate_table_results(results,1), &#39;1/&#39; + str(max_page)
    else:
        raise PreventUpdate
    results, max_page = supportFilterHistory(get_results(), genome_filter, pam_filter)
    return generate_table_results(results,1), &#39;1/&#39; + str(max_page)


############################ GUI CALLBACKS #########################
#Add a new genome
@app.callback(
    Output(&#34;genome-job&#34;,&#34;value&#34;),        
    [Input(&#34;add-genome&#34;,&#34;n_clicks&#34;)],  
)
def add_genome(nAdd):
    &#34;&#34;&#34;
    Bottone per avviare la GUI in Tkinter per l&#39;aggiunta di genomi offline
    &#34;&#34;&#34;
    from GUI import ChooseFiles as cf
    if nAdd is None:
        raise PreventUpdate
    cf.startChooseFiles(current_working_directory,  app_location + &#39;GUI/&#39; )
    return &#39;&#39;

#Update an existing dictionary    
@app.callback(
    Output(&#34;dict-job&#34;,&#34;value&#34;),        
    [Input(&#34;update-dict&#34;,&#34;n_clicks&#34;)],  
)
def update_dict(nUpd):
    &#34;&#34;&#34;
    Bottone per avviare la GUI in Tkinter per l&#39;aggiornamento di dizionari
    &#34;&#34;&#34;
    from GUI import UpdateDict as ud
    if nUpd is None:
        raise PreventUpdate
    ud.startUpdateDict(current_working_directory)
    return &#39;&#39;


#Open filedialog for choosing new annotation file 
@app.callback(
    [Output(&#39;label-new-annotation-selected&#39;, &#39;children&#39;),
    Output(&#39;tooltip-label-new-annotation-selected&#39;, &#39;children&#39;)],
    [Input(&#39;button-choose-new-annotation&#39;, &#39;n_clicks&#39;)]
)
def fileDialogUpdateAnnotation(n):
    selected_file = openDialog(n, &#39;F&#39;)
    return &#39;Selected: &#39; + os.path.basename(selected_file), &#39;Full Path: &#39; + selected_file


#Change annotation of selected Genome row
@app.callback(
    Output(&#39;ann-job&#39;, &#39;children&#39;),
    [Input(&#39;change-ann&#39;,&#39;n_clicks&#39;)],
    [ State(&#39;genomes-table&#39;, &#39;derived_virtual_data&#39;),
     State(&#39;genomes-table&#39;, &#39;selected_rows&#39;),
     State(&#39;tooltip-label-new-annotation-selected&#39;, &#39;children&#39;),
     State(&#39;radioitems-new-annotation&#39;, &#39;value&#39;)]
    )
def change_annotation(nChg, rows, selected_row, selected_new_ann, selected_type):
    if nChg is None:
        raise PreventUpdate
    if len(selected_row) == 0:
        return dbc.Alert(&#34;Warning! Please select a Genome!&#34;, is_open=True, duration=5000, color = &#39;warning&#39; )
    selected_new_ann = selected_new_ann.split(&#39;Full Path: &#39;)[-1]
    if not isfile(selected_new_ann):
        return dbc.Alert(&#34;Error! The selected file does not exist!&#34;, is_open=True, duration=7000, color = &#39;danger&#39; )
    if selected_type is None:
        return dbc.Alert(&#34;Warning! Please select an option (Overwrite or Extend)!&#34;, is_open=True, duration=7000, color = &#39;warning&#39; )
    row = pd.DataFrame(rows).iloc[selected_row,:] 
    annotationFile = row[&#34;Annotation File&#34;].iloc[0]

    if selected_type == &#39;replace&#39;:
        subprocess.run([&#39;cp&#39;, selected_new_ann ,current_working_directory + &#39;annotations/&#39; + annotationFile])
    else:
        with open (current_working_directory + &#39;annotations/&#39; + annotationFile, &#39;a&#39;) as oldAnn:
            with open (selected_new_ann, &#39;r&#39;) as newAnn:
                for line in newAnn:
                    oldAnn.write(&#34;\n&#34;+line.strip())
                    
    
    # from GUI import annotations as ann
    # ann.startChangeAnn(current_working_directory+&#34;/annotations/&#34;+str(annotationFile))
    
    #Return an alert if the job is completed
    return dbc.Alert(
            &#34;Completed! The annotation file is updated!&#34;,
            id=&#34;alert-auto&#34;,
            is_open=True,
            duration=5000,
        )

if __name__ == &#39;__main__&#39;:
    #app.run_server(debug=True)
    app.run_server(host=&#39;0.0.0.0&#39;, debug=True, port=8050)
    #app.run_server(host=&#39;0.0.0.0&#39;,  port=8080) #NOTE to not reload the page when creating new images in graphical report
    cache.clear()       #delete cache when server is closed

    #BUG nel filtering se ho, in min mismatch etc, la stringa &#39;-&#39;, che non Ã¨ considerata numero
    #NOTE: l&#39;ordinamento su Samples Summary o su Samples Ã¨ fatto su stringhe, e non su numero di samples (potrebbe essere piÃ¹ utile)
    #BUG see https://github.com/plotly/dash/issues/1049; Location component is called twice, meaning that two grep can occure at once.</code></pre>
          </details>
        </section>
        <section></section>
        <section></section>
        <section>
          <h2 class="section-title" id="header-functions">Functions</h2>
          <dl>
            <dt id="crisprme_off.add_genome">
              <code class="name flex">
                <span>def <span class="ident">add_genome</span></span
                >(<span>nAdd)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Bottone per avviare la GUI in Tkinter per l'aggiunta di genomi
                  offline
                </p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#34;genome-job&#34;,&#34;value&#34;),        
    [Input(&#34;add-genome&#34;,&#34;n_clicks&#34;)],  
)
def add_genome(nAdd):
    &#34;&#34;&#34;
    Bottone per avviare la GUI in Tkinter per l&#39;aggiunta di genomi offline
    &#34;&#34;&#34;
    from GUI import ChooseFiles as cf
    if nAdd is None:
        raise PreventUpdate
    cf.startChooseFiles(current_working_directory,  app_location + &#39;GUI/&#39; )
    return &#39;&#39;</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.availableGenomes">
              <code class="name flex">
                <span>def <span class="ident">availableGenomes</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Returns a list of dictionaries of the available genomes in the
                  'Genomes' directory.
                </p>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>gen_dir</strong> (<em>list</em> of {'label': genome,
                    'value': genome}): list containing a series of dictionaries,
                    one for each directory (genome) found in the 'Genomes'
                    directory. Used as input parameter for the 'options' element
                    of a Dash Droplist
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def availableGenomes():
    &#39;&#39;&#39;
    Returns a list of dictionaries of the available genomes in the &#39;Genomes&#39; directory.

    ***Returns***

    + **gen_dir** (*list* of {&#39;label&#39;: genome, &#39;value&#39;: genome}): list containing a series of dictionaries, one for each directory (genome) found in
    the &#39;Genomes&#39; directory. Used as input parameter for the &#39;options&#39; element of a Dash Droplist 
    &#39;&#39;&#39;
    onlydir = [f for f in listdir(current_working_directory + &#39;Genomes&#39;) if isdir(join(current_working_directory + &#39;Genomes&#39;, f))]
    onlydir = [x.replace(&#39;_&#39;, &#39; &#39;) for x in onlydir]
    gen_dir = []
    for dir in onlydir:
        gen_dir.append({&#39;label&#39;: dir, &#39;value&#39; : dir})
    return gen_dir</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.availablePAM">
              <code class="name flex">
                <span>def <span class="ident">availablePAM</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Returns a list of dictionaries of the available PAMs in the
                  'PAM' directory.
                </p>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>pam_file</strong> (<em>list</em> of {'label': pam,
                    'value': pam}): list containing a series of dictionaries,
                    one for each PAM file found in the 'PAM' directory. Used as
                    input parameter for the 'options' element of a Dash Droplist
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def availablePAM():
    &#39;&#39;&#39;
    Returns a list of dictionaries of the available PAMs in the &#39;PAM&#39; directory.

    ***Returns***
    
    + **pam_file** (*list* of {&#39;label&#39;: pam, &#39;value&#39;: pam}): list containing a series of dictionaries, one for each PAM file found in
        the &#39;PAM&#39; directory. Used as input parameter for the &#39;options&#39; element of a Dash Droplist
    &#39;&#39;&#39;
    onlyfile = [f for f in listdir(current_working_directory + &#39;pam&#39;) if isfile(join(current_working_directory + &#39;pam&#39;, f))]
    onlyfile = [x.replace(&#39;.txt&#39;, &#39;&#39;) for x in onlyfile]            #removed .txt for better visualization
    pam_file = []
    for pam_name in onlyfile:
        if &#39;tempPAM&#39; in pam_name:   #Skip the temp pam used for updating dictionaries
            pass
        else:
            pam_file.append({&#39;label&#39;:pam_name, &#39;value&#39;:pam_name})
    return pam_file</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.changePage">
              <code class="name flex">
                <span>def <span class="ident">changePage</span></span
                >(<span>href, path, search, hash_guide)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>Change the page layout based on the URL.</p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>href</strong>]
                    <strong>url</strong> (<em>href</em>): string containing the
                    whole address, eg
                    'http://127.0.0.1:8080/result?job=QV99PN6XDL#CCATCGGTGGCCGTTTGCCCNNNnewX00'
                  </li>
                  <li>
                    [<strong>path</strong>]
                    <strong>url</strong> (<em>pathname</em>): string containing
                    the page, eg '/result'
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                  <li>
                    [<strong>hash_guide</strong>]
                    <strong>url</strong> (<em>hash</em>): string containing the
                    view result query, eg '#CCATCGGTGGCCGTTTGCCCNNNnewX00'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>page-content</strong> (<em>children</em>): the
                    layout of the page, based on the URL.
                    <ul>
                      <li>'/': returns the index page (main page)</li>
                      <li>
                        '/load': returns the load page. Called after submitting
                        a job
                      </li>
                      <li>
                        '/result': returns the result page. Based on the job ID
                        in the <strong>search</strong> parameter, the user can
                        also access to:
                        <ul>
                          <li>
                            '#GUIDEnew': returns the table visualizing the
                            targets based on Bulge and Mismatch values
                          </li>
                          <li>
                            '-Sample-': returns the table visualizing the
                            targets for each sample
                          </li>
                          <li>
                            '-Pos-': returns the table visualizing the targets
                            based on the selected chromosome position
                          </li>
                        </ul>
                      </li>
                      <li>'/user-guide': returns the help page</li>
                      <li>'/contacts': returns the contacts page</li>
                      <li>
                        '/history': returns the history page. Available only
                        offline
                      </li>
                      <li>
                        '/genomes': returns the genomes page. Available only
                        offline
                      </li>
                    </ul>
                  </li>
                  <li>
                    <strong>job-link</strong> (<em>children</em>): the link
                    displayed to the user in the '/load' page, used to access
                    the status of the job. By saving this URL the the user can
                    monitor the status of the job and see the corresponding
                    '/result' page
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;page-content&#39;, &#39;children&#39;),
    Output(&#39;job-link&#39;, &#39;children&#39;)],
    [Input(&#39;url&#39;, &#39;href&#39;), Input(&#39;url&#39;,&#39;pathname&#39;), Input(&#39;url&#39;,&#39;search&#39;)],[State(&#39;url&#39;,&#39;hash&#39;)]
)
def changePage( href, path, search, hash_guide):
    &#39;&#39;&#39;
    Change the page layout based on the URL.

    ***Args***

    + [**href**] **url** (*href*): string containing the whole address, eg &#39;http://127.0.0.1:8080/result?job=QV99PN6XDL#CCATCGGTGGCCGTTTGCCCNNNnewX00&#39;
    + [**path**] **url** (*pathname*): string containing the page, eg &#39;/result&#39;
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**hash_guide**] **url** (*hash*): string containing the view result query, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewX00&#39;

    ***Returns***

    + **page-content** (*children*): the layout of the page, based on the URL. 
        + &#39;/&#39;: returns the index page (main page)
        + &#39;/load&#39;: returns the load page. Called after submitting a job
        + &#39;/result&#39;: returns the result page. Based on the job ID in the **search** parameter, the user can also access to:
            + &#39;#GUIDEnew&#39;: returns the table visualizing the targets based on Bulge and Mismatch values
            + &#39;-Sample-&#39;: returns the table visualizing the targets for each sample
            + &#39;-Pos-&#39;: returns the table visualizing the targets based on the selected chromosome position
        + &#39;/user-guide&#39;: returns the help page
        + &#39;/contacts&#39;: returns the contacts page
        + &#39;/history&#39;: returns the history page. Available only offline
        + &#39;/genomes&#39;: returns the genomes page. Available only offline
    + **job-link** (*children*): the link displayed to the user in the &#39;/load&#39; page, used to access the status of the job. By saving this URL the
    the user can monitor the status of the job and see the corresponding &#39;/result&#39; page
    &#39;&#39;&#39;

    if path == &#39;/load&#39;:
        return load_page, URL + &#39;/load&#39; + search 
    if path == &#39;/result&#39;:
        job_id = search.split(&#39;=&#39;)[-1]
        if hash_guide is None or hash_guide == &#39;&#39;:
            return resultPage(job_id), URL + &#39;/load&#39; + search
        if &#39;new&#39; in hash_guide:         #TODO cambiare nome alla pagina delle guide
            return guidePagev3(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        if &#39;-Sample-&#39; in hash_guide:   
            return samplePage(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        if &#39;-Pos-&#39; in hash_guide:
            return clusterPage(job_id, hash_guide.split(&#39;#&#39;)[1]), URL + &#39;/load&#39; + search
        return resultPage(job_id), URL + &#39;/load&#39; + search
    if path == &#39;/test-page&#39;:
        return test_page(), URL + &#39;/load&#39; + search
    if path == &#39;/test-page2&#39;:
        return test_page2, URL + &#39;/load&#39; + search
    if path == &#39;/test-page3&#39;:
        return test_page3, URL + &#39;/load&#39; + search
    if path == &#39;/user-guide&#39;:
        return about_page, URL + &#39;/load&#39; + search
    if path == &#39;/contacts&#39;:
        return contacts_page, URL + &#39;/load&#39; + search
    if path == &#39;/history&#39;:
        if ONLINE:
            return indexPage(), &#39;&#39;
        return historyPage(), URL + &#39;/load&#39; + search
    if path == &#39;/genomes&#39;:
        if ONLINE:
            return indexPage(), &#39;&#39;
        genomes_page = html.Div(gen_page.genomesPage(current_working_directory), style = {&#39;margin&#39;:&#39;1%&#39;})
        return genomes_page, URL + &#39;/load&#39; + search
    return indexPage(), &#39;&#39;</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.changeUrl">
              <code class="name flex">
                <span>def <span class="ident">changeUrl</span></span
                >(<span
                  >n, href, genome_selected, pam, text_guides, mms, dna, rna,
                  gecko_opt, genome_ref_opt, adv_opts, dest_email, active_tab,
                  text_sequence, len_guide_sequence)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Main function that generates the inputs for the
                  Post/Process/submit_job.final.sh script and launches the
                  search analysis.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>submit-job</strong> (<em>n_clicks</em>): this value
                    comes from the output of the
                    <code
                      ><a
                        title="crisprme_off.checkInput"
                        href="#crisprme_off.checkInput"
                        >checkInput()</a
                      ></code
                    >
                    function. If <code>1</code>, it means that the inputs are
                    correct, and the function can proceed. If
                    <code>None</code> it means that some inputs are missing, so
                    a <code>raise PreventUpdate</code> is returned.
                  </li>
                  <li>
                    [<strong>href</strong>]
                    <strong>url</strong> (<em>href</em>): string for the href
                    part of the url. NOTE not used
                  </li>
                  <li>
                    [<strong>genome_selected</strong>]
                    <strong>available-genome</strong> (<em>value</em>): string
                    for the selected genome
                  </li>
                  <li>
                    [<strong>pam</strong>]
                    <strong>available-pam</strong> (<em>value</em>): string for
                    the selected PAM
                  </li>
                  <li>
                    [<strong>text_guides</strong>]
                    <strong>text-guides</strong> (<em>value</em>): string for
                    the input guides
                  </li>
                  <li>
                    [<strong>mms</strong>]
                    <strong>mms</strong> (<em>value</em>): int for the mismatch
                    selected
                  </li>
                  <li>
                    [<strong>dna</strong>]
                    <strong>dna</strong> (<em>value</em>): int for the DNA bulge
                    selected
                  </li>
                  <li>
                    [<strong>rna</strong>]
                    <strong>rna</strong> (<em>value</em>): int for the RNA
                    bbulge selected
                  </li>
                  <li>
                    [<strong>gecko_opt</strong>]
                    <strong>checkbox-gecko</strong> (<em>checked</em>): bool for
                    the GeCKO Checkbox
                  </li>
                  <li>
                    [<strong>genoma_ref_opt</strong>]
                    <strong>checkbox-ref-comp</strong> (<em>checked</em>): bool
                    for the reference genome comparison
                  </li>
                  <li>
                    [<strong>adv_opts</strong>]
                    <strong>checklist-advanced</strong> (<em>value</em>): list
                    of advanced options selected (NOTE only email)
                  </li>
                  <li>
                    [<strong>dest_email</strong>]
                    <strong>example-email</strong> (<em>value</em>): string of
                    the input email
                  </li>
                  <li>
                    [<strong>active_tab</strong>]
                    <strong>tabs</strong> (<em>active_tab</em>): string of the
                    ID of the active tab ('Guide' or 'Sequence')
                  </li>
                  <li>
                    [<strong>text_sequence</strong>]
                    <strong>text-sequence</strong> (<em>value</em>): string of
                    the input sequence
                  </li>
                  <li>
                    [<strong>len_guide_sequence</strong>]
                    <strong>len-guide-sequence-ver</strong> (<em>value</em>):
                    int of the selected guide len (available only if 'Sequence'
                    tab is active)
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>url</strong> (<em>pathname</em>): string '/load' to
                    go to the Load Page
                  </li>
                  <li>
                    <strong>url</strong> (<em>search</em>): string '?job=' + the
                    job ID, to check the status of the specific job
                  </li>
                </ul>
                <p>
                  <strong><em>Details</em></strong>
                </p>
                <ul>
                  <li>
                    1) (NOTE already done in
                    <code
                      ><a
                        title="crisprme_off.checkInput"
                        href="#crisprme_off.checkInput"
                        >checkInput()</a
                      ></code
                    >) The function checks the validity of the input parameters.
                  </li>
                  <li>
                    2) In order to differentiante various analysis submissions,
                    an ID is given to each analysis (Job ID), consisting of a
                    string of 10 alphanumeric characters (A-Z 0-9). If a
                    generated ID is already assigned, retry and compute another
                    one. Every 7 iterations, add +1 to the length of the ID, up
                    to a maximum of 20 chars. Then the JobID directory is
                    created and inside is created a <code>queue.txt</code> file
                    in order to implement a job queue
                  </li>
                  <li>
                    3) The parameters used as input for the submit_job.final.sh
                    script are created based on user input:
                    <ul>
                      <li>
                        Email: the email address, link for the results and start
                        date are written in <code>Genomes/JobID/email.txt</code>
                      </li>
                      <li>
                        PAM: get PAM len and direction (beginning or end), in
                        order to write the correct files for pam and guides used
                        in Crispritz.
                      </li>
                      <li>
                        Guides: if the 'Sequence' tab is selected, the input is
                        processed in the <code>extract_seq</code> module, that
                        returns a list of guides. Non valid characters are then
                        eliminated, along with the exceeding guides (only 1000
                        guides are acceptable). The guides are then modified by
                        adding N characters, following PAM type input (check
                        Crispritz), and saved into file
                        <code>Genomes/JobID/guides.txt</code>. The PAM is also
                        saved in the <code>Genomes/JobID/pam.txt</code> file,
                        following the Crispritz standard
                      </li>
                      <li>
                        Indexing: if the selected Genome-PAM has no index in
                        <code>genome_library</code>, set a flag to calculate the
                        index when submitting the job. The PAM used for indexing
                        is <code>Genomes/JobID/pam_indexing.txt</code>
                      </li>
                      <li>
                        Params file: the informations about the job are saved
                        into the <code>Params.txt</code> file
                      </li>
                      <li>
                        Annotation: based on the selected genome reference part,
                        the annotation is chosen from the
                        <code>annotations</code> directory
                      </li>
                      <li>
                        Sample: based on the enriched genome selected, the
                        sampleID file is chosen from the
                        <code>samplesID</code> directory
                      </li>
                      <li>
                        Dictionary: based on the enriched genome selected, the
                        Dictionary for sample extraction is selected from the
                        <code>dictionaries</code> directory
                      </li>
                    </ul>
                  </li>
                  <li>
                    4) If the input is equal to an already calculated analysis,
                    then the function modify the job id to the one of the
                    already existing analysis (even if it's completed/currently
                    submitted/in queue), update the <code>email</code> file and
                    the <code>log</code> file (in order to reset the 3 days
                    availability on the server)
                  </li>
                  <li>
                    Launch the submit_job.final.sh script using
                    <code>exeggutor</code>, to a max of 2 concurrent jobs, the
                    others are put into a queue
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;url&#39;, &#39;pathname&#39;),
    Output(&#39;url&#39;,&#39;search&#39;)],
    [Input(&#39;submit-job&#39;,&#39;n_clicks&#39;)],
    [State(&#39;url&#39;, &#39;href&#39;),
    State(&#39;available-genome&#39;, &#39;value&#39;),
    State(&#39;available-pam&#39;,&#39;value&#39;),
    State(&#39;text-guides&#39;, &#39;value&#39;),
    State(&#39;mms&#39;,&#39;value&#39;),
    State(&#39;dna&#39;,&#39;value&#39;),
    State(&#39;rna&#39;,&#39;value&#39;),
    State(&#39;checkbox-gecko&#39;,&#39;checked&#39;),
    State(&#39;checkbox-ref-comp&#39;, &#39;checked&#39;),
    State(&#39;checklist-advanced&#39;, &#39;value&#39;),
    State(&#39;example-email&#39;,&#39;value&#39;),
    State(&#39;tabs&#39;,&#39;active_tab&#39;),
    State(&#39;text-sequence&#39;,&#39;value&#39;),
    State(&#39;len-guide-sequence-ver&#39;, &#39;value&#39;)]
)
def changeUrl(n, href, genome_selected, pam, text_guides, mms, dna, rna, gecko_opt, genome_ref_opt, adv_opts,dest_email, active_tab, text_sequence, len_guide_sequence):      #NOTE startJob
    &#39;&#39;&#39;
    Main function that generates the inputs for the Post/Process/submit_job.final.sh script and launches the search analysis.

    ***Args***
    
    + [**n**] **submit-job** (*n_clicks*): this value comes from the output of the `checkInput()` function. If `1`, it means that the inputs are
    correct, and the function can proceed. If `None` it means that some inputs are missing, so a `raise PreventUpdate` is returned.
    + [**href**] **url** (*href*): string for the href part of the url. NOTE not used
    + [**genome_selected**] **available-genome** (*value*): string for the selected genome
    + [**pam**] **available-pam** (*value*): string for the selected PAM
    + [**text_guides**] **text-guides** (*value*): string for the input guides
    + [**mms**] **mms** (*value*): int for the mismatch selected
    + [**dna**] **dna** (*value*): int for the DNA bulge selected
    + [**rna**] **rna** (*value*): int for the RNA bbulge selected
    + [**gecko_opt**] **checkbox-gecko** (*checked*): bool for the GeCKO Checkbox 
    + [**genoma_ref_opt**] **checkbox-ref-comp** (*checked*): bool for the reference genome comparison
    + [**adv_opts**] **checklist-advanced** (*value*): list of advanced options selected (NOTE only email)
    + [**dest_email**] **example-email** (*value*): string of the input email
    + [**active_tab**] **tabs** (*active_tab*): string of the ID of the active tab (&#39;Guide&#39; or &#39;Sequence&#39;)
    + [**text_sequence**] **text-sequence** (*value*): string of the input sequence
    + [**len_guide_sequence**] **len-guide-sequence-ver** (*value*): int of the selected guide len (available only if &#39;Sequence&#39; tab is active)

    ***Returns***

    + **url** (*pathname*): string &#39;/load&#39; to go to the Load Page
    + **url** (*search*): string &#39;?job=&#39; + the job ID, to check the status of the specific job 

    ***Details***
    
    + 1) (NOTE already done in `checkInput()`) The function checks the validity of the input parameters.
    + 2) In order to differentiante various analysis submissions, an ID is given to each analysis (Job ID), consisting of a string of 10 alphanumeric
    characters (A-Z 0-9). If a generated ID is already assigned, retry and compute another one. Every 7 iterations, add +1 to the length of the
    ID, up to a maximum of 20 chars. Then the JobID directory is created and inside is created a `queue.txt` file in order to implement a job queue
    + 3) The parameters used as input for the submit_job.final.sh script are created based on user input:
        + Email: the email address, link for the results and start date are written in `Genomes/JobID/email.txt`
        + PAM: get PAM len and direction (beginning or end), in order to write the correct files for pam and guides used in Crispritz.
        + Guides: if the &#39;Sequence&#39; tab is selected, the input is processed in the `extract_seq` module, that returns a list of guides. Non valid 
        characters are then eliminated, along with the exceeding guides (only 1000 guides are acceptable). The guides are then modified by adding
        N characters, following PAM type input (check Crispritz), and saved into file `Genomes/JobID/guides.txt`. The PAM is also saved in the 
        `Genomes/JobID/pam.txt` file, following the Crispritz standard
        + Indexing: if the selected Genome-PAM has no index in `genome_library`, set a flag to calculate the index when submitting the job. The PAM
        used for indexing is `Genomes/JobID/pam_indexing.txt`
        + Params file: the informations about the job are saved into the `Params.txt` file
        + Annotation: based on the selected genome reference part, the annotation is chosen from the `annotations` directory
        + Sample: based on the enriched genome selected, the sampleID file is chosen from the `samplesID` directory 
        + Dictionary: based on the enriched genome selected, the Dictionary for sample extraction is selected from the `dictionaries` directory
    + 4) If the input is equal to an already calculated analysis, then the function modify the job id to the one of the already existing analysis
    (even if it&#39;s completed/currently submitted/in queue), update the `email` file and the `log` file (in order to reset the 3 days availability on the server)
    + Launch the submit_job.final.sh script using `exeggutor`, to a max of 2 concurrent jobs, the others are put into a queue
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    
    # 1) Check input, else give simple input
    if genome_selected is None or genome_selected == &#39;&#39;:
        genome_selected = &#39;hg38_ref&#39;
    if pam is None or pam == &#39;&#39;:
        pam = &#39;20bp-NGG-SpCas9&#39;
    if text_guides is None or text_guides == &#39;&#39;:
        text_guides = &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;
    else:
        text_guides = text_guides.strip()
        if ( not all(len(elem) == len(text_guides.split(&#39;\n&#39;)[0]) for elem in text_guides.split(&#39;\n&#39;))):
            text_guides = selectSameLenGuides(text_guides)
    if (len_guide_sequence is None or str(len_guide_sequence) == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        len_guide_sequence = 20
    if (text_sequence is None or text_sequence == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        text_sequence = &#39;&gt;sequence\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39;
    
    # 2) Get random string for job id
    n_it = 10
    len_id = 10
    for i in range(n_it):
        assigned_ids = [o for o in os.listdir(current_working_directory + &#39;Results/&#39;) if os.path.isdir(os.path.join(current_working_directory + &#39;Results/&#39;,o))]
        job_id = &#39;&#39;.join(random.choices(string.ascii_uppercase + string.digits, k = len_id))
        if job_id not in assigned_ids:
            break
        if i &gt; 7:
            i = 0
            len_id += 1 
            if len_id &gt; 20:
                break
    result_dir = current_working_directory + &#39;Results/&#39; + job_id
    subprocess.run([&#39;mkdir &#39; + result_dir], shell = True)
    #NOTE test command per queue
    subprocess.run([&#39;touch &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/queue.txt&#39;], shell = True)

    # 3) Set parameters
    generate_index_ref = False
    generate_index_enr = False
    search_index = True
    search = True
    annotation = True
    report =  True
    gecko_comp = False
    ref_comparison = False
    send_email = False
    if adv_opts is None:
        adv_opts = []
    if gecko_opt:
        gecko_comp = True
    if genome_ref_opt:
        ref_comparison = True
    if &#39;email&#39; in adv_opts and dest_email is not None and len(dest_email.split(&#39;@&#39;)) &gt; 1 and dest_email.split(&#39;@&#39;)[-1] != &#39;&#39;:
        send_email = True
        with open(result_dir + &#39;/email.txt&#39;, &#39;w&#39;) as e:
            e.write(dest_email + &#39;\n&#39;)
            e.write(URL + &#39;/load?job=&#39; + job_id + &#39;\n&#39;)
            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
            #e.write(&#39;Job done. Parameters: etc etc&#39;)
            e.close()
    
    
    genome_selected = genome_selected.replace(&#39; &#39;, &#39;_&#39;)
    genome_ref = genome_selected.split(&#39;+&#39;)[0]              # + char to separate ref and enr, eg Human_Genome_ref+Human_Genome_1000_genome_project
    if genome_ref == genome_selected:
        ref_comparison = False
    #NOTE Indexed genomes names are PAM + _ + bMax + _ + genome_selected
    
    pam_len = 0
    with open(current_working_directory + &#39;pam/&#39; + pam + &#39;.txt&#39;) as pam_file:
        pam_char = pam_file.readline()
        index_pam_value = pam_char.split(&#39; &#39;)[-1]
        if int(pam_char.split(&#39; &#39;)[-1]) &lt; 0:
            end_idx = int(pam_char.split(&#39; &#39;)[-1]) * (-1)
            pam_char = pam_char.split(&#39; &#39;)[0][0 : end_idx]
            pam_len = end_idx
            pam_begin = True
        else:
            end_idx = int(pam_char.split(&#39; &#39;)[-1])
            pam_char = pam_char.split(&#39; &#39;)[0][end_idx * (-1):]
            pam_len = end_idx
            pam_begin = False
    
    if &#39;sequence-tab&#39; in active_tab:
        #Extract sequence and create the guides
        guides = []
        for name_and_seq in text_sequence.split(&#39;&gt;&#39;):
            if &#39;&#39; == name_and_seq:
                continue
            name = name_and_seq[:name_and_seq.find(&#39;\n&#39;)]
            seq = name_and_seq[name_and_seq.find(&#39;\n&#39;):]
            seq = seq.strip().split()
            seq = &#39;&#39;.join(seq)
            # name, seq = name_and_seq.strip().split(&#39;\n&#39;)    
            if &#39;chr&#39; in seq:
                extracted_seq = extract_seq.extractSequence(name, seq, genome_ref.replace(&#39; &#39;, &#39;_&#39;))
            else:
                extracted_seq = seq.strip()
            
            guides.extend(convert_pam.getGuides(extracted_seq, pam_char, len_guide_sequence, pam_begin))
            text_guides = &#39;\n&#39;.join(guides).strip()
    
    text_guides = text_guides.upper()
    for g in text_guides.split(&#39;\n&#39;):
        for c in g:
            if c not in VALID_CHARS:
                text_guides = text_guides.replace(c,&#39;&#39;)
    if len(text_guides.split(&#39;\n&#39;)) &gt; 1000:
        text_guides = &#39;\n&#39;.join(text_guides.split(&#39;\n&#39;)[:1000]).strip()
    len_guides = len(text_guides.split(&#39;\n&#39;)[0])
    #Adjust guides by adding Ns to make compatible with Crispritz
    if (pam_begin):
        pam_to_file = pam_char + (&#39;N&#39; * len_guides) + &#39; &#39; + index_pam_value
        pam_to_indexing = pam_char + (&#39;N&#39; * 25) + &#39; &#39; + index_pam_value
    else:
        pam_to_file = (&#39;N&#39; * len_guides) + pam_char + &#39; &#39; + index_pam_value
        pam_to_indexing = (&#39;N&#39; * 25) + pam_char + &#39; &#39; + index_pam_value

    save_pam_file = open(result_dir + &#39;/pam.txt&#39;, &#39;w&#39;)
    save_pam_file.write(pam_to_file)
    save_pam_file.close()
    pam = result_dir + &#39;/pam.txt&#39;
        
    guides_file = result_dir + &#39;/guides.txt&#39;
    if text_guides is not None and text_guides != &#39;&#39;:
        save_guides_file = open(result_dir + &#39;/guides.txt&#39;, &#39;w&#39;)
        if (pam_begin):
            text_guides = &#39;N&#39; * pam_len + text_guides.replace(&#39;\n&#39;, &#39;\n&#39; + &#39;N&#39; * pam_len)
        else:
            text_guides = text_guides.replace(&#39;\n&#39;, &#39;N&#39; * pam_len + &#39;\n&#39;) + &#39;N&#39; * pam_len
        save_guides_file.write(text_guides)
        save_guides_file.close()     

    if (int(dna) == 0 and int(rna) == 0):
        search_index = False
    max_bulges = rna
    if (int(dna) &gt; int(rna)):
        max_bulges = dna

    if (search_index):
        search = False

    #Check if index exists, otherwise set generate_index to true
    genome_indices_created =  [f for f in listdir(current_working_directory + &#39;genome_library&#39;) if isdir(join(current_working_directory + &#39;genome_library&#39;, f))]
    genome_idx = &#39;&#39;
    genome_idx_ref = &#39;&#39;
    for gidx in genome_indices_created:
        if pam_char in gidx and genome_selected in gidx:
            if int(gidx.split(&#39;_&#39;)[1]) &gt;= int(max_bulges):
                if &#39;+&#39; in gidx:
                    genome_idx = gidx
                genome_idx_ref = gidx.split(&#39;+&#39;)[0]
                
    if genome_idx == &#39;&#39;:
        if int(max_bulges) &gt; 0:
            generate_index_enr = True
            with open(result_dir + &#39;/pam_indexing.txt&#39;, &#39;w+&#39;) as pam_id_file:
                pam_id_file.write(pam_to_indexing)
        genome_idx = pam_char + &#39;_&#39; + str(max_bulges) + &#39;_&#39; + genome_selected
    if genome_idx_ref == &#39;&#39;:
        if int(max_bulges) &gt; 0:
            generate_index_ref = True
            with open(result_dir + &#39;/pam_indexing.txt&#39;, &#39;w+&#39;) as pam_id_file:
                pam_id_file.write(pam_to_indexing)
        genome_idx_ref = pam_char + &#39;_&#39; + str(max_bulges) + &#39;_&#39; + genome_selected.split(&#39;+&#39;)[0]

    if genome_ref == genome_selected:
        generate_index_enr = False
    # genome_idx = pam_char + &#39;_&#39; + &#39;2&#39; + &#39;_&#39; + genome_selected   
    # genome_idx_ref = genome_idx.split(&#39;+&#39;)[0]
    
    #Create Params.txt file
    with open(result_dir + &#39;/Params.txt&#39;, &#39;w&#39;) as p:           
        p.write(&#39;Genome_selected\t&#39; + genome_selected + &#39;\n&#39;)         
        p.write(&#39;Genome_ref\t&#39; + genome_ref + &#39;\n&#39;)
        if search_index:
            p.write(&#39;Genome_idx\t&#39; + genome_idx + &#39;\n&#39;)
        else:
            p.write(&#39;Genome_idx\t&#39; + &#39;None\n&#39;)
        p.write(&#39;Pam\t&#39; + pam_char + &#39;\n&#39;)
        p.write(&#39;Max_bulges\t&#39; + str(max_bulges) + &#39;\n&#39;)
        p.write(&#39;Mismatches\t&#39; + str(mms) + &#39;\n&#39;)
        p.write(&#39;DNA\t&#39; + str(dna) + &#39;\n&#39;)
        p.write(&#39;RNA\t&#39; + str(rna) + &#39;\n&#39;)
        p.write(&#39;Gecko\t&#39; + str(gecko_comp) + &#39;\n&#39;)
        p.write(&#39;Ref_comp\t&#39; + str(ref_comparison) + &#39;\n&#39;)
        p.close()

    # 4) Check if input parameters (mms, bulges, pam, guides, genome) are the same as a previous search
    all_result_dirs = [f for f in listdir(current_working_directory + &#39;Results&#39;) if isdir(join(current_working_directory + &#39;Results&#39;, f))]
    all_result_dirs.remove(job_id)
    #all_result_dirs.remove(&#39;test&#39;)
    for check_param_dir in all_result_dirs:
        if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/Params.txt&#39;):
            #if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;):
                #with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;) as log:
                    #if (&#39;Job\tDone&#39; in log.read()):
            if (filecmp.cmp(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/Params.txt&#39;, result_dir + &#39;/Params.txt&#39; )):
                    guides1 = open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/guides.txt&#39;).read().split(&#39;\n&#39;)
                    guides2 = open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides.txt&#39;).read().split(&#39;\n&#39;)
                    if (collections.Counter(guides1) == collections.Counter(guides2)):
                        if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;):
                            adj_date = False
                            with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39;) as log:
                                log_content = log.read().strip()
                                if (&#39;Job\tDone&#39; in log_content):
                                    adj_date = True
                                    log_content = log_content.split(&#39;\n&#39;)
                                    new_date = subprocess.Popen([&#39;echo $(date)&#39;], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell = True)
                                    out, err = new_date.communicate()
                                    rewrite = &#39;\n&#39;.join(log_content[:-1]) + &#39;\nJob\tDone\t&#39; + out.decode(&#39;UTF-8&#39;).strip()
                            if adj_date:
                                with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/log.txt&#39; ,&#39;w+&#39;) as log:
                                    log.write(rewrite)
                                    #Send mail
                                if send_email:
                                    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    #Send mail with file in job_id dir with link to job already done, note that job_id directory will be deleted
                                    subprocess.call([&#39;python &#39; + app_main_directory + &#39;send_mail.py &#39; + current_working_directory + &#39;Results/&#39; + job_id ], shell = True)

                            elif send_email:
                                #Job is not finished, add this user email to email.txt and when job is done send to both
                                if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39;):
                                    with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;a+&#39;) as e:
                                        e.write(&#39;--OTHEREMAIL--&#39;)
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                else:
                                    with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                        e.write(dest_email + &#39;\n&#39;)
                                        e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                        e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    

                            subprocess.call([&#39;rm -r &#39; + current_working_directory + &#39;Results/&#39; + job_id], shell = True)
                            return &#39;/load&#39;,&#39;?job=&#39; + check_param_dir
                        else:
                            #We may have entered a jobdir that was in queue
                            if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/queue.txt&#39;):
                                if send_email:
                                    if os.path.exists(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39;):
                                        with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;a+&#39;) as e:
                                            e.write(&#39;--OTHEREMAIL--&#39;)
                                            e.write(dest_email + &#39;\n&#39;)
                                            e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                    else:
                                        with open(current_working_directory + &#39;Results/&#39; + check_param_dir + &#39;/email.txt&#39; ,&#39;w+&#39;) as e:
                                            e.write(dest_email + &#39;\n&#39;)
                                            e.write(URL + &#39;/load?job=&#39; + check_param_dir + &#39;\n&#39;)
                                            e.write(datetime.utcnow().strftime(&#34;%m/%d/%Y, %H:%M:%S&#34;) + &#39;\n&#39;)
                                return &#39;/load&#39;,&#39;?job=&#39; + check_param_dir

    #Annotation
    if (not search and not search_index):
        annotation = False      

    #Generate report
    if (not search and not search_index):
        report = False         
    
    genome_type = &#39;ref&#39;     #Indicates if search is &#39;ref&#39;, &#39;var&#39; or &#39;both&#39;
    if &#39;+&#39; in genome_selected:
        genome_type = &#39;var&#39;
    if ref_comparison:
        genome_type = &#39;both&#39;    

    #Get annotation file, already with the absolute path. TODO currently only one annotation per genome
    #Also get dictionary and sample dictionary files
    annotation_file = [f for f in listdir(current_working_directory + &#39;annotations/&#39;) if isfile(join(current_working_directory + &#39;annotations/&#39;, f)) and f.startswith(genome_ref)][0]
    
    if genome_type == &#39;ref&#39;:
        sample_list = None
        dictionary_directory = None
    else:
        sample_list = current_working_directory + &#39;samplesID/samples_&#39; + genome_selected + &#39;.txt&#39;
        dictionary_directory = current_working_directory + &#39;dictionaries/dictionary_&#39; + genome_selected

    command = app_main_directory + &#39;PostProcess/./submit_job.final.sh &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39; &#39; + current_working_directory +  &#39;Genomes/&#39; + genome_selected + &#39; &#39; + current_working_directory + &#39;Genomes/&#39; + genome_ref + &#39; &#39; + current_working_directory + &#39;genome_library/&#39; + genome_idx + (
        &#39; &#39; + pam + &#39; &#39; + guides_file + &#39; &#39; + str(mms) + &#39; &#39; + str(dna) + &#39; &#39; + str(rna) + &#39; &#39; + str(search_index) + &#39; &#39; + str(search) + &#39; &#39; + str(annotation) + (
            &#39; &#39; + str(report) + &#39; &#39; + str(gecko_comp) + &#39; &#39; + str(ref_comparison) + &#39; &#39; + current_working_directory +  &#39;genome_library/&#39; + genome_idx_ref + &#39; &#39; + str(send_email) + &#39; &#39;  + current_working_directory +  &#39;annotations/&#39; + annotation_file + 
            &#39; &#39; + genome_type + &#39; &#39; + app_main_directory + &#39; &#39; + str(dictionary_directory) + &#39; &#39; + str(sample_list) + &#39; &#39; + str(generate_index_ref) + &#39; &#39; + str(generate_index_enr) + &#39; &#39; + current_working_directory))

    exeggutor.submit(subprocess.run, command, shell=True)
    return &#39;/load&#39;,&#39;?job=&#39; + job_id</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.change_annotation">
              <code class="name flex">
                <span>def <span class="ident">change_annotation</span></span
                >(<span
                  >nChg, rows, selected_row, selected_new_ann,
                  selected_type)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;ann-job&#39;, &#39;children&#39;),
    [Input(&#39;change-ann&#39;,&#39;n_clicks&#39;)],
    [ State(&#39;genomes-table&#39;, &#39;derived_virtual_data&#39;),
     State(&#39;genomes-table&#39;, &#39;selected_rows&#39;),
     State(&#39;tooltip-label-new-annotation-selected&#39;, &#39;children&#39;),
     State(&#39;radioitems-new-annotation&#39;, &#39;value&#39;)]
    )
def change_annotation(nChg, rows, selected_row, selected_new_ann, selected_type):
    if nChg is None:
        raise PreventUpdate
    if len(selected_row) == 0:
        return dbc.Alert(&#34;Warning! Please select a Genome!&#34;, is_open=True, duration=5000, color = &#39;warning&#39; )
    selected_new_ann = selected_new_ann.split(&#39;Full Path: &#39;)[-1]
    if not isfile(selected_new_ann):
        return dbc.Alert(&#34;Error! The selected file does not exist!&#34;, is_open=True, duration=7000, color = &#39;danger&#39; )
    if selected_type is None:
        return dbc.Alert(&#34;Warning! Please select an option (Overwrite or Extend)!&#34;, is_open=True, duration=7000, color = &#39;warning&#39; )
    row = pd.DataFrame(rows).iloc[selected_row,:] 
    annotationFile = row[&#34;Annotation File&#34;].iloc[0]

    if selected_type == &#39;replace&#39;:
        subprocess.run([&#39;cp&#39;, selected_new_ann ,current_working_directory + &#39;annotations/&#39; + annotationFile])
    else:
        with open (current_working_directory + &#39;annotations/&#39; + annotationFile, &#39;a&#39;) as oldAnn:
            with open (selected_new_ann, &#39;r&#39;) as newAnn:
                for line in newAnn:
                    oldAnn.write(&#34;\n&#34;+line.strip())
                    
    
    # from GUI import annotations as ann
    # ann.startChangeAnn(current_working_directory+&#34;/annotations/&#34;+str(annotationFile))
    
    #Return an alert if the job is completed
    return dbc.Alert(
            &#34;Completed! The annotation file is updated!&#34;,
            id=&#34;alert-auto&#34;,
            is_open=True,
            duration=5000,
        )</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.checkEmailValidity">
              <code class="name flex">
                <span>def <span class="ident">checkEmailValidity</span></span
                >(<span>val)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Checks email validity (i.e. an '@' is present) and changes the
                  border to green or red accordingly.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>val</strong>]
                    <strong>example-email</strong> (<em>value</em>): string of
                    the email
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>example-email</strong> (<em>style</em>): dictionary
                    of the style for the Input email: change border to red (if
                    no '@' in <strong>val</strong>) or to green
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;example-email&#39;, &#39;style&#39;),
    [Input(&#39;example-email&#39;, &#39;value&#39;)]
)
def checkEmailValidity(val):
    &#39;&#39;&#39;
    Checks email validity (i.e. an &#39;@&#39; is present) and changes the border to green or red accordingly.

    ***Args***
    
    + [**val**] **example-email** (*value*): string of the email

    ***Returns***

    + **example-email** (*style*): dictionary of the style for the Input email: change border to red (if no &#39;@&#39; in **val**) or to green
    &#39;&#39;&#39;
    if val is None:
        raise PreventUpdate

    if &#39;@&#39; in val:
        return {&#39;border&#39;:&#39;1px solid #94f033&#39;, &#39;outline&#39;:&#39;0&#39;}
    return {&#39;border&#39;:&#39;1px solid red&#39;}</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.checkInput">
              <code class="name flex">
                <span>def <span class="ident">checkInput</span></span
                >(<span
                  >n, n_close, genome_selected, pam, text_guides, mms, dna, rna,
                  len_guide_seq, active_tab, is_open)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Checks the presence and correctness of the input fields,
                  changing their border to red if it's missing and displaying a
                  Modal element with a list of the missing inputs. The callback
                  is triggered when the user clicks on the 'Submit' button or
                  when the modal is closed (by the 'Close' button or by clicking
                  on-screen when the Modal element is open)
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>check-job</strong> (<em>n_clicks</em>): button that
                    starts the job after checking the correctness of the input
                  </li>
                  <li>
                    [<strong>n_close</strong>]
                    <strong>close</strong> (<em>n_clicks</em>): button that
                    closes the opened modal
                  </li>
                  <li>
                    [<strong>genome_selected</strong>]
                    <strong>available-genome</strong> (<em>value</em>): string
                    of the selected genome from the Dropdown.
                    <code>None</code> if not selected, '' if selected and then
                    deleted
                  </li>
                  <li>
                    [<strong>pam</strong>]
                    <strong>available-pam</strong> (<em>value</em>): string of
                    the selected PAM from the Dropdown. <code>None</code> if not
                    selected, '' if selected and then deleted
                  </li>
                  <li>
                    [<strong>text_guides</strong>]
                    <strong>text-guides</strong> (<em>value</em>): string of the
                    input guides from the Textarea. <code>None</code> if not
                    selected, '' if selected and then deleted
                  </li>
                  <li>
                    [<strong>mms</strong>]
                    <strong>mms</strong> (<em>value</em>): int of the selected
                    mismatch value. <code>None</code> if not selected, '' if
                    selected and then deleted
                  </li>
                  <li>
                    [<strong>dna</strong>]
                    <strong>dna</strong> (<em>value</em>): int of the selected
                    DNA bulge value. <code>None</code> if not selected, '' if
                    selected and then deleted
                  </li>
                  <li>
                    [<strong>rna</strong>]
                    <strong>rna</strong> (<em>value</em>): int of the selected
                    RNA bulge value. <code>None</code> if not selected, '' if
                    selected and then deleted
                  </li>
                  <li>
                    [<strong>len_guide_seq</strong>]
                    <strong>len-guide-sequence-ver</strong> (<em>value</em>):
                    int value of the length of the guides (available when
                    'Sequence' tab is active). <code>None</code> if not
                    selected, '' if selected and then deleted
                  </li>
                  <li>
                    [<strong>active_tab</strong>]
                    <strong>tabs</strong> (<em>active_tab</em>): string of the
                    ID of the active tab ('Guide' or 'Sequence')
                  </li>
                  <li>
                    [<strong>is_open</strong>]
                    <strong>modal</strong> (<em>is_open</em>): True if the modal
                    is displayed, false otherwise
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>submit-job</strong> (<em>n_clicks</em>): reset the
                    click counter (<code>None</code>) if some inputs are
                    missing, else put to <code>1</code> in order to trigger the
                    <code
                      ><a
                        title="crisprme_off.changeUrl"
                        href="#crisprme_off.changeUrl"
                        >changeUrl()</a
                      ></code
                    >
                    function and proceed with the job
                  </li>
                  <li>
                    <strong>modal</strong> (<em>is_open</em>):
                    <code>True</code> if some inputs are missing,
                    <code>False</code> otherwise
                  </li>
                  <li>
                    <strong>available-genome</strong> (<em>className</em>):
                    string containing the name of the css class for the
                    red-border ('missing-input'), indicating a missing input.
                    <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>available-pam</strong> (<em>className</em>): string
                    containing the name of the css class for the red-border
                    ('missing-input'), indicating a missing input.
                    <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>text-guides</strong> (<em>style</em>): dictionary
                    for the style element (NOTE not updated if input is missing)
                  </li>
                  <li>
                    <strong>mms</strong> (<em>className</em>): string containing
                    the name of the css class for the red-border
                    ('missing-input'), indicating a missing input.
                    <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>dna</strong> (<em>className</em>): string containing
                    the name of the css class for the red-border
                    ('missing-input'), indicating a missing input.
                    <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>rna</strong> (<em>className</em>): string containing
                    the name of the css class for the red-border
                    ('missing-input'), indicating a missing input.
                    <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>len-guide-sequence-ver</strong>
                    (<em>className</em>): string containing the name of the css
                    class for the red-border ('missing-input'), indicating a
                    missing input. <code>None</code> if input is ok
                  </li>
                  <li>
                    <strong>warning-list</strong> (<em>children</em>): html.Div
                    for the Modal component, listing the missing inputs
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;submit-job&#39;, &#39;n_clicks&#39;),
    Output(&#39;modal&#39;, &#39;is_open&#39;),
    Output(&#39;available-genome&#39;, &#39;className&#39;),
    Output(&#39;available-pam&#39;, &#39;className&#39;),
    Output(&#39;text-guides&#39;, &#39;style&#39;),
    Output(&#39;mms&#39;, &#39;className&#39;),
    Output(&#39;dna&#39;, &#39;className&#39;),
    Output(&#39;rna&#39;, &#39;className&#39;),
    Output(&#39;len-guide-sequence-ver&#39;, &#39;className&#39;),
    Output(&#39;warning-list&#39;, &#39;children&#39;)],
    [Input(&#39;check-job&#39;,&#39;n_clicks&#39;),
    Input(&#39;close&#39;,&#39;n_clicks&#39;)],
    [State(&#39;available-genome&#39;, &#39;value&#39;),
    State(&#39;available-pam&#39;,&#39;value&#39;),
    State(&#39;text-guides&#39;, &#39;value&#39;),
    State(&#39;mms&#39;,&#39;value&#39;),
    State(&#39;dna&#39;,&#39;value&#39;),
    State(&#39;rna&#39;,&#39;value&#39;),
    State(&#39;len-guide-sequence-ver&#39;,&#39;value&#39;),
    State(&#39;tabs&#39;,&#39;active_tab&#39;),
    State(&#34;modal&#34;, &#34;is_open&#34;)]
)
def checkInput(n, n_close, genome_selected, pam, text_guides, mms, dna, rna, len_guide_seq, active_tab ,is_open):
    &#39;&#39;&#39;
    Checks the presence and correctness of the input fields, changing their border to red if it&#39;s missing and displaying a Modal element with 
    a list of the missing inputs. The callback is triggered when the user clicks on the &#39;Submit&#39; button or when the modal is closed 
    (by the &#39;Close&#39; button or by clicking on-screen when the Modal element is open)
    
    ***Args***

    + [**n**] **check-job** (*n_clicks*): button that starts the job after checking the correctness of the input
    + [**n_close**] **close** (*n_clicks*): button that closes the opened modal
    + [**genome_selected**] **available-genome** (*value*): string of the selected genome from the Dropdown. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**pam**] **available-pam** (*value*): string of the selected PAM from the Dropdown. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**text_guides**] **text-guides** (*value*): string of the input guides from the Textarea. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**mms**] **mms** (*value*): int of the selected mismatch value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**dna**] **dna** (*value*): int of the selected DNA bulge value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**rna**] **rna** (*value*): int of the selected RNA bulge value. `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**len_guide_seq**] **len-guide-sequence-ver** (*value*): int value of the length of the guides (available when &#39;Sequence&#39; tab is active). `None` if not selected, &#39;&#39; if selected
    and then deleted
    + [**active_tab**] **tabs** (*active_tab*): string of the ID of the active tab (&#39;Guide&#39; or &#39;Sequence&#39;)
    + [**is_open**] **modal** (*is_open*): True if the modal is displayed, false otherwise

    ***Returns***

    + **submit-job** (*n_clicks*): reset the click counter (`None`) if some inputs are missing, else put to `1` in order to trigger the `changeUrl()`
    function and proceed with the job
    + **modal** (*is_open*): `True` if some inputs are missing, `False` otherwise
    + **available-genome** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **available-pam** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **text-guides** (*style*): dictionary for the style element (NOTE not updated if input is missing)
    + **mms** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **dna** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **rna** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **len-guide-sequence-ver** (*className*): string containing the name of the css class for the red-border (&#39;missing-input&#39;), indicating a missing input. `None` if 
    input is ok
    + **warning-list** (*children*): html.Div for the Modal component, listing the missing inputs
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    if is_open is None:
        is_open = False
    
    classname_red = &#39;missing-input&#39;
    genome_update = None
    pam_update = None
    text_update = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;}
    mms_update = None
    dna_update = None
    rna_update = None
    len_guide_update = None
    update_style = False
    miss_input_list = []
    
    if genome_selected is None or genome_selected == &#39;&#39;:
        genome_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Genome&#39;)
    if pam is None or pam == &#39;&#39;:
        pam_update = classname_red
        update_style = True
        miss_input_list.append(&#39;PAM&#39;)
    # if text_guides is None or text_guides == &#39;&#39;:
        # text_update = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;,&#39;border&#39;: &#39;1px solid red&#39;}
        # update_style = True
        # miss_input_list.append(&#39;crRNA sequence(s)&#39;)
    if mms is None or str(mms) == &#39;&#39;:
        mms_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Allowed Mismatches&#39;)
    if dna is None or str(dna) == &#39;&#39;:
        dna_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Bulge DNA size&#39;)
    if rna is None or str(rna) == &#39;&#39;:
        rna_update = classname_red
        update_style = True
        miss_input_list.append(&#39;Bulge RNA size&#39;)
    if (len_guide_seq is None or str(len_guide_seq) == &#39;&#39;) and (&#39;sequence-tab&#39; in active_tab):
        len_guide_update = classname_red
        update_style = True
        miss_input_list.append(&#39;crRNA length&#39;)
    miss_input = html.Div(
        [
            html.P(&#39;The following inputs are missing:&#39;),
            html.Ul([html.Li(x) for x in miss_input_list]),
            html.P(&#39;Please fill in the values before submitting the job&#39;)
        ]
    )
    
    if not update_style:
        return 1, False, genome_update, pam_update, text_update, mms_update, dna_update, rna_update, len_guide_update, miss_input
    return None, not is_open, genome_update, pam_update, text_update, mms_update, dna_update, rna_update, len_guide_update, miss_input</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.clusterPage">
              <code class="name flex">
                <span>def <span class="ident">clusterPage</span></span
                >(<span>job_id, hash)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def clusterPage(job_id, hash):
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    style_hide_reference = {&#39;display&#39;:&#39;none&#39;}
    value_hide_reference = []
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
        style_hide_reference = {}
        value_hide_reference = [&#39;hide-ref&#39;, &#39;hide-cluster&#39;]
    final_list = []
    final_list.append(
        html.H3(&#39;Selected Position: &#39; + chromosome + &#39; - &#39; + position)
    )
    
    
    if genome_type == &#39;ref&#39;:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_REF, COL_REF_TYPE)]
        file_to_grep = &#39;.targets.cluster.txt&#39;       
    else:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
        file_to_grep = &#39;.total.cluster.txt&#39;
    # print(&#39;qui cluster before grep&#39;)
    
    cluster_grep_result = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.txt&#39;
    put_header = &#39;head -1 &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + file_to_grep + &#39; &gt; &#39; + cluster_grep_result + &#39; ; &#39;
    # print(&#39;esiste cluster?&#39; , str(os.path.exists(cluster_grep_result)) )
    if not os.path.exists(cluster_grep_result):    #Example    job_id.chr3_100.guide.txt
        #Grep annotation for ref
        if genome_type == &#39;ref&#39;:#NOTE HEADER NON SALVATO
            get_annotation = subprocess.Popen([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.Annotation.targets.txt&#39; + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39;&#39;], shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            out, err = get_annotation.communicate()
            annotation_type = out.decode(&#39;UTF-8&#39;).strip().split(&#39;\t&#39;)[-1]
            subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34; {print $0\&#34;\\t&#39; + annotation_type + &#39;\&#34;}\&#39; &gt; &#39; + cluster_grep_result], shell = True)
        else:  
            # print(&#39;qui cluster in grep&#39;)     #NOTE HEADER NON SALVATO       
            subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39; &gt; &#39; + cluster_grep_result], shell = True)  #NOTE top1 will have sample and annotation, other targets will have &#39;.&#39;-&gt; 18/03 all samples and annotation are already writter for all targets
        subprocess.Popen([&#39;zip &#39; + cluster_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + cluster_grep_result], shell = True)
    final_list.append(
        html.Div(job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide ,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbyposition-targets&#39;)
    ) 

    scomposition_file = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.scomposition.txt&#39;
    file_to_grep = &#39;.samples.annotation.txt&#39;

    iupac_scomposition_visibility = {&#39;display&#39;:&#39;none&#39;}
    if genome_type != &#39;ref&#39;:                   
        iupac_scomposition_visibility = {}
        if not os.path.exists(scomposition_file):    #Example    job_id.chr_pos.guide.scomposition.txt
            subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34; &amp;&amp; $13!=\&#34;n\&#34;\&#39; &gt; &#39; + scomposition_file], shell = True)

    final_list.append(html.P(
        [
            html.P(&#39;List of all the configurations for the target in the selected position.&#39;, style = iupac_scomposition_visibility),
            dcc.Checklist(
                options = [{&#39;label&#39;: &#39;Hide Reference Targets&#39;, &#39;value&#39;: &#39;hide-ref&#39;}, {&#39;label&#39;: &#39;Show only TOP1 Target&#39;, &#39;value&#39;: &#39;hide-cluster&#39;}], 
                id=&#39;hide-reference-targets&#39;, value = value_hide_reference, style = style_hide_reference
            ),
            html.Div(
                [   
                    html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbyposition&#39;), 
                    dcc.Interval(interval = 5*1000, id = &#39;interval-sumbyposition&#39;)
                ]

            )
        ]
    )
    )
    
    cols_for_scomposition = cols.copy()
    cols_for_scomposition.append({&#34;name&#34;: &#39;Samples&#39;, &#34;id&#34;: &#39;Samples&#39;, &#39;type&#39;:&#39;text&#39;, &#39;hideable&#39;:True})
    final_list.append(
        html.Div(
            dash_table.DataTable(
                id = &#39;table-scomposition-cluster&#39;,          #TABLE that represent scomposition of iupac of selected target, take rows from top_1.samples.txt
                columns=cols_for_scomposition, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            style = iupac_scomposition_visibility
        )
    )

    final_list.append(html.Hr())

    #Cluster Table
    final_list.append(
        &#39;List of Targets found for the selected position. Other possible configurations of the target are listed in the table above, along with the corresponding samples list.&#39;, # The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
    )
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-position-target&#39;, 
                columns=cols, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    # final_list.append(html.Div(&#39;&#39;, id =&#39;target-to-highlight&#39;))
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.colorSelectedRow">
              <code class="name flex">
                <span>def <span class="ident">colorSelectedRow</span></span
                >(<span>sel_cel, all_guides)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update the background color of the row of the main table when
                  the user clicks on a cell. Also change to bold the 'Reference'
                  and 'Enriched' labels.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>sel_cel</strong>]
                    <strong>general-profile-table</strong>
                    (<em>selected_cells</em>): list contaning the selected row
                    of the main guide table
                  </li>
                  <li>
                    [<strong>all_guides</strong>]
                    <strong>general-profile-table</strong> (<em>data</em>): list
                    of all the rows that are currenty displayed in the main
                    guide table
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>general-profile-table</strong>
                    (<em>style_data_conditional</em>): dictionary of the style
                    for the main table
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;general-profile-table&#39;, &#39;style_data_conditional&#39;),
    [Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;)]
)
def colorSelectedRow(sel_cel, all_guides):
    &#39;&#39;&#39;
    Update the background color of the row of the main table when the user clicks on a cell. Also change to bold the &#39;Reference&#39; and &#39;Enriched&#39;
    labels.

    ***Args***

    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table

    ***Returns***

    + **general-profile-table** (*style_data_conditional*): dictionary of the style for the main table
    &#39;&#39;&#39;
    if sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    #Change background color of all the rows that have the &#39;Guide&#39; column equal to the selected guide (guides are unique)
    return [
        {
            &#39;if&#39;: {
                    &#39;filter_query&#39;: &#39;{Guide} eq &#34;&#39; + guide + &#39;&#34;&#39;
                },
                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;
            },
            {
            &#39;if&#39;: {
                    &#39;column_id&#39; :&#39;Genome&#39;
                },
                &#39;font-weight&#39;:&#39;bold&#39;,
                &#39;textAlign&#39;: &#39;center&#39;      
            }
    ]</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.downloadLinkGuide">
              <code class="name flex">
                <span>def <span class="ident">downloadLinkGuide</span></span
                >(<span>n, file_to_load, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;download-link-sumbyguide&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbyguide&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbyguide&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbyguide-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkGuide(n, file_to_load, search): #file to load = job_id.RNA.1.0.guide
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.downloadLinkPosition">
              <code class="name flex">
                <span>def <span class="ident">downloadLinkPosition</span></span
                >(<span>n, file_to_load, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;download-link-sumbyposition&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbyposition&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbyposition&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbyposition-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkPosition(n, file_to_load, search): #file to load = 
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.downloadLinkSample">
              <code class="name flex">
                <span>def <span class="ident">downloadLinkSample</span></span
                >(<span>n, file_to_load, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;download-link-sumbysample&#39;, &#39;children&#39;),
    Output(&#39;interval-sumbysample&#39;, &#39;disabled&#39;)],
    [Input(&#39;interval-sumbysample&#39;,&#39;n_intervals&#39;)],
    [State(&#39;div-info-sumbysample-targets&#39;,&#39;children&#39;),
    State(&#39;url&#39;, &#39;search&#39;)]
)
def downloadLinkSample(n, file_to_load, search): #file to load = job_id.HG001.guide
    if n is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    file_to_load = file_to_load + &#39;.zip&#39;
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + file_to_load):
        return html.A(&#39;Download zip&#39;, href=URL+&#39;/data/&#39; + job_id + &#39;/&#39; + file_to_load, target = &#39;_blank&#39; ), True
    
    return &#39;Generating download link, Please wait...&#39;, False</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogAnnotation">
              <code class="name flex">
                <span>def <span class="ident">fileDialogAnnotation</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;selected-annotationfile&#39;, &#39;children&#39;),
    [Input(&#39;button-select-annotation&#39;,&#39;n_clicks&#39;)]
)
def fileDialogAnnotation(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;,&#39;annotations&#39;) </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogPam">
              <code class="name flex">
                <span>def <span class="ident">fileDialogPam</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;selected-pamfile&#39;, &#39;children&#39;),
    [Input(&#39;button-select-pam&#39;,&#39;n_clicks&#39;)]
)
def fileDialogPam(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;) </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogRefGenome">
              <code class="name flex">
                <span>def <span class="ident">fileDialogRefGenome</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;selected-referencegenome&#39;, &#39;children&#39;),
    [Input(&#39;button-select-refgenome&#39;,&#39;n_clicks&#39;)]
)
def fileDialogRefGenome(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;D&#39;,&#39;Genomes&#39;)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogSamplesID">
              <code class="name flex">
                <span>def <span class="ident">fileDialogSamplesID</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
Output(&#39;selected-sampleIDfile&#39;, &#39;children&#39;),
[Input(&#39;button-select-sampleID&#39;,&#39;n_clicks&#39;)]
)
def fileDialogSamplesID(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;F&#39;,&#39;samplesID&#39;)  </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogUpdateAnnotation">
              <code class="name flex">
                <span
                  >def
                  <span class="ident">fileDialogUpdateAnnotation</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;label-new-annotation-selected&#39;, &#39;children&#39;),
    Output(&#39;tooltip-label-new-annotation-selected&#39;, &#39;children&#39;)],
    [Input(&#39;button-choose-new-annotation&#39;, &#39;n_clicks&#39;)]
)
def fileDialogUpdateAnnotation(n):
    selected_file = openDialog(n, &#39;F&#39;)
    return &#39;Selected: &#39; + os.path.basename(selected_file), &#39;Full Path: &#39; + selected_file</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.fileDialogVCF">
              <code class="name flex">
                <span>def <span class="ident">fileDialogVCF</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;selected-vcf&#39;, &#39;children&#39;),
    [Input(&#39;button-select-vcf&#39;,&#39;n_clicks&#39;)]
)
def fileDialogVCF(n):
    return &#39;Selected: &#39; + openDialog(n, &#39;D&#39;)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.filterPositionTable">
              <code class="name flex">
                <span>def <span class="ident">filterPositionTable</span></span
                >(<span
                  >nPrev, nNext, filter_q, n, search, sel_cel, all_guides,
                  current_page, mms_bulge)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Filtering/changing page of the table in the Summary by
                  Position tab.
                </p>
                <p>
                  <strong><em>Args</em></strong> + [<strong>nPrev</strong>]
                  <strong>prev-page-position</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of last click on
                  Previous Page button + [<strong>nNext</strong>]
                  <strong>next-page-position</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of last click on
                  Next Page button + [<strong>filter_q</strong>]
                  <strong>div-position-filter-query</strong>
                  (<em>children</em>): string of the filter query +
                  [<strong>n</strong>]
                  <strong>button-filter-position</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of the Apply
                  Filter button + [<strong>search</strong>]
                  <strong>url</strong> (<em>search</em>): string containing the
                  job ID, eg '?job=QV99PN6XDL' + [<strong>sel_cel</strong>]
                  <strong>general-profile-table</strong>
                  (<em>selected_cells</em>): list contaning the selected row of
                  the main guide table + [<strong>all_guides</strong>]
                  <strong>general-profile-table</strong> (<em>data</em>): list
                  of all the rows that are currenty displayed in the main guide
                  table + [<strong>current_page</strong>]
                  <strong>div-current-page-table-samples</strong>
                  (<em>children</em>): string containing the current page of the
                  table (eg '1/15') + [<strong>mms_bulge</strong>]
                  <strong>div-mms-bulge-position</strong> (<em>children</em>):
                  string containing the value of the max mismatch and bulge
                  value (eg. '6-2')
                </p>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-table-position</strong> (<em>children</em>):
                    html.Table with filtering applied and/or next/previous page
                    of data
                  </li>
                  <li>
                    <strong>div-current-page-table-position</strong>
                    (<em>children</em>): string of the currently displayed page
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;div-table-position&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-table-position&#39;, &#39;children&#39;)],
    [Input(&#39;prev-page-position&#39;,&#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-position&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-position-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-filter-position&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;selected_cells&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;div-current-page-table-position&#39;, &#39;children&#39;),
    State(&#39;div-mms-bulges-position&#39;, &#39;children&#39;)]
)
def filterPositionTable(nPrev, nNext, filter_q, n, search, sel_cel, all_guides, current_page, mms_bulge):
    &#39;&#39;&#39;
    Filtering/changing page of the table in the Summary by Position tab.

    ***Args***
    + [**nPrev**] **prev-page-position** (*n_clicks_timestamp*): int timestamp of last click on Previous Page button
    + [**nNext**] **next-page-position** (*n_clicks_timestamp*): int timestamp of last click on Next Page button
    + [**filter_q**] **div-position-filter-query** (*children*): string of the filter query
    + [**n**] **button-filter-position** (*n_clicks_timestamp*): int timestamp of the Apply Filter button
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**current_page**] **div-current-page-table-samples** (*children*): string containing the current page of the table (eg &#39;1/15&#39;)
    + [**mms_bulge**] **div-mms-bulge-position** (*children*): string containing the value of the max mismatch and bulge value (eg. &#39;6-2&#39;)

    ***Returns***

    + **div-table-position** (*children*): html.Table with filtering applied and/or next/previous page of data
    + **div-current-page-table-position** (*children*): string of the currently displayed page    
    &#39;&#39;&#39;

    if sel_cel is None:
        raise PreventUpdate
    if nPrev is None and nNext is None and n is None:
        raise PreventUpdate
    
    if nPrev is None:
        nPrev = 0
    if nNext is None:
        nNext = 0
    if n is None:
        n = 0

    filter_q = filter_q.split(&#39;,&#39;)
    chr = filter_q[0]
    if chr == &#39;None&#39;:
        chr = None
    pos_begin = filter_q[1]
    if pos_begin == &#39;None&#39;:
        pos_begin = None
    pos_end = filter_q[2]
    if pos_end == &#39;None&#39;:
        pos_end = None
    
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    mms = int(mms_bulge.split(&#39;-&#39;)[0])
    max_bulges = int(mms_bulge.split(&#39;-&#39;)[1])
    btn_position_section = []
    btn_position_section.append(n)
    btn_position_section.append(nPrev)
    btn_position_section.append(nNext)
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    if max(btn_position_section) == n:              #Last button pressed is filtering, return the first page of the filtered table
        if pos_begin is None or pos_begin == &#39;&#39;:
            pos_begin = 0
        if pos_end == &#39;&#39;:
            pos_end = None
        if pos_end:
            if int(pos_end) &lt; int(pos_begin):
                pos_end = None
        df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
        
        df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        if chr is None or chr == &#39;&#39;:
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, 1, mms, max_bulges,guide, job_id ), &#39;1/&#39; + str(max_page)
        if pos_end is None:
            df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
        else:
            df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        return generate_table_position(df, &#39;table-position&#39;, 1, mms, max_bulges,guide, job_id ), &#39;1/&#39;+ str(max_page)
    else:
        
        if max(btn_position_section) == nNext:
            current_page = current_page + 1
            if chr:
                if pos_begin is None or pos_begin == &#39;&#39;:
                    pos_begin = 0
                if pos_end == &#39;&#39;:
                    pos_end = None
                if pos_end:
                    if int(pos_end) &lt; int(pos_begin):
                        pos_end = None
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)#, nrows = current_page * 10)   
            df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if chr:
                if pos_end is None:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
            if ((current_page - 1) * 10) &gt; len(df): 
                current_page = current_page -1
                if current_page &lt; 1:
                    current_page = 1
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, current_page, mms, max_bulges,guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
        else:                       #Go to previous page
            current_page = current_page - 1
            if current_page &lt; 1:
                current_page = 1

            if chr:
                if pos_begin is None or pos_begin == &#39;&#39;:
                    pos_begin = 0
                if pos_end == &#39;&#39;:
                    pos_end = None
                if pos_end:
                    if int(pos_end) &lt; int(pos_begin):
                        pos_end = None
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)  
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)#, nrows = current_page * 10)   
            df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if chr:
                if pos_end is None:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) )].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Chromosome&#39;] != chr) | ((df[&#39;Chromosome&#39;] == chr) &amp; (df[&#39;Position&#39;] &lt; int(pos_begin)) | (df[&#39;Position&#39;] &gt; int(pos_end)))].index , inplace = True)
            
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_position(df, &#39;table-position&#39;, current_page, mms, max_bulges,guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.filterSampleTable">
              <code class="name flex">
                <span>def <span class="ident">filterSampleTable</span></span
                >(<span
                  >nPrev, nNext, filter_q, n, search, sel_cel, all_guides,
                  current_page)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Filtering/changing page of the table in the Summary by Sample
                  tab.
                </p>
                <p>
                  <strong><em>Args</em></strong> + [<strong>nPrev</strong>]
                  <strong>prev-page-sample</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of last click on
                  Previous Page button + [<strong>nNext</strong>]
                  <strong>next-page-sample</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of last click on
                  Next Page button + [<strong>filter_q</strong>]
                  <strong>div-sample-filter-query</strong> (<em>children</em>):
                  string of the filter query + [<strong>n</strong>]
                  <strong>button-filter-population-sample</strong>
                  (<em>n_clicks_timestamp</em>): int timestamp of the Apply
                  Filter button + [<strong>search</strong>]
                  <strong>url</strong> (<em>search</em>): string containing the
                  job ID, eg '?job=QV99PN6XDL' + [<strong>sel_cel</strong>]
                  <strong>general-profile-table</strong>
                  (<em>selected_cells</em>): list contaning the selected row of
                  the main guide table + [<strong>all_guides</strong>]
                  <strong>general-profile-table</strong> (<em>data</em>): list
                  of all the rows that are currenty displayed in the main guide
                  table + [<strong>current_page</strong>]
                  <strong>div-current-page-table-samples</strong>
                  (<em>children</em>): string containing the current page of the
                  table (eg '1/15')
                </p>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-table-samples</strong> (<em>children</em>):
                    html.Table with filtering applied and/or next/previous page
                    of data
                  </li>
                  <li>
                    <strong>div-current-page-table-samples</strong>
                    (<em>children</em>): string of the currently displayed page
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;div-table-samples&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-table-samples&#39;, &#39;children&#39;)],
    [Input(&#39;prev-page-sample&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-sample&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-sample-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-filter-population-sample&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;selected_cells&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;div-current-page-table-samples&#39;, &#39;children&#39;)]
)
def filterSampleTable( nPrev, nNext, filter_q, n, search, sel_cel, all_guides, current_page):
    &#39;&#39;&#39;
    Filtering/changing page of the table in the Summary by Sample tab.

    ***Args***
    + [**nPrev**] **prev-page-sample** (*n_clicks_timestamp*): int timestamp of last click on Previous Page button
    + [**nNext**] **next-page-sample** (*n_clicks_timestamp*): int timestamp of last click on Next Page button
    + [**filter_q**] **div-sample-filter-query** (*children*): string of the filter query
    + [**n**] **button-filter-population-sample** (*n_clicks_timestamp*): int timestamp of the Apply Filter button
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**current_page**] **div-current-page-table-samples** (*children*): string containing the current page of the table (eg &#39;1/15&#39;)

    ***Returns***

    + **div-table-samples** (*children*): html.Table with filtering applied and/or next/previous page of data
    + **div-current-page-table-samples** (*children*): string of the currently displayed page
    &#39;&#39;&#39;
    if sel_cel is None:
        raise PreventUpdate
    if nPrev is None and nNext is None and n is None:
        raise PreventUpdate

    if nPrev is None:
        nPrev = 0
    if nNext is None:
        nNext = 0
    if n is None:
        n = 0
    
    sup_pop = filter_q.split(&#39;,&#39;)[0]
    pop = filter_q.split(&#39;,&#39;)[1]
    samp = filter_q.split(&#39;,&#39;)[2]
    if sup_pop == &#39;None&#39;:
        sup_pop = None
    if pop == &#39;None&#39;:
        pop = None
    if samp == &#39;None&#39; or samp == &#39;NONE&#39;:
        samp = None
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    btn_sample_section = []
    btn_sample_section.append(n)
    btn_sample_section.append(nPrev)
    btn_sample_section.append(nNext)
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    if genome_type == &#39;both&#39;:
        col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
    else:
        col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]       
    if max(btn_sample_section) == n:              #Last button pressed is filtering, return the first page of the filtered table
        if genome_type == &#39;both&#39;:
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
        else:
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        if (sup_pop is None or sup_pop == &#39;&#39;) and (pop is None or pop == &#39;&#39;) and (samp is None or samp == &#39;&#39;):   #No filter value selected
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), &#39;1/&#39; + str(max_page)
        if samp is None or samp == &#39;&#39;:
            if pop is None or pop == &#39;&#39;:
                df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
            else:
                df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
        else:
            df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        return generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), &#39;1/&#39; + str(max_page)
    else:
        if max(btn_sample_section) == nNext:
            current_page = current_page + 1
            if genome_type == &#39;both&#39;:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
                df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            #Active filter
            if pop or sup_pop or samp:
                if samp is None or samp == &#39;&#39;:
                    if pop is None or pop == &#39;&#39;:
                        df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
                    else:
                        df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)

            if ((current_page - 1) * 10) &gt; len(df): 
                current_page = current_page -1
                if current_page &lt; 1:
                    current_page = 1
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, current_page, guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
        
        else:   #Go to previous page
            current_page = current_page - 1
            if current_page &lt; 1:
                current_page = 1
            if genome_type == &#39;both&#39;:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            else:
                df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
                df = df.sort_values(&#39;Targets in Reference&#39;, ascending = False)
                df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
                df.drop([&#39;Class&#39;], axis = 1, inplace = True) 
            more_info_col = []
            for i in range(df.shape[0]):
                more_info_col.append(&#39;Show Targets&#39;)
            df[&#39;&#39;] = more_info_col
            if pop or sup_pop or samp:
                if samp is None or samp == &#39;&#39;:
                    if pop is None or pop == &#39;&#39;:
                        df.drop(df[(~(df[&#39;Population&#39;].isin(population_1000gp[sup_pop])))].index , inplace = True)
                    else:
                        df.drop(df[(df[&#39;Population&#39;] != pop)].index , inplace = True)
                else:
                    df.drop(df[(df[&#39;Sample&#39;] != samp)].index , inplace = True)
            max_page = len(df.index)
            max_page = math.floor(max_page / 10) + 1
            return generate_table_samples(df, &#39;table-samples&#39;, current_page, guide, job_id ), str(current_page) + &#39;/&#39; + str(max_page)
    raise PreventUpdate</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.generate_table">
              <code class="name flex">
                <span>def <span class="ident">generate_table</span></span
                >(<span
                  >dataframe, id_table, genome_type, guide='', job_id='',
                  max_rows=2600)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>Generates an html.Table for the Summary by Guide section.</p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>dataframe</strong>: dataframe containing the data to
                    display
                  </li>
                  <li>
                    <strong>id_table</strong>: string that identifies the ID of
                    the new generated html.Table
                  </li>
                  <li>
                    <strong>genome_type</strong>: string containing the type of
                    the search ('ref', 'var' or 'both')
                  </li>
                  <li><strong>guide</strong>: string of the selected guide</li>
                  <li><strong>job_id</strong>: string of the current jobID</li>
                  <li>
                    <strong>max_rows</strong>: int of the max number of rows of
                    the table
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    html.Table() containing data for the Summary by Guide
                    section
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def generate_table(dataframe, id_table, genome_type, guide=&#39;&#39;, job_id=&#39;&#39;, max_rows=2600):
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Guide section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **genome_type**: string containing the type of the search (&#39;ref&#39;, &#39;var&#39; or &#39;both&#39;)
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Guide section
    &#39;&#39;&#39;
    if genome_type == &#39;both&#39;:
        header = [html.Tr([
            html.Th(&#39;Bulge Type&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Mismatches&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Bulge Size&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;Targets found in Genome&#39;, colSpan = str(3), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;PAM Creation&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;&#39;, rowSpan = &#39;2&#39;),
            ])
        ]
    # &#39;Bulge Type&#39; &#39;Mismatches&#39; &#39;Bulge Size&#39; &#39;Targets in Reference&#39; &#39;Targets in Enriched&#39; &#39;Combined&#39; &#39;PAM Creation&#39; &#39;&#39;
    
        header.append(html.Tr([html.Th(x, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for x in [&#39;Reference&#39;, &#39;Enriched&#39;,&#39;Combined&#39;]]))
    else:
        header = [html.Tr([html.Th(col, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns])]
    return html.Table(
        # Header
        # [html.Tr([html.Th(col) if col != &#39;Targets in Enriched&#39; else html.Th(html.Abbr(col, title = &#39;Counting of targets that are generated by the insertion of a IUPAC nucleotide of a sample&#39;, 
        # style = {&#39;text-decoration&#39;:&#39;underline&#39;})) for col in dataframe.columns])] +
        # [html.Tr([html.Th(col, rowSpan = 2) if &#39;Targets&#39; not in col or &#39;Combined&#39; not in col else html.Th(&#39;Targets&#39;) for col in dataframe.columns])] +
        header  + 
        # Body
        [html.Tr([
            html.Td(html.A(dataframe.iloc[i][col],  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;new&#39; + dataframe.iloc[i][&#39;Bulge Type&#39;] + str(dataframe.iloc[i][&#39;Bulge Size&#39;]) + str(dataframe.iloc[i][&#39;Mismatches&#39;]) , target = &#39;_blank&#39; ), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) if col == &#39;&#39; else  html.Td(dataframe.iloc[i][col],style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns
        ]) for i in range(min(len(dataframe), max_rows))],
        style = {&#39;display&#39;:&#39;inline-block&#39;},
        id = id_table
    )</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.generate_table_position">
              <code class="name flex">
                <span
                  >def <span class="ident">generate_table_position</span></span
                >(<span
                  >dataframe, id_table, page, mms, bulges, guide='', job_id='',
                  max_rows=10)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Generates an html.Table for the Summary by Position section.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>dataframe</strong>: dataframe containing the data to
                    display
                  </li>
                  <li>
                    <strong>id_table</strong>: string that identifies the ID of
                    the new generated html.Table
                  </li>
                  <li>
                    <strong>page</strong>: int containing the current page of
                    the table
                  </li>
                  <li>
                    <strong>mms</strong>: int value of the max allowed
                    mismatched
                  </li>
                  <li>
                    <strong>bulges</strong>: int value of the max allowed bulges
                  </li>
                  <li><strong>guide</strong>: string of the selected guide</li>
                  <li><strong>job_id</strong>: string of the current jobID</li>
                  <li>
                    <strong>max_rows</strong>: int of the max number of rows of
                    the table
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    html.Table() containing data for the Summary by Position
                    section
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def generate_table_position(dataframe, id_table, page, mms, bulges, guide = &#39;&#39;, job_id = &#39;&#39;, max_rows = 10): #NOTE v2 della tabella posizioni       #TODO modifica layout righe per allinearle
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Position section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **page**: int containing the current page of the table
    + **mms**: int value of the max allowed mismatched
    + **bulges**: int value of the max allowed bulges
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Position section
    &#39;&#39;&#39;
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    header = [html.Tr([
        html.Th(&#39;Chromosome&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Position&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Best Target&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Min Mismatch&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Min Bulge&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Bulge&#39;, rowSpan = &#39;2&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;Targets in Cluster by Mismatch Value&#39;, colSpan = str(mms +1), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
        html.Th(&#39;&#39;, rowSpan = &#39;2&#39;),
        ])
    ]
    mms_header = []
    for mm in range (mms +1):
        mms_header.append(html.Th(str(mm) + &#39; MM&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}))
    header.append(html.Tr(mms_header))
    
    data = []
    for i in range(min(rows_remaining, max_rows)):
        first_cells = [
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Chromosome&#39;], rowSpan = str(bulges +1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Position&#39;], rowSpan = str(bulges +1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Best Target&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Min Mismatch&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Td(dataframe.iloc[i + (page - 1)*max_rows][&#39;Min Bulge&#39;], rowSpan = str(bulges+1),  style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}),
            html.Th(&#39;0 Bulge&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;, &#39;padding-left&#39;:&#39;0&#39;})
        ]
        
        mm_cells = [html.Td(dataframe.iloc[i + (page - 1)*max_rows][col], style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) for col in dataframe.columns[5:5+mms+1]]
        data.append(html.Tr(first_cells + mm_cells + [html.Td(
                html.A(&#39;Show Targets&#39;,  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;-Pos-&#39; + str(dataframe.iloc[i + (page - 1)*max_rows][&#39;Chromosome&#39;]) + &#39;-&#39; +  str(dataframe.iloc[i + (page - 1)*max_rows][&#39;Position&#39;]) , target = &#39;_blank&#39;), 
                rowSpan = str(bulges+1), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
            ]))
        for b in range (bulges):
            data.append(
                html.Tr(
                    [html.Th(str(b +1) + &#39; Bulge&#39;, style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;} )]
                    +
                    [html.Td(dataframe.iloc[i + (page - 1)*max_rows][col]) for col in dataframe.columns[5 + (b +1) *(mms +1) : 5 + (b +1) *(mms+1) + mms +1]]
                )
            )
    
    return html.Table(header + data, style = {&#39;display&#39;:&#39;inline-block&#39;}, id = id_table)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.generate_table_results">
              <code class="name flex">
                <span
                  >def <span class="ident">generate_table_results</span></span
                >(<span>dataframe, page, max_rows=10)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"><p>Generate table for History page</p></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def generate_table_results(dataframe, page, max_rows = 10):
    &#39;&#39;&#39;
    Generate table for History page
    &#39;&#39;&#39;
    fl = []
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    header = html.Thead(
            html.Tr([html.Th(col,style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;}) if col != &#39;Load&#39; and col != &#39;Delete&#39; else html.Th(&#39;&#39;,style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})  for col in dataframe.columns])
        )
    body_history = []
    add_button = 0
    for i in range(min(rows_remaining, max_rows)):
        add_button += 1
        row_hist = []
        for col in dataframe.columns:
            if col == &#39;Load&#39;:
                row_hist.append(
                        html.Td(html.A(&#39;Load&#39;, target = &#39;_blank&#39;, href = dataframe.iloc[i + (page - 1)*max_rows][col]), style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                )
            elif col == &#39;Delete&#39;:
                row_hist.append(
                    html.Td(html.Button(&#39;Delete&#39;, id = &#39;button-delete-history-&#39;+str(i), **{&#39;data-jobid&#39;:dataframe.iloc[i + (page - 1)*max_rows][&#39;Job ID&#39;]}),style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                )
            else:
                row_hist.append(
                        html.Td(dataframe.iloc[i + (page - 1)*max_rows][col], style = {&#39;vertical-align&#39;:&#39;middle&#39;, &#39;text-align&#39;:&#39;center&#39;})
                    )
        body_history.append(html.Tr(row_hist))
    fl.append(
        html.Table([
            header,
            html.Tbody(body_history)
        ], style = {&#39;display&#39;:&#39;inline-block&#39;},)
    )
    
    for i in range(add_button, 10): #Add hidden buttons for callback removeJobId compatibility
        fl.append(html.Button(
            str(i), id = &#39;button-delete-history-&#39;+str(i),**{&#39;data-jobid&#39;:&#39;None&#39;}, style = {&#39;display&#39;:&#39;none&#39;}
            ))
    return fl</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.generate_table_samples">
              <code class="name flex">
                <span
                  >def <span class="ident">generate_table_samples</span></span
                >(<span
                  >dataframe, id_table, page, guide='', job_id='',
                  max_rows=10)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Generates an html.Table for the Summary by Sample section.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>dataframe</strong>: dataframe containing the data to
                    display
                  </li>
                  <li>
                    <strong>id_table</strong>: string that identifies the ID of
                    the new generated html.Table
                  </li>
                  <li>
                    <strong>page</strong>: int containing the current page of
                    the table
                  </li>
                  <li><strong>guide</strong>: string of the selected guide</li>
                  <li><strong>job_id</strong>: string of the current jobID</li>
                  <li>
                    <strong>max_rows</strong>: int of the max number of rows of
                    the table
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    html.Table() containing data for the Summary by Sample
                    section
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def generate_table_samples(dataframe, id_table, page ,guide=&#39;&#39;, job_id=&#39;&#39;, max_rows=10):
    &#39;&#39;&#39;
    Generates an html.Table for the Summary by Sample section.

    ***Args***

    + **dataframe**: dataframe containing the data to display
    + **id_table**: string that identifies the ID of the new generated html.Table
    + **page**: int containing the current page of the table
    + **guide**: string of the selected guide
    + **job_id**: string of the current jobID
    + **max_rows**: int of the max number of rows of the table

    ***Returns***

    + html.Table() containing data for the Summary by Sample section
    &#39;&#39;&#39;
    rows_remaining = len(dataframe) - (page - 1) * max_rows
    return html.Table(
        # Header
        # [html.Tr([html.Th(col) if col != &#39;Targets in Enriched&#39;  else html.Th(html.Abbr(col, title = &#39;Counting of targets that are generated by the insertion of a IUPAC nucleotide of a sample&#39;,
        # style = {&#39;text-decoration&#39;:&#39;underline&#39;})) for col in dataframe.columns]) ] +  
        [html.Tr([html.Th(col) for col in dataframe.columns]) ] +
        # Body
        [html.Tr([
            html.Td(html.A(dataframe.iloc[i + (page - 1)*max_rows][col],  href = &#39;result?job=&#39; + job_id + &#39;#&#39; + guide +&#39;-Sample-&#39; + dataframe.iloc[i  + (page - 1)*max_rows][&#39;Sample&#39;] , target = &#39;_blank&#39; )) if col == &#39;&#39; else  html.Td(dataframe.iloc[i + (page - 1)*max_rows][col]) for col in dataframe.columns
        ]) for i in range(min(rows_remaining, max_rows))],
        style = {&#39;display&#39;:&#39;inline-block&#39;},
        id = id_table
    )</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.get_results">
              <code class="name flex">
                <span>def <span class="ident">get_results</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>Get a dataframe of the Results directory</p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def get_results():
    &#39;&#39;&#39;
    Get a dataframe of the Results directory
    &#39;&#39;&#39;
    results_dirs = [join(current_working_directory + &#39;/Results/&#39;, f) for f in listdir(current_working_directory + &#39;/Results/&#39;) if isdir(join(current_working_directory + &#39;/Results/&#39;, f)) and isfile(current_working_directory + &#39;/Results/&#39; + f + &#39;/Params.txt&#39;)]
    results_dirs.sort(key = os.path.getctime)   #Sorted older first
    results_dirs = [os.path.basename(f) for f in results_dirs]
    col = [&#39;Job ID&#39;, &#39;Genome&#39;, &#39;PAM&#39;, &#39;Mismatches&#39;, &#39;DNA Bulges&#39;, &#39;RNA Bulges&#39;, &#39;Gecko Comparison&#39;, &#39;Reference Comparison&#39;, &#39;Date&#39;, &#39;Load&#39;]
    a = pd.DataFrame(columns = col)
    for job in results_dirs:
        if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/Params.txt&#39;):
            with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/Params.txt&#39;) as p:
                all_params = p.read()
                mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
                genome_selected = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
                genome_selected = genome_selected.replace(&#39;_&#39;,&#39; &#39;)
                if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/log.txt&#39;):
                    with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/log.txt&#39;) as lo:
                        all_log = lo.read()
                    job_start = (next(s for s in all_log.split(&#39;\n&#39;) if &#39;Job\tStart&#39; in s)).split(&#39;\t&#39;)[-1]
                    try:
                        job_end = (next(s for s in all_log.split(&#39;\n&#39;) if &#39;Job\tDone&#39; in s)).split(&#39;\t&#39;)[-1]
                    except:
                        link_load = URL + &#39;/load?job=&#39; + job
                    else:
                        link_load = URL + &#39;/result?job=&#39; + job
                else:
                    job_start = &#39;n/a&#39;
                    link_load = URL + &#39;/load?job=&#39; + job
                dna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;DNA&#39; in s)).split(&#39;\t&#39;)[-1]
                rna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;RNA&#39; in s)).split(&#39;\t&#39;)[-1]
                pam = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Pam&#39; in s)).split(&#39;\t&#39;)[-1]
                gecko = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Gecko&#39; in s)).split(&#39;\t&#39;)[-1]
                if gecko == &#39;True&#39;:
                    gecko = &#39;Yes&#39;
                else:
                    gecko = &#39;No&#39;
                comparison = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
                if comparison == &#39;True&#39;:
                    comparison = &#39;Yes&#39;
                else:
                    comparison = &#39;No&#39;
                if os.path.exists(current_working_directory + &#39;/Results/&#39; + job + &#39;/guides.txt&#39;):
                    with open(current_working_directory  + &#39;/Results/&#39; + job + &#39;/guides.txt&#39;) as g:
                        n_guides = str(len(g.read().strip().split(&#39;\n&#39;)))
                else:
                    n_guides =&#39;n/a&#39;
                
                a = a.append({&#39;Job ID&#39;:job, &#39;Genome&#39;:genome_selected, &#39;Mismatches&#39;:mms, &#39;DNA Bulges&#39;:dna,
                &#39;RNA Bulges&#39;:rna, &#39;PAM&#39;:pam,&#39;Gecko Comparison&#39;:gecko,&#39;Reference Comparison&#39;:comparison, &#39;Date&#39;:job_start, &#39;Load&#39;: link_load, &#39;Delete&#39;:&#39;&#39;}, ignore_index = True)
    a = a.sort_values([&#39;Mismatches&#39;,&#39;DNA Bulges&#39;,&#39;RNA Bulges&#39;],ascending = [True, True, True])
    return a</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.global_store">
              <code class="name flex">
                <span>def <span class="ident">global_store</span></span
                >(<span>value)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Caching of files, mainly the ones for the 'Show Targets'
                  tables, to improve loading speed. NOTE that if two files have
                  the same name, then the generated cache will be the same, so a
                  regular cleaning of the 'Cache' directory is mandatory.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li><strong>value</strong>: string of the job ID to load</li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>df</strong>: dataframe for the 'Show Targets' table
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@cache.memoize()
def global_store(value):
    &#39;&#39;&#39;
    Caching of files, mainly the ones for the &#39;Show Targets&#39; tables, to improve loading speed. NOTE that if two files have the same name, then the
    generated cache will be the same, so a regular cleaning of the &#39;Cache&#39; directory is mandatory.

    ***Args***

    + **value**: string of the job ID to load 

    ***Returns***

    + **df**: dataframe for the &#39;Show Targets&#39; table
    &#39;&#39;&#39;
    if value is None:
        return &#39;&#39;
    target = [f for f in listdir(current_working_directory + &#39;Results/&#39; + value) if isfile(join(current_working_directory + &#39;Results/&#39;+value, f)) and f.endswith(&#39;scores.txt&#39;) ]
    if not target:
        target = [f for f in listdir(current_working_directory + &#39;Results/&#39; + value) if isfile(join(current_working_directory + &#39;Results/&#39;+value, f)) and f.endswith(&#39;targets.txt&#39;) ]
    
    df = pd.read_csv(current_working_directory + &#39;Results/&#39; +value + &#39;/&#39; + target[0], sep = &#39;\t&#39;)
    df.rename(columns = {&#34;#Bulge type&#34;:&#39;BulgeType&#39;, &#39;#Bulge_type&#39;:&#39;BulgeType&#39;,&#39;Bulge Size&#39;: &#39;BulgeSize&#39;, &#39;Bulge_Size&#39;: &#39;BulgeSize&#39;, &#39;Doench 2016&#39;:&#39;Doench2016&#39;,&#39;Doench_2016&#39;:&#39;Doench2016&#39;}, inplace = True)
    return df</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.global_store_general">
              <code class="name flex">
                <span>def <span class="ident">global_store_general</span></span
                >(<span>path_file_to_load)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Caching dei file targets per una miglior performance di
                  visualizzazione
                </p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@cache.memoize()
def global_store_general(path_file_to_load):
    &#39;&#39;&#39;
    Caching dei file targets per una miglior performance di visualizzazione
    &#39;&#39;&#39;
    if &#39;scomposition&#39; in path_file_to_load:
        rows_to_skip = 0
    else:
        rows_to_skip = 0        #Skip header
    if path_file_to_load is None:
        return &#39;&#39;
    if os.path.getsize(path_file_to_load) &gt; 0: 
        df = pd.read_csv( path_file_to_load , sep = &#39;\t&#39;, header = None, skiprows = rows_to_skip)
    else:
        df = None
    #df.rename(columns = {&#34;#Bulge type&#34;:&#39;Bulge Type&#39;, &#34;#Bulge_type&#34;:&#39;Bulge Type&#39;, &#39;Bulge_Size&#39;:&#39;Bulge Size&#39;}, inplace = True)
    return df</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.global_store_subset">
              <code class="name flex">
                <span>def <span class="ident">global_store_subset</span></span
                >(<span>value, bulge_t, bulge_s, mms, guide)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Caching of files for the subset table in the 'Show Targets'
                  link of the Summary by Guide tabe, to improve loading speed.
                  NOTE that if two files have the same name, then the generated
                  cache will be the same, so a regular cleaning of the 'Cache'
                  directory is mandatory.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li><strong>value</strong>: string of the job ID to load</li>
                  <li>
                    <strong>bulge_t</strong>: string of the type of bulge
                    selected
                  </li>
                  <li>
                    <strong>bulge_s</strong>: string of the number of bulges
                    selected
                  </li>
                  <li>
                    <strong>mms</strong>: string of the number of mismatches
                    selected
                  </li>
                  <li><strong>guide</strong>: string of the selected guide</li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>df</strong>: dataframe for the subset table of the
                    'Show Targets' table of the Summary by Guide
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@cache.memoize()
def global_store_subset(value, bulge_t, bulge_s, mms, guide):
    &#39;&#39;&#39;
    Caching of files for the subset table in the &#39;Show Targets&#39; link of the Summary by Guide tabe, to improve loading speed. NOTE that if two 
    files have the same name, then the generated cache will be the same, so a regular cleaning of the &#39;Cache&#39; directory is mandatory.

    ***Args***

    + **value**: string of the job ID to load 
    + **bulge_t**: string of the type of bulge selected
    + **bulge_s**: string of the number of bulges selected
    + **mms**: string of the number of mismatches selected
    + **guide**: string of the selected guide

    ***Returns***

    + **df**: dataframe for the subset table of the &#39;Show Targets&#39; table of the Summary by Guide
    &#39;&#39;&#39;
    if value is None:
        return &#39;&#39;
    #Skiprows = 1 to skip header of file
    df = pd.read_csv( current_working_directory + &#39;Results/&#39; + value + &#39;/&#39; + value + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;, header = None) #, skiprows = 1)
    return df</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.guidePagev3">
              <code class="name flex">
                <span>def <span class="ident">guidePagev3</span></span
                >(<span>job_id, hash)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Creates the layout for the 'Show Targets' page of the Summary
                  by Guide tab.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li><strong>job_id</strong>: string of the jobID</li>
                  <li>
                    <strong>hash</strong>: string containing the informations
                    about the selected 'Show Targets' row, eg
                    '#CCATCGGTGGCCGTTTGCCCNNNnewDNA10'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    list of Dash Components containing the layout of the page
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def guidePagev3(job_id, hash):
    &#39;&#39;&#39;
    Creates the layout for the &#39;Show Targets&#39; page of the Summary by Guide tab.

    ***Args***

    + **job_id**: string of the jobID
    + **hash**: string containing the informations about the selected &#39;Show Targets&#39; row, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewDNA10&#39;

    ***Returns***

    + list of Dash Components containing the layout of the page
    &#39;&#39;&#39;
    guide = hash[:hash.find(&#39;new&#39;)]
    mms = hash[-1:]
    bulge_s = hash[-2:-1]
    if &#39;DNA&#39; in hash:
        bulge_t = &#39;DNA&#39;
    elif &#39;RNA&#39; in hash:
        bulge_t = &#39;RNA&#39;
    else:
        bulge_t = &#39;X&#39;
    add_header = &#39; - Mismatches &#39; + str(mms)
    if bulge_t != &#39;X&#39;:
        add_header += &#39; - &#39; + str(bulge_t) + &#39; &#39; + str(bulge_s) 
    value = job_id
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    style_hide_reference = {&#39;display&#39;:&#39;none&#39;}
    value_hide_reference = []
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
        style_hide_reference = {}
        value_hide_reference = [&#39;hide-ref&#39;]
    final_list = []
    final_list.append(html.H3(&#39;Selected Guide: &#39; + guide + add_header))
    final_list.append(
        html.P(
            [
                &#39;List of Targets found for the selected guide. Select a row to view other possible configurations of the target, along with the corresponding samples list.&#39;, # &#39;Select a row to view the target IUPAC character scomposition. The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
                dcc.Checklist(options = [{&#39;label&#39;: &#39;Hide Reference Targets&#39;, &#39;value&#39;: &#39;hide-ref&#39;}], id=&#39;hide-reference-targets&#39;, value = value_hide_reference, style = style_hide_reference),
                html.Div(
                    [   
                        html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbyguide&#39;), 
                        dcc.Interval(interval = 5*1000, id = &#39;interval-sumbyguide&#39;)
                    ]
                )
            ]
        )
    )
    if genome_type == &#39;ref&#39;:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_REF, COL_REF_TYPE)]    
        file_to_grep = &#39;.Annotation.targets.txt&#39;#&#39;.top_1.txt&#39;
    else:
        cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
        file_to_grep = &#39;.samples.annotation.txt&#39;
    
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide_grep_result = job_directory + job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide + &#39;.txt&#39;
    put_header = &#39;head -1 &#39; + job_directory + job_id + file_to_grep + &#39; &gt; &#39; + guide_grep_result + &#39; ; &#39;
    final_list.append(
        html.Div(job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbyguide-targets&#39;)
    )
    
    if not os.path.exists(guide_grep_result):    #Example    job_id.X.0.4.guide.txt #NOTE HEADER NON SALVATO
        subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + job_directory + job_id + file_to_grep + &#39; | LC_ALL=C grep -F &#39; + bulge_t + &#39; | awk \&#39;$8==&#39; + mms + &#39; &amp;&amp; $9==&#39; + bulge_s + &#39;\&#39;&gt; &#39; + guide_grep_result], shell = True)
        subprocess.Popen([&#39;zip &#39; + guide_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + guide_grep_result], shell = True)
    global_store_subset(job_id, bulge_t, bulge_s, mms,guide)
    
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-subset-target&#39;, 
                columns=cols, 
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_cell_conditional=[
                    {
                        &#39;if&#39;: {&#39;column_id&#39;: &#39;Samples&#39;},
                        &#39;textAlign&#39;: &#39;left&#39;
                    }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                style_data_conditional = [
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                            },
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;
                        },
                ]            
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    final_list.append(html.Br())
    final_list.append(
        html.Div(
            id = &#39;div-second-table-subset-targets&#39;
        )
    )
    
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.historyPage">
              <code class="name flex">
                <span>def <span class="ident">historyPage</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"><p>Create the History page</p></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def historyPage():
    &#39;&#39;&#39;
    Create the History page
    &#39;&#39;&#39;
    results = get_results()
    final_list = []

    final_list.append(
        html.Div(
            [
                html.H3(&#39;Results History&#39;),
                html.P(&#39;List of available results. Click on the \&#39;Load\&#39; link to open the corresponding result in a new page.&#39;)
            ]
        )
    )
    final_list.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = availableGenomes(), id = &#39;dropdown-genomes-history&#39;, placeholder = &#39;Select a Genome&#39;))),
                                dbc.Col(html.Div(dcc.Dropdown(options = availablePAM(), id = &#39;dropdown-pam-history&#39;, placeholder = &#39;Select a PAM&#39;))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_mismatches, id = &#39;dropdown-mms-history&#39;, placeholder = &#39;Select a Mismatch value&#39; ))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_bulges, id = &#39;dropdown-dna-history&#39;, placeholder = &#39;Select a DNA Bulge value&#39; ))),
                                # dbc.Col(html.Div(dcc.Dropdown(options = av_bulges, id = &#39;dropdown-rna-history&#39;, placeholder = &#39;Select a RNA Bulge value&#39; ))),


                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-history&#39;)))
                            ]
                        ),
                    ],
                )
        )
    final_list.append(html.Div(&#39;None,None&#39;,id = &#39;div-history-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;}))

    final_list.append(
            html.Div(
                generate_table_results(results,1),
                id = &#39;div-history-table&#39;,
                style = {&#39;text-align&#39;: &#39;center&#39;}
            ),
    )
    final_list.append(
        html.Div(id = &#39;div-remove-jobid&#39;, style = {&#39;display&#39;:&#39;none&#39;})
    )
    final_list.append(
        html.Div(
            [
                html.Br(),
                html.Button(&#39;Prev&#39;, id = &#39;prev-page-history&#39;),
                html.Button(&#39;Next&#39;, id = &#39;next-page-history&#39;)
            ],
            style = {&#39;text-align&#39;: &#39;center&#39;}
        )
    )
    max_page = len(results.index)
    max_page = math.floor(max_page / 10) + 1
    final_list.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-history&#39;))
    page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return page</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.inExample">
              <code class="name flex">
                <span>def <span class="ident">inExample</span></span
                >(<span>nI, nR)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Inserts an example value in all fields to show the user an
                  example result, or reset the input fields. NOT available in
                  OFFLINE version.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>nI</strong>]
                    <strong>example-parameters</strong>
                    (<em>n_clicks_timestamp</em>): button that inserts the
                    example values
                  </li>
                  <li>
                    [<strong>nR</strong>]
                    <strong>remove-parameters</strong>
                    (<em>n_clicks_timestamp</em>): button that removes the
                    values and resets all the fields
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>available-genome</strong> (<em>value</em>): 'hg38
                    ref+hg38 1000genomeproject' as input example, or '' to reset
                    the value
                  </li>
                  <li>
                    <strong>available-pam</strong> (<em>value</em>):
                    '20bp-NGG-SpCas9' as input example, or '' to reset the value
                  </li>
                  <li>
                    <strong>text-guides</strong> (<em>value</em>):
                    'GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC' as input
                    example, or '' to reset the value
                  </li>
                  <li>
                    <strong>mms</strong> (<em>value</em>): '4' as input example,
                    or '' to reset the value
                  </li>
                  <li>
                    <strong>dna</strong> (<em>value</em>): '1' as input example,
                    or '' to reset the value
                  </li>
                  <li>
                    <strong>rna</strong> (<em>value</em>): '1' as input example,
                    or '' to reset the value
                  </li>
                  <li>
                    <strong>len-guide-sequence-ver</strong> (<em>value</em>):
                    '20' as input example, or '' to reset the value
                  </li>
                  <li>
                    <strong>text-sequence</strong> (<em>value</em>):
                    '&gt;sequence\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA'
                    as input example, or '' to reset the value
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;available-genome&#39;, &#39;value&#39;),
     Output(&#39;available-pam&#39;, &#39;value&#39;),
     Output(&#39;text-guides&#39;, &#39;value&#39;),
     Output(&#39;mms&#39;, &#39;value&#39;),
     Output(&#39;dna&#39;, &#39;value&#39;),
     Output(&#39;rna&#39;, &#39;value&#39;),
     Output(&#39;len-guide-sequence-ver&#39;, &#39;value&#39;),
     Output(&#39;text-sequence&#39;, &#39;value&#39;)],
     [Input(&#39;example-parameters&#39;, &#39;n_clicks_timestamp&#39;),
     Input(&#39;remove-parameters&#39;, &#39;n_clicks_timestamp&#39;)]
)
def inExample(nI, nR):
    &#39;&#39;&#39;
    Inserts an example value in all fields to show the user an example result, or reset the input fields. NOT available in OFFLINE version.
    
    ***Args***

    + [**nI**] **example-parameters** (*n_clicks_timestamp*): button that inserts the example values
    + [**nR**] **remove-parameters** (*n_clicks_timestamp*): button that removes the values and resets all the fields

    ***Returns***

    + **available-genome** (*value*): &#39;hg38 ref+hg38 1000genomeproject&#39; as input example, or &#39;&#39; to reset the value
    + **available-pam** (*value*): &#39;20bp-NGG-SpCas9&#39; as input example, or &#39;&#39; to reset the value
    + **text-guides** (*value*): &#39;GAGTCCGAGCAGAAGAAGAA\\nCCATCGGTGGCCGTTTGCCC&#39; as input example, or &#39;&#39; to reset the value
    + **mms** (*value*): &#39;4&#39; as input example, or &#39;&#39; to reset the value
    + **dna** (*value*): &#39;1&#39; as input example, or &#39;&#39; to reset the value
    + **rna** (*value*): &#39;1&#39; as input example, or &#39;&#39; to reset the value
    + **len-guide-sequence-ver** (*value*): &#39;20&#39; as input example, or &#39;&#39; to reset the value
    + **text-sequence** (*value*): &#39;&gt;sequence\\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39; as input example,
    or &#39;&#39; to reset the value
    &#39;&#39;&#39;

    if (nI is None) and (nR is None):
        raise PreventUpdate

    if nI is None:
        nI = 0

    if nR is None:
        nR = 0
    
    if nI &gt; 0:
        if nI &gt; nR:
            return &#39;hg38 ref+hg38 1000genomeproject&#39;, &#39;20bp-NGG-SpCas9&#39;, &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;, &#39;4&#39;, &#39;1&#39;, &#39;1&#39;, &#39;20&#39;, &#39;&gt;sequence\nTACCCCAAACGCGGAGGCGCCTCGGGAAGGCGAGGTGGGCAAGTTCAATGCCAAGCGTGACGGGGGA&#39;


    if nR &gt; 0:
        if nR &gt; nI:
            return &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.indexPage">
              <code class="name flex">
                <span>def <span class="ident">indexPage</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Creates the layout of the main page ('/'). The creation of the
                  main page is put under a function in order to reload the
                  genome and pam dropdown if a new genome is added, simply by
                  reloading the page.
                </p>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>index_page</strong> (<em>list</em>): list of html,
                    dcc and dbc components for the layout.
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def indexPage():
    &#39;&#39;&#39;
    Creates the layout of the main page (&#39;/&#39;). The creation of the main page is put under a function in order to reload the genome and pam dropdown
    if a new genome is added, simply by reloading the page.

    ***Returns***

    + **index_page** (*list*): list of html, dcc and dbc components for the layout.
    &#39;&#39;&#39;
    final_list = []
    final_list.extend([
        html.Div([
            &#39;CRISPRme  performs  predictive analysis and result assessment on population and individual specific CRISPR/Cas experiments.&#39; +  
            &#39; CRISPRme enumerates on- and off-target accounting simultaneously for  substitutions, DNA/RNA bulges and common genetic variants from the 1000 genomes project.&#39;+
            &#39; CRISPRme is based on CRISPRitz [1] a software tool for population target analyses.&#39;  
        + &#39; CRISPRme is devoted to individual specific on- and off-target analyses.&#39;
        ]),
        ])

    final_list.append(
        html.Div(
            [
                # html.P([&#39;Download the offline version here: &#39;, html.A(&#39;InfOmics/CRISPRitz&#39;, href = &#39;https://github.com/InfOmics/CRISPRitz&#39;, target=&#34;_blank&#34;), &#39; or &#39;, html.A(&#39;Pinellolab/CRISPRitz&#39;, href = &#39;https://github.com/pinellolab/CRISPRitz&#39;, target=&#34;_blank&#34;) ])
                html.Br()
            ]
        )
    )
    checklist_div = html.Div(
        [
            dbc.FormGroup(
                [
                    dbc.Checkbox(
                        id=&#34;checkbox-gecko&#34;, className=&#34;form-check-input&#34;, checked = True
                    ),
                    dbc.Label(
                        #html.P([&#39;Activate Gecko &#39;, html.Abbr(&#39;comparison&#39;, title =&#39;The results of your test guides will be compared with results obtained from a previous computed analysis on gecko library&#39;)]) ,
                        html.P(&#39;Compare your results with the GeCKO v2 library&#39;),
                        html_for=&#34;checkbox-gecko&#34;,
                        className=&#34;form-check-label&#34;,
                    ),
                    dbc.Checkbox(
                        id=&#34;checkbox-ref-comp&#34;, className=&#34;form-check-input&#34;
                    ),
                    dbc.Label(
                        html.P(&#39;Compare your results with the corresponding reference genome&#39;),
                        html_for=&#34;checkbox-ref-comp&#34;,
                        className=&#34;form-check-label&#34;,
                    )
                    
                ],
                check = True
            )
        ],
        id = &#39;checklist-test-div&#39;
    )

    modal = html.Div(
        [
            dbc.Modal(
                [
                    dbc.ModalHeader(&#34;WARNING! Missing inputs&#34;),
                    dbc.ModalBody(&#39;The following inputs are missing, please select values before submitting the job&#39;, id = &#39;warning-list&#39;),
                    dbc.ModalFooter(
                        dbc.Button(&#34;Close&#34;, id=&#34;close&#34; , className=&#34;modal-button&#34;)
                    ),
                ],
                id=&#34;modal&#34;,
                centered=True
            ),
        ]
    )

    tab_guides_content = html.Div(
        [
            html.P([
                &#39;Insert crRNA sequence(s), one per line.&#39;, 
                html.P(&#39;Sequences must have the same length and be provided without the PAM sequence&#39;, id = &#39;testP&#39;) ,
            ],
            style = {&#39;word-wrap&#39;: &#39;break-word&#39;}), 

            dcc.Textarea(id = &#39;text-guides&#39;, placeholder = &#39;GAGTCCGAGCAGAAGAAGAA\nCCATCGGTGGCCGTTTGCCC&#39;, style = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;, &#39;font-family&#39;:&#39;monospace&#39;, &#39;font-size&#39;:&#39;large&#39;}),
            dbc.FormText(&#39;Note: a maximum number of 1000 sequences can be provided&#39;, color = &#39;secondary&#39;)
        ],
        style = {&#39;width&#39;:&#39;450px&#39;} #NOTE same as text-area
    )
    tab_sequence_content = html.Div(
        [
            html.P([&#39;Search crRNAs by inserting one or more genomic sequences.&#39;, html.P(&#39;Chromosome ranges can also be supplied&#39;)],
            style = {&#39;word-wrap&#39;: &#39;break-word&#39;}), 

            dcc.Textarea(id = &#39;text-sequence&#39;, placeholder = &#39;&gt;sequence 1\nAAGTCCCAGGACTTCAGAAGagctgtgagaccttggc\n&gt;sequence2\nchr1:11,130,540-11,130,751&#39;, style = {&#39;width&#39;:&#39;450px&#39;, &#39;height&#39;:&#39;160px&#39;, &#39;font-family&#39;:&#39;monospace&#39;, &#39;font-size&#39;:&#39;large&#39;}),
            dbc.FormText(&#39;Note: a maximum number of 1000 characters can be provided&#39;, color = &#39;secondary&#39;)
        ],
        style = {&#39;width&#39;:&#39;450px&#39;} #NOTE same as text-area
    )
    final_list.append(
        html.Div(
            html.Div(
                [
                    modal,
                    html.Div(
                        [
                            html.Div([
                                html.H3(&#39;STEP 1&#39;, style = {&#39;margin-top&#39;:&#39;0&#39;}),
                                html.Div([
                                    html.P([html.Button(html.P(&#34;Load example&#34;, style={&#39;color&#39;:&#39;rgb(46,140,187)&#39;,&#39;text-decoration-line&#39;: &#39;underline&#39;, &#39;font-size&#39;:&#39;initial&#39;}), id=&#39;example-parameters&#39;,
                                                style={ &#39;border&#39;: &#39;None&#39;, &#39;text-transform&#39;: &#39;capitalize&#39;,&#39;height&#39;:&#39;12&#39;,&#39;font-weight&#39;: &#39;500&#39;, &#39;padding&#39;: &#39;0 0px&#39;,&#39;textcolor&#39;:&#39;blu&#39;}), &#39; - &#39;,
                                    #html.Br(),
                                    html.Button(html.P(children=&#34;Reset&#34;, style={&#39;color&#39;:&#39;rgb(46,140,187)&#39;,&#39;text-decoration-line&#39;: &#39;underline&#39;,&#39;font-size&#39;:&#39;initial&#39;}), id=&#39;remove-parameters&#39;,
                                                style={&#39;border&#39;: &#39;None&#39;, &#39;text-transform&#39;: &#39;capitalize&#39;,&#39;height&#39;:&#39;12&#39;,&#39;font-weight&#39;: &#39;500&#39;, &#39;padding&#39;: &#39;0 0px&#39;})])
                                ], style = {&#39;display&#39;:DISPLAY_ONLINE})
                            ], className = &#39;flex-div-insert-delete-example&#39;), 
                            
                            html.P(html.P(&#39;Select a genome&#39;) ),
                            html.Div(
                                dcc.Dropdown(options = availableGenomes(), clearable = False, id = &#34;available-genome&#34;,) #style = {&#39;width&#39;:&#39;75%&#39;})
                            ),
                            dbc.FormText(&#39;Note: Genomes enriched with variants are indicated with a \&#39;+\&#39; symbol&#39;, color=&#39;secondary&#39;),
                            
                            html.Div(
                                [
                                    html.Div(
                                        [
                                            html.P(html.P(&#39;Select PAM&#39;)),
                                            html.Div(
                                                dcc.Dropdown(options = availablePAM(), clearable = False, id = &#39;available-pam&#39;)
                                            )
                                        ],
                                        style = {&#39;flex&#39;:&#39;0 0 100%&#39;, &#39;margin-top&#39;: &#39;10%&#39;}
                                    )
                                ],
                                id = &#39;div-pam&#39;,
                                className = &#39;flex-div-pam&#39;
                            ),
                            html.Br(),
                            html.Button(&#34;Add New Genome&#34;, id = &#39;add-genome&#39;, style = {&#39;margin-right&#39;:&#39;5px&#39;, &#39;display&#39;:DISPLAY_OFFLINE}),
                            html.Div(&#39;&#39;, id = &#39;genome-job&#39;, style = {&#39;display&#39;:&#39;none&#39;}),
                            html.Button(&#34;Update dictionary&#34;, id = &#39;update-dict&#39;, style = {&#39;margin-left&#39;:&#39;5px&#39;, &#39;display&#39;:DISPLAY_OFFLINE}),
                            html.Div(&#39;&#39;, id = &#39;dict-job&#39;, style = {&#39;display&#39;:&#39;none&#39;}),
                            html.Div(
                                [
                                    html.Ul(
                                        [html.Li(
                                            [html.A(&#39;Contact us&#39;, href = URL + &#39;/contacts&#39;, target=&#34;_blank&#34;),&#39; to request new genomes availability in the dropdown list&#39;],
                                            style = {&#39;margin-top&#39;:&#39;5%&#39;, &#39;display&#39;: DISPLAY_ONLINE}
                                        ),
                                        ],
                                        style = {&#39;list-style&#39;:&#39;inside&#39;}
                                    ),
                                ],
                                style = {&#39;height&#39;:&#39;50%&#39;}
                            ),
                        ],
                        id = &#39;step1&#39;,
                        style = {&#39;flex&#39;:&#39;0 0 30%&#39;, &#39;tex-align&#39;:&#39;center&#39;}
                    ),
                    html.Div(style = {&#39;border-right&#39;:&#39;solid 1px white&#39;}),
                    html.Div(
                        [
                            html.H3(&#39;STEP 2&#39;, style = {&#39;margin-top&#39;:&#39;0&#39;}),
                            html.Div(
                                [
                                    html.Div(
                                        [   html.P(&#39;Select the input type&#39;),
                                            dbc.Tabs(
                                                [
                                                    dbc.Tab(tab_guides_content, label=&#39;Guides&#39;, tab_id= &#39;guide-tab&#39;),
                                                    dbc.Tab(tab_sequence_content, label=&#39;Sequence&#39;, tab_id = &#39;sequence-tab&#39;)
                                                ],
                                                active_tab=&#39;guide-tab&#39;,
                                                id = &#39;tabs&#39;
                                            )
                                        ],
                                        id = &#39;div-guides&#39;
                                    ),
                                    html.Div(
                                        [
                                            html.P(&#39;Allowed mismatches&#39;),
                                            dcc.Dropdown(options = av_mismatches, clearable = False, id = &#39;mms&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            html.P(&#39;Bulge DNA size&#39;),
                                            dcc.Dropdown(options = av_bulges, clearable = False, id = &#39;dna&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            html.P(&#39;Bulge RNA size&#39;),
                                            dcc.Dropdown(options = av_bulges, clearable = False, id = &#39;rna&#39;, style = {&#39;width&#39;:&#39;60px&#39;}),
                                            dbc.Fade(
                                                [
                                                    html.P(&#39;crRNA length (without PAM)&#39;),
                                                    dcc.Dropdown(options = av_guide_sequence, clearable = False, id = &#39;len-guide-sequence-ver&#39;, style = {&#39;width&#39;:&#39;60px&#39;})
                                                ],
                                                id = &#39;fade-len-guide&#39;, is_in= False, appear= False
                                            )
                                        ]
                                    )
                                ],
                                className = &#39;flex-step2&#39;
                            )

                        ],
                        id = &#39;step2&#39;,
                        style = {&#39;flex&#39;:&#39;0 0 40%&#39;}
                        
                    ),
                    html.Div(style = {&#39;border-right&#39;:&#39;solid 1px white&#39;}),
                    html.Div(
                        [
                            html.H3(&#39;Advanced Options&#39;, style = {&#39;margin-top&#39;:&#39;0px&#39;}),
                            checklist_div,
                            dcc.Checklist(
                                options = [
                                    {&#39;label&#39;:&#39;Notify me by email&#39;,&#39;value&#39;:&#39;email&#39;, &#39;disabled&#39;:False}
                                ], 
                                id = &#39;checklist-advanced&#39;,
                                style = {&#39;display&#39;: DISPLAY_ONLINE}
                            ),
                            dbc.Fade(
                                [
                                    dbc.FormGroup(
                                        [
                                            dbc.Label(&#34;Email&#34;, html_for=&#34;example-email&#34;),
                                            dbc.Input(type=&#34;email&#34;, id=&#34;example-email&#34;, placeholder=&#34;Enter email&#34;, className=&#39;exampleEmail&#39;)
                                        ]
                                    )
                                ],
                                id = &#39;fade&#39;, is_in= False, appear= False, 
                            ),
                            html.Div(
                                [
                                    html.Button(&#39;Submit&#39;, id = &#39;check-job&#39;, style = {&#39;background-color&#39;:&#39;skyblue&#39;}),
                                    html.Button(&#39;&#39;, id = &#39;submit-job&#39;, style = {&#39;display&#39;:&#39;none&#39;})
                                ],
                                style = {&#39;display&#39;:&#39;inline-block&#39;, &#39;margin&#39;:&#39;0 auto&#39;}   #style=&#34;height:55px; width:150px&#34;
                            )
                        ],
                        id = &#39;step3&#39;,
                        style = {&#39;tex-align&#39;:&#39;center&#39;},
                        className = &#39;flex-step3&#39;
                    )
                ],
                id = &#39;div-steps&#39;,
                style = {&#39;margin&#39;:&#39;1%&#39;},
                className = &#39;flex-div-steps&#39;
            ),
            style = {&#39;background-color&#39;:&#39;rgba(154, 208, 150, 0.39)&#39;, &#39;border-radius&#39;: &#39;10px&#39;, &#39;border&#39;:&#39;1px solid black&#39;},
            id = &#39;steps-background&#39;
        )
    )
    final_list.append(html.Br())
    final_list.append(html.P(&#39;[1] Cancellieri, Samuele, et al. \&#34;Crispritz: rapid, high-throughput, and variant-aware in silico off-target site identification for crispr genome editing.\&#34; Bioinformatics (2019).&#39;))
    final_list.append(
        html.P([&#39;Download CRISPRitz here: &#39;, html.A(&#39;InfOmics/CRISPRitz&#39;, href = &#39;https://github.com/InfOmics/CRISPRitz&#39;, target=&#34;_blank&#34;), &#39; or &#39;, html.A(&#39;Pinellolab/CRISPRitz&#39;, href = &#39;https://github.com/pinellolab/CRISPRitz&#39;, target=&#34;_blank&#34;) ])
    )
    index_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return index_page</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.loadDistributionPopulations">
              <code class="name flex">
                <span
                  >def
                  <span class="ident">loadDistributionPopulations</span></span
                >(<span>sel_cel, all_guides, job_id)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>Load the barplot images from the 'assets' directory.</p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>sel_cel</strong>]
                    <strong>general-profile-table</strong>
                    (<em>selected_cells</em>): list contaning the selected row
                    of the main guide table
                  </li>
                  <li>
                    [<strong>all_guides</strong>]
                    <strong>general-profile-table</strong> (<em>data</em>): list
                    of all the rows that are currenty displayed in the main
                    guide table
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>content-collapse-population</strong>
                    (<em>children</em>): list of Dash Components with the images
                    of the Populations Distribution
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;content-collapse-population&#39;, &#39;children&#39;),
    [Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;url&#39;,&#39;search&#39;)]
)
def loadDistributionPopulations(sel_cel, all_guides, job_id):
    &#39;&#39;&#39;
    Load the barplot images from the &#39;assets&#39; directory.

    ***Args***

    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **content-collapse-population** (*children*): list of Dash Components with the images of the Populations Distribution
    &#39;&#39;&#39;
    if sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    job_id = job_id.split(&#39;=&#39;)[-1]

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1])
        max_bulges = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1])

    distributions = [dbc.Row(html.P(&#39;On- and Off-Targets distributions in the Reference and Enriched Genome. For the Enriched Genome, the targets are divided into 5 SuperPopulations (EAS, EUR, AFR, AMR, SAS).&#39;, style = {&#39;margin-left&#39;:&#39;0.75rem&#39;}))]

    for i in range(math.ceil((mms + max_bulges + 1) / BARPLOT_LEN)):
        all_images = []
        for mm in range (i * BARPLOT_LEN, (i + 1) * BARPLOT_LEN ):
            if mm &lt; (mms + max_bulges + 1):
                try:
                    all_images.append(
                        dbc.Col(  
                            [   
                                html.A(
                                    html.Img(
                                        src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/populations_distribution_&#39; + guide + &#39;_&#39; + str(mm) + &#39;total.png&#39;, &#39;rb&#39;).read()).decode()),
                                        id = &#39;distribution-population&#39; + str(mm), width=&#34;100%&#34;, height=&#34;auto&#34;
                                    ),
                                    target=&#34;_blank&#34;,
                                    href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + &#39;populations_distribution_&#39; + guide + &#39;_&#39; + str(mm) + &#39;total.png&#39;
                                ),
                                html.Div(html.P(&#39;Distribution &#39; + str(mm) + &#39; Mismatches + Bulges &#39;, style = {&#39;display&#39;:&#39;inline-block&#39;} ),style = {&#39;text-align&#39;:&#39;center&#39;})
                            ]
                        )
                    )
                except:
                    all_images.append(
                        dbc.Col(
                            [
                                html.Div(html.P(&#39;No Targets found with &#39; + str(mm) + &#39; Mismatches + Bulges&#39; , style = {&#39;display&#39;:&#39;inline-block&#39;}), style = {&#39;text-align&#39;:&#39;center&#39;}),
                                # html.Div(html.P(&#39;Distribution &#39; + str(mm) + &#39; Mismatches + Bulges &#39;, style = {&#39;display&#39;:&#39;inline-block&#39;} ),style = {&#39;text-align&#39;:&#39;center&#39;})
                            ],
                            align = &#39;center&#39;
                        )
                    )
            else:
                all_images.append(dbc.Col(html.P(&#39;&#39;)))
        
        distributions.append(
            html.Div(
                [
                    dbc.Row(
                        all_images
                    )
                ]
            )
        )
    return distributions</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.loadFullSubsetTable">
              <code class="name flex">
                <span>def <span class="ident">loadFullSubsetTable</span></span
                >(<span
                  >active_cel, data, cols, search, style_data, sel_cell)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;div-second-table-subset-targets&#39;, &#39;children&#39;),
    Output(&#39;table-subset-target&#39;, &#39;style_data_conditional&#39;)],
    [Input(&#39;table-subset-target&#39;, &#39;active_cell&#39;)],
    [State(&#39;table-subset-target&#39;, &#39;data&#39;),
    State(&#39;table-subset-target&#39;, &#39;columns&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;table-subset-target&#39;, &#39;style_data_conditional&#39;),
    State(&#39;table-subset-target&#39;, &#39;selected_cells&#39;)]
)
def loadFullSubsetTable(active_cel, data, cols, search, style_data, sel_cell):
    #NOTE tabella secondaria della scomposizione ora non serve, non cancello il codice ma uso PreventUpdate per non azionare la funzione
    if False:
        raise PreventUpdate
    if active_cel is  None:
        raise PreventUpdate
    fl = []
    job_id = search.split(&#39;=&#39;)[-1]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
    
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    if genome_type == &#39;ref&#39;:
        raise PreventUpdate
    #fl.append(html.Br())
    fl.append(html.Hr())
    #Table for IUPAC scomposition
    #fl.append(html.Br())
    fl.append(&#39;List of all the configurations for the selected target.&#39;)
    fl.append(html.Br())
    cols.append({&#34;name&#34;: &#39;Samples&#39;, &#34;id&#34;: &#39;Samples&#39;, &#39;type&#39;:&#39;text&#39;, &#39;hideable&#39;:True})  

       
    fl.append(
        html.Div(
            dash_table.DataTable(
                id=&#39;second-table-subset-targets&#39;, 
                columns=cols, 
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                },
                style_cell_conditional=[
                    {
                        &#39;if&#39;: {&#39;column_id&#39;: &#39;Samples&#39;},
                        &#39;textAlign&#39;: &#39;left&#39;
                    }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                style_data_conditional = [
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                        }
                ]         
            )
        )
    )

    pos_cluster = data[int(sel_cell[0][&#39;row&#39;])][&#39;Cluster Position&#39;]
    chrom = data[int(sel_cell[0][&#39;row&#39;])][&#39;Chromosome&#39;]
    cells_style = [
                       style_data[0],
                        {
                            &#39;if&#39;: {
                                    &#39;filter_query&#39;: &#39;{Cluster Position} eq &#34;&#39; + str(pos_cluster) + &#39;&#34;&#39;,
                                    ##&#39;filter_query&#39;: &#39;{Chromosome} eq &#34;&#39; + str(chrom) + &#39;&#34;&#39;,
                                    #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                                    #&#39;column_id&#39; :&#39;{Total}&#39;
                                },
                                #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                                
                        }
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    return  fl, cells_style</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.openDialog">
              <code class="name flex">
                <span>def <span class="ident">openDialog</span></span
                >(<span>n, type_ask, start_dir='./')</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def openDialog(n, type_ask, start_dir = &#39;./&#39;):
    if n is None:
        raise PreventUpdate
    root = tk.Tk()
    root.withdraw()
    if type_ask == &#39;D&#39;:
        selected = filedialog.askdirectory(initialdir = current_working_directory + start_dir)
    else:
        selected = filedialog.askopenfilename(initialdir = current_working_directory + start_dir)
    root.destroy()
    if selected == &#39;&#39; or selected == &#39;()&#39;:
        selected = &#39;None&#39;
    return str(selected)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.openResultDirectory">
              <code class="name flex">
                <span>def <span class="ident">openResultDirectory</span></span
                >(<span>n, search, guide)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Opens a new tab where the final list of off-targets is shown
                  (NOT available when ONLINE mode is selected)
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>button-open-result-directory</strong>
                    (<em>n_cliks</em>): number of times the button was pressed
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                  <li>
                    [<strong>guide</strong>]
                    <strong>div-open-result-directory</strong>
                    (<em>children</em>): string of the currently selected guide
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    Opens a new tab showing the off-target list of
                    jobID.targets.GUIDE.txt final file
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-open-result-directory&#39;, &#39;children&#39;),
    [Input(&#39;button-open-result-directory&#39;, &#39;n_clicks&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-open-result-directory&#39;, &#39;children&#39;)]
)
def openResultDirectory(n, search, guide):
    &#39;&#39;&#39;
    Opens a new tab where the final list of off-targets is shown (NOT available when ONLINE mode is selected)

    ***Args***

    + [**n**] **button-open-result-directory** (*n_cliks*): number of times the button was pressed
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**guide**] **div-open-result-directory** (*children*): string of the currently selected guide

    ***Returns***

    + Opens a new tab showing the off-target list of jobID.targets.GUIDE.txt final file
    &#39;&#39;&#39;
    if n is None or ONLINE:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]  #TODO decidere se aprire tutta la cartella, solo il file, e nel secondo caso creare copia submit job che non rimuova .targets.GUIDE.txt
    wb.open_new_tab(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.txt&#39;)
    raise PreventUpdate</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.parse_contents">
              <code class="name flex">
                <span>def <span class="ident">parse_contents</span></span
                >(<span>contents)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>Read the uploaded file and converts into bit</p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def parse_contents(contents):
    &#39;&#39;&#39;
    Read the uploaded file and converts into bit
    &#39;&#39;&#39;
    content_type, content_string = contents.split(&#39;,&#39;)
    decoded = base64.b64decode(content_string)
    return decoded</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.refreshSearch">
              <code class="name flex">
                <span>def <span class="ident">refreshSearch</span></span
                >(<span>n, dir_name)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  The Interval component of the '/load' page calls this function
                  every 3 seconds. The function checks the status of the
                  submitted job by means of the log and output file created and
                  updated by the submit_job.final.sh script, and notifies the
                  user about the current status ('To Do', 'Done' etc.) When the
                  job is completed, a link directing to the '/result' page is
                  shown. If the job doesn't exists or is in the queue, a
                  notification will appear.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>load-page-check</strong> (<em>n_intervals</em>):
                    element of the Interval component that shows the number of
                    time it has been fired
                  </li>
                  <li>
                    [<strong>dir_name</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>view-results</strong> (<em>style</em>): dictionary
                    for the style element of the link that redirects to the
                    '/result' page. If the job is completed then the
                    {'visibility':'visible'} is returned, else
                    {'visibility':'visible'}
                  </li>
                  <li>
                    <strong>search-status</strong> (<em>children</em>): html.P()
                    that contains the status of the search phase. Can be:
                    <ul>
                      <li>To Do, red</li>
                      <li>Done, green</li>
                      <li>Currently ongoing, orange</li>
                      <li>Not Available, red</li>
                    </ul>
                  </li>
                  <li>
                    <strong>generate-report-status</strong> (<em>children</em>):
                    html.P() that contains the status of the generate report.
                    Can be as above
                  </li>
                  <li>
                    <strong>post-process-status</strong> (<em>children</em>):
                    html.P() that contains the status of the post process phase.
                    Can be as above
                  </li>
                  <li>
                    <strong>view-results</strong> (<em>href</em>): link that
                    redirects to the '/result' page
                  </li>
                  <li>
                    <strong>no-directory-error</strong> (<em>children</em>):
                    Alert component that notify the user that the result is not
                    present in the server, or is in the queue
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;view-results&#39;, &#39;style&#39;),
    Output(&#39;search-status&#39;, &#39;children&#39;),
    Output(&#39;generate-report-status&#39;, &#39;children&#39;),
    Output(&#39;post-process-status&#39;, &#39;children&#39;),
    Output(&#39;view-results&#39;,&#39;href&#39;),
    Output(&#39;no-directory-error&#39;, &#39;children&#39;)],
    [Input(&#39;load-page-check&#39;, &#39;n_intervals&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def refreshSearch(n, dir_name):
    &#39;&#39;&#39;
    The Interval component of the &#39;/load&#39; page calls this function every 3 seconds. The function checks the status of the submitted job by means
    of the log and output file created and updated by the submit_job.final.sh script, and notifies the user about the current status (&#39;To Do&#39;, &#39;Done&#39; etc.) 
    When the job is completed, a link directing to the &#39;/result&#39; page is shown. If the job doesn&#39;t exists or is in the queue,
    a notification will appear. 

    ***Args***

    + [**n**] **load-page-check** (*n_intervals*): element of the Interval component that shows the number of time it has been fired
    + [**dir_name**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **view-results** (*style*): dictionary for the style element of the link that redirects to the &#39;/result&#39; page. If the job is completed
    then the {&#39;visibility&#39;:&#39;visible&#39;} is returned, else {&#39;visibility&#39;:&#39;visible&#39;} 
    + **search-status** (*children*): html.P() that contains the status of the search phase. Can be:
        + To Do, red
        + Done, green
        + Currently ongoing, orange
        + Not Available, red
    + **generate-report-status** (*children*): html.P() that contains the status of the generate report. Can be as above
    + **post-process-status** (*children*): html.P() that contains the status of the post process phase. Can be as above
    + **view-results** (*href*): link that redirects to the &#39;/result&#39; page
    + **no-directory-error** (*children*): Alert component that notify the user that the result is not present in the server, or is in the queue
    &#39;&#39;&#39;

    if n is None:
        raise PreventUpdate    
    
    onlydir = [f for f in listdir(current_working_directory + &#39;Results&#39;) if isdir(join(current_working_directory + &#39;Results&#39;, f))]
    current_job_dir = current_working_directory + &#39;Results/&#39; +  dir_name.split(&#39;=&#39;)[-1] + &#39;/&#39;
    if dir_name.split(&#39;=&#39;)[-1] in onlydir:
        onlyfile = [f for f in listdir(current_job_dir) if isfile(join(current_job_dir, f))]
        if os.path.exists(current_job_dir + &#39;guides.txt&#39;):
            with open(current_job_dir + &#39;guides.txt&#39;) as guides:
                n_guides = len(guides.read().strip().split(&#39;\n&#39;))
        else:
            n_guides = -1
        if &#39;log.txt&#39; in onlyfile:
            with open(current_job_dir + &#39;log.txt&#39;) as log:
                all_done = 0
                
                search_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                report_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                post_process_status = html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;})
                current_log = log.read()

                if (&#39;Search-index\tDone&#39; in current_log and &#39;Search\tDone&#39; in current_log):
                    search_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done from output.txt
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;Indexing_Reference&#39; in line:
                            search_status = html.P(&#39;Indexing Reference Genome...&#39; + &#39; &#39; + &#39;Step [1/2]&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                        if &#39;Indexing_Enriched&#39; in line:
                            search_status = html.P(&#39;Indexing Enriched Genome...&#39; + &#39; &#39; + &#39;Step [2/2]&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                        if &#39;Search_output&#39; in line:
                            if &#39;both&#39; in line:
                                last_percent = line.rfind(&#39;%&#39;)
                                if last_percent &gt; 0:
                                    last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                    search_status_message = last_percent + &#39;%&#39;
                                else:
                                    search_status_message = &#39;Searching...&#39;

                                steps = &#39;Step [1/2]&#39;
                                if &#39;Search_output_ref&#39; in line:
                                    steps = &#39;Step [2/2]&#39;
                                
                            else:
                                last_percent = line.rfind(&#39;%&#39;)
                                if last_percent &gt; 0:
                                    last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                    search_status_message = last_percent + &#39;%&#39;
                                else:
                                    search_status_message = &#39;Searching...&#39;
                                steps = &#39;&#39;
                            search_status = html.P(search_status_message + &#39; &#39; + steps, style = {&#39;color&#39;:&#39;orange&#39;})

                if (&#39;Report\tDone&#39; in current_log):
                    report_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;Generate_report&#39; in line:
                            if n_guides &lt; 0:
                                report_status = html.P(&#39;Generating Report...&#39;, style = {&#39;color&#39;:&#39;orange&#39;}) 
                            else:
                                status_message = round((len(line.split(&#39;\n&#39;)) - 1) / n_guides, 2)
                                report_status = html.P(str(status_message * 100) + &#39;%&#39;, style = {&#39;color&#39;:&#39;orange&#39;})
                if (&#39;PostProcess\tDone&#39; in current_log):
                    post_process_status = html.P(&#39;Done&#39;, style = {&#39;color&#39;:&#39;green&#39;})
                    all_done = all_done + 1
                elif os.path.exists(current_job_dir + &#39;output.txt&#39;):                #Extract % of search done
                    with open(current_job_dir + &#39;output.txt&#39;, &#39;r&#39;) as output_status:
                        line = output_status.read().strip()
                        if &#39;PostProcess_output&#39; in line:
                            line = line.split(&#39;\n&#39;)
                            if line[-1] == &#39;PostProcess_output&#39;:
                                post_process_status = html.P(&#39;Processing data...&#39;, style = {&#39;color&#39;:&#39;orange&#39;})    
                            else:
                                if &#39;Annotating...&#39; in line:
                                    last_percent = line[-1].rfind(&#39;%&#39;)
                                    if last_percent &gt; 0:
                                        last_percent = line[line[:last_percent].rfind(&#39; &#39;): last_percent]
                                        status_message = last_percent + &#39;%&#39;
                                    else:
                                        status_message = &#39;Annotating...&#39;
                                else:
                                    status_message = line[-1]
                                post_process_status = html.P(status_message, style = {&#39;color&#39;:&#39;orange&#39;})
                if all_done == 3 or &#39;Job\tDone&#39; in current_log:
                    return {&#39;visibility&#39;:&#39;visible&#39;},  search_status, report_status, post_process_status ,&#39;/result?job=&#39; + dir_name.split(&#39;=&#39;)[-1], &#39;&#39;
                else:
                    return {&#39;visibility&#39;:&#39;hidden&#39;},  search_status, report_status, post_process_status,&#39;&#39;, &#39;&#39;
        elif &#39;queue.txt&#39; in onlyfile:
            return {&#39;visibility&#39;:&#39;hidden&#39;},  html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;To do&#39;, style = {&#39;color&#39;:&#39;red&#39;}),&#39;&#39;, dbc.Alert(&#34;Job submitted. Current status: in queue&#34;, color = &#34;info&#34;)
    return {&#39;visibility&#39;:&#39;hidden&#39;},  html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}), html.P(&#39;Not available&#39;, style = {&#39;color&#39;:&#39;red&#39;}) ,&#39;&#39;, dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.removeJobIDandFilter">
              <code class="name flex">
                <span>def <span class="ident">removeJobIDandFilter</span></span
                >(<span
                  >n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, nPrev, nNext,
                  filter_q, jID0, jID1, jID2, jID3, jID4, jID5, jID6, jID7,
                  jID8, jID9, n, search, current_page)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;div-history-table&#39;, &#39;children&#39;),
    Output(&#39;div-current-page-history&#39;, &#39;children&#39;)],
    [Input(&#39;button-delete-history-0&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-1&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-2&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-3&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-4&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-5&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-6&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-7&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-8&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;button-delete-history-9&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;prev-page-history&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;next-page-history&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;div-history-filter-query&#39;, &#39;children&#39;)],
    [State(&#39;button-delete-history-0&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-1&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-2&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-3&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-4&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-5&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-6&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-7&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-8&#39;, &#39;data-jobid&#39;),
    State(&#39;button-delete-history-9&#39;, &#39;data-jobid&#39;),
    State(&#39;button-filter-history&#39;, &#39;n_clicks_timestamp&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-current-page-history&#39;, &#39;children&#39;)
    ]
)
def removeJobIDandFilter(n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, nPrev, nNext, filter_q, jID0, jID1, jID2, jID3, jID4, jID5, jID6, jID7, jID8, jID9, n, search, current_page):
    #Get last pressed button
    if not n0:
        n0 = 0
    if not n1:
        n1 = 0
    if not n2:
        n2 = 0
    if not n3:
        n3 = 0
    if not n4:
        n4 = 0
    if not n5:
        n5 = 0
    if not n6:
        n6 = 0
    if not n7:
        n7 = 0
    if not n8:
        n8 = 0
    if not n9:
        n9 = 0
    if not nPrev:
        nPrev = 0
    if not nNext:
        nNext = 0
    if not n:
        n = 0
    btn_group = []
    btn_group.append(n0)
    btn_group.append(n1)
    btn_group.append(n2)
    btn_group.append(n3)
    btn_group.append(n4)
    btn_group.append(n5)
    btn_group.append(n6)
    btn_group.append(n7)
    btn_group.append(n8)
    btn_group.append(n9)
    btn_group.append(nPrev)
    btn_group.append(nNext)
    btn_group.append(n)
    
    genome_filter = filter_q.split(&#39;,&#39;)[0]
    pam_filter = filter_q.split(&#39;,&#39;)[1]
    if genome_filter == &#39;None&#39;:
        genome_filter = None
    if pam_filter == &#39;None&#39;:
        pam_filter = None
    current_page = current_page.split(&#39;/&#39;)[0]
    current_page = int(current_page)
    results = get_results()
    selectedID = &#39;&#39;

    if max(btn_group) == 0:
        selectedID = &#39;&#39;
    elif max(btn_group) == n0:
        selectedID = jID0
    elif max(btn_group) == n1:
        selectedID = jID1
    elif max(btn_group) == n2:
        selectedID = jID2
    elif max(btn_group) == n3:
        selectedID = jID3
    elif max(btn_group) == n4:
        selectedID = jID4
    elif max(btn_group) == n5:
        selectedID = jID5
    elif max(btn_group) == n6:
        selectedID = jID6
    elif max(btn_group) == n7:
        selectedID = jID7
    elif max(btn_group) == n8:
        selectedID = jID8
    elif max(btn_group) == n9:
        selectedID = jID9
    elif max(btn_group) == n:    #Filter Button selected, return the first page of the filtered table
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        return generate_table_results(results,1), &#39;1/&#39; + str(max_page)
    elif max(btn_group) == nNext:   #Next Button of the table
        current_page = current_page + 1
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        if ((current_page - 1) * 10) &gt; len(results): 
            current_page = current_page -1
            if current_page &lt; 1:
                current_page = 1
        return generate_table_results(results,current_page), str(current_page) + &#39;/&#39; + str(max_page)
    elif max(btn_group) == nPrev:   #Go to previous page
        current_page = current_page - 1
        if current_page &lt; 1:
            current_page = 1
        results, max_page = supportFilterHistory(results, genome_filter, pam_filter)
        return generate_table_results(results,current_page), str(current_page) + &#39;/&#39; + str(max_page)

    if selectedID == &#39;&#39;:
        raise PreventUpdate
    result_removed = Gmsg.deleteResultConfirm(selectedID)
    if result_removed:      #If the result was removed, update the table
        results, max_page = supportFilterHistory(get_results(), genome_filter, pam_filter)
        return generate_table_results(results,1), &#39;1/&#39; + str(max_page)
    else:
        raise PreventUpdate
    results, max_page = supportFilterHistory(get_results(), genome_filter, pam_filter)
    return generate_table_results(results,1), &#39;1/&#39; + str(max_page)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.resetTab">
              <code class="name flex">
                <span>def <span class="ident">resetTab</span></span
                >(<span>current_tab, is_in)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Manages the fading of the Dropdown for the guide length when
                  the tab 'Sequence' is active.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>current_tab</strong>]
                    <strong>tabs</strong> (<em>active_tab</em>): string of the
                    ID of the current active tab
                  </li>
                  <li>
                    [<strong>is_in</strong>]
                    <strong>fade-len-guide</strong> (<em>is_in</em>): True if
                    the Dropdown guide length element is displayed, False
                    otherwise
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>fade-len-guide</strong> (<em>is_in</em>): True in
                    order to show the Dropdown guide length element, False to
                    hide it
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;fade-len-guide&#39;, &#39;is_in&#39;),
    [Input(&#39;tabs&#39;, &#39;active_tab&#39;)],
    [State(&#39;fade-len-guide&#39;, &#39;is_in&#39;)]
)
def resetTab(current_tab, is_in):
    &#39;&#39;&#39;
    Manages the fading of the Dropdown for the guide length when the tab &#39;Sequence&#39; is active.

    ***Args***

    + [**current_tab**] **tabs** (*active_tab*): string of the ID of the current active tab
    + [**is_in**] **fade-len-guide** (*is_in*): True if the Dropdown guide length element is displayed, False otherwise

    ***Returns***

    + **fade-len-guide** (*is_in*): True in order to show the Dropdown guide length element, False to hide it
    &#39;&#39;&#39;
    if current_tab is None:
        raise PreventUpdate

    if current_tab == &#39;guide-tab&#39;:
        return False
    return True</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.resultPage">
              <code class="name flex">
                <span>def <span class="ident">resultPage</span></span
                >(<span>job_id)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  The function creates the layout for the Result Page, with the
                  general summary table at the top, the popup Population
                  histogram section, the Tabs for the three different summaries
                  and report (Guide, Sample, Position, Graphical Sumamary).
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>job_id</strong>: string containing the jobbID of the
                    current job
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>result_page</strong>: list of Dash Components for
                    the layout of the page
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def resultPage(job_id):
    &#39;&#39;&#39;
    The function creates the layout for the Result Page, with the general summary table at the top, the popup Population histogram section, the 
    Tabs for the three different summaries and report (Guide, Sample, Position, Graphical Sumamary).
    
    ***Args***

    + **job_id**: string containing the jobbID of the current job

    ***Returns***

    + **result_page**: list of Dash Components for the layout of the page
    &#39;&#39;&#39;
    value = job_id
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    if (not isdir(job_directory)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))

    #Load informations from the Params file
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
        bulge_dna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;DNA&#39; in s)).split(&#39;\t&#39;)[-1]
        bulge_rna = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;RNA&#39; in s)).split(&#39;\t&#39;)[-1]
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        max_bulges = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1]

    genome_name = genome_type_f
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
        genome_name = genome_name.split(&#39;_&#39;)[0] + &#39; Variants&#39;
    else:
        genome_name = genome_name.split(&#39;_&#39;)[0] + &#39; Reference&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    mms = int(mms[0])    
    
    #load acfd for each guide 
    with open(current_working_directory + &#39;Results/&#39; + value + &#39;/acfd.txt&#39;) as a:
        all_scores = a.read().strip().split(&#39;\n&#39;)
    
    list_error_guides = []
    if os.path.exists(current_working_directory + &#39;Results/&#39; + value + &#39;/guides_error.txt&#39;):
        with open(current_working_directory + &#39;Results/&#39; + value + &#39;/guides_error.txt&#39;) as error_g:
            for e_g in error_g:
                list_error_guides.append(e_g.strip())

    #Columns for the main table
    col_targetfor = &#39;(&#39;
    for i in range(1, mms + int(max_bulges)):
        col_targetfor = col_targetfor + str(i) + &#39;-&#39;
    col_targetfor = col_targetfor + str(mms + int(max_bulges))
    col_targetfor = col_targetfor + &#39; Mismatches + Bulges)&#39;
    
    columns_profile_table = [ 
        {&#39;name&#39;:[&#39;&#39;, &#39;Guide&#39;], &#39;id&#39;:&#39;Guide&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;CFD&#39;], &#39;id&#39;:&#39;CFD&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Doench 2016&#39;], &#39;id&#39;:&#39;Doench 2016&#39;, &#39;type&#39;:&#39;text&#39;},    #Doench, only for REF or VAR
        {&#39;name&#39;:[&#39;Doench 2016&#39;, &#39;Reference&#39;], &#39;id&#39;:&#39;Reference&#39;, &#39;type&#39;:&#39;text&#39;},        #REF Doench, only for Both
        {&#39;name&#39;:[&#39;Doench 2016&#39;, &#39;Enriched&#39;], &#39;id&#39;:&#39;Enriched&#39;, &#39;type&#39;:&#39;text&#39;},          #VAR Doench, only for Both
        {&#39;name&#39;:[&#39;&#39;, &#39;On-Targets Reference&#39;], &#39;id&#39;:&#39;On-Targets Reference&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;On-Targets Enriched&#39;], &#39;id&#39;:&#39;On-Targets Enriched&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39;], &#39;id&#39;:&#39;Samples in Class 0 - 0+ - 1 - 1+&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;&#39;, &#39;Genome&#39;], &#39;id&#39;:&#39;Genome&#39;, &#39;type&#39;:&#39;text&#39;},
        {&#39;name&#39;:[&#39;Off-targets for Mismatch (MM) + Bulge (B) Value&#39;, &#39;Total&#39;], &#39;id&#39;:&#39;Total&#39;, &#39;type&#39;:&#39;text&#39;}
        ]    #Column of headers . Remove the entries accordingly when checking type of genome
    
    for i in range (1, mms + int(max_bulges) + 1):
        columns_profile_table.append({&#39;name&#39;:[&#39;Off-targets for Mismatch (MM) + Bulge (B) Value&#39;, str(i) + &#39; MM + B&#39;], &#39;id&#39;: str(i) + &#39; MM + B&#39;, &#39;type&#39;:&#39;text&#39;})
    remove_indices = set()
    
    if &#39;NO SCORES&#39; in all_scores:
        # remove_indices.update([1,2,3,4])    #Remove CFD and Doench header
        remove_indices.update(&#39;CFD&#39;, &#39;Doench 2016&#39;, &#39;Reference&#39;, &#39;Enriched&#39;)
    
    if genome_type == &#39;ref&#39;:
        # remove_indices.update([3,4,6,7])
        remove_indices.update([&#39;Reference&#39;, &#39;Enriched&#39;, &#39;On-Targets Enriched&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39; ])
    elif genome_type == &#39;both&#39;:
        # remove_indices.update([6])
        remove_indices.update([&#39;Doench 2016&#39;,&#39;On-Targets Enriched&#39;])
    else:
        # remove_indices.update([3,4,5,7])
        remove_indices.update([&#39;Reference&#39;, &#39;Enriched&#39;, &#39;On-Targets Reference&#39;, &#39;Samples in Class 0 - 0+ - 1 - 1+&#39;])
    
    #Remove headers not used in selected search result
    columns_profile_table = [i for j, i in enumerate(columns_profile_table) if columns_profile_table[j][&#39;id&#39;] not in remove_indices]      
    
    final_list = []    
    if list_error_guides:   #If some guides were not processed due to too many targets
        final_list.append(
            dbc.Alert(
                [
                    &#39;Warning: Some guides have too many targets! &#39;,
                    html.A(&#34;Click here&#34;, href= URL + &#34;/data/&#34; + job_id + &#39;/guides_error.txt&#39;, className=&#34;alert-link&#34;),
                    &#39; to view them&#39;
                ], color=&#39;warning&#39;)
        )
    final_list.append(
        html.H3(&#39;Result Summary - &#39; + genome_name + &#39; - Mismatches &#39; + str(mms) + &#39; - DNA &#39; + bulge_dna + &#39; - RNA &#39; + bulge_rna)
    )
   
    add_to_description = html.P(
        &#39;General summary for the given guides. For each guide, the number of Off-Targets found for each Mismatch + Bulge value is shown.&#39;
    )
    if genome_type == &#39;both&#39;:
        add_to_description = html.P(
            [
                &#39;General summary for the given guides. For each guide, the number of &#39;,  
                html.Span(
                    &#34;Samples for each Class is provided&#34;,
                    id=&#34;tooltip-sample-class&#34;,
                    style={&#34;textDecoration&#34;: &#34;underline&#34;, &#34;cursor&#34;: &#34;pointer&#34;}
                ),
                &#39;, along with the number of Off-Targets found for each Mismatch + Bulge value, for both Reference and Enriched Genomes.&#39;,
                dbc.Tooltip(
                    [
                        html.Div([html.P([html.B(&#39;Class 0:&#39;), &#39; Samples that does not have any On-Targets&#39;]),
                        html.P([html.B(&#39;Class 0+:&#39;), &#39; Samples that have a subset of the Reference Genome On-Targets&#39;]),
                        html.P([html.B(&#39;Class 1:&#39;), &#39; Samples that have the same On-Targets as the Reference Genome&#39;]),
                        html.P([html.B(&#39;Class 1+:&#39;), &#39; Samples that creates at least a new On-Target, that is not present in the Reference Genome&#39;])], 
                        style = {&#39;display&#39;:&#39;inline-block&#39;})
                    ],
                    target=&#34;tooltip-sample-class&#34;, style = {&#39;font-size&#39;: &#39;12px&#39;}
                )
            ]
        )
    final_list.append(add_to_description)
    final_list.append(
        html.Div(
            dash_table.DataTable(
                id = &#39;general-profile-table&#39;,
                columns = columns_profile_table,
                merge_duplicate_headers=True,
                #fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                selected_cells = [{&#39;row&#39;:0, &#39;column&#39;:0}],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                page_current= 0,
                page_size= PAGE_SIZE,
                page_action=&#39;custom&#39;,
                #virtualization = True,
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,

                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                style_table={
                    &#39;max-height&#39;: &#39;260px&#39;,
                    &#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data={
                    &#39;whiteSpace&#39;: &#39;pre&#39;,
                    &#39;height&#39;: &#39;auto&#39;,
                    &#39;font-size&#39;:&#39;1.30rem&#39;
                },
                style_data_conditional = [
                    {
                        &#39;if&#39;: {
                                &#39;column_id&#39; :&#39;Genome&#39;
                            },
                            &#39;font-weight&#39;:&#39;bold&#39;,
                            &#39;textAlign&#39;: &#39;center&#39;
                            
                    }
                ]
            )
            ,id = &#39;div-general-profile-table&#39;)
    )

    final_list.append(html.Br())

    if genome_type == &#39;ref&#39;:
        final_list.append(
        dcc.Tabs(id=&#34;tabs-reports&#34;, value=&#39;tab-summary-by-guide&#39;, children=[
            dcc.Tab(label=&#39;Summary by Guide&#39;, value=&#39;tab-summary-by-guide&#39;),
            dcc.Tab(label=&#39;Summary by Position&#39;, value=&#39;tab-summary-by-position&#39;),
            dcc.Tab(label=&#39;Graphical Summary&#39;, value=&#39;tab-summary-graphical&#39;),
        ])
    )
    else:
        #Barplot for population distributions
        final_list.append(
            html.Div(
                [
                    dbc.Row(
                        [
                            dbc.Col(html.Button(&#34;Show/Hide Target Distribution in SuperPopulations&#34;, id=&#34;btn-collapse-populations&#34;)),
                        ]
                    ),
                    dbc.Collapse(
                        dbc.Card(dbc.CardBody(
                            html.Div(id = &#39;content-collapse-population&#39;)
                        )),
                        id=&#34;collapse-populations&#34;,
                    ),
                ]
            )
        )
        final_list.append(html.Br())
        final_list.append(
            dcc.Tabs(id=&#34;tabs-reports&#34;, value=&#39;tab-summary-by-guide&#39;, children=[
                dcc.Tab(label=&#39;Summary by Guide&#39;, value=&#39;tab-summary-by-guide&#39;),
                dcc.Tab(label=&#39;Summary by Sample&#39;, value=&#39;tab-summary-by-sample&#39;),
                dcc.Tab(label=&#39;Summary by Position&#39;, value=&#39;tab-summary-by-position&#39;),
                dcc.Tab(label=&#39;Graphical Summary&#39;, value=&#39;tab-summary-graphical&#39;),
            ])
        )
    final_list.append(html.Div(id = &#39;div-tab-content&#39;))

    final_list.append(html.Div(genome_type, style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-genome-type&#39;))
    result_page = html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})
    return result_page</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.samplePage">
              <code class="name flex">
                <span>def <span class="ident">samplePage</span></span
                >(<span>job_id, hash)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def samplePage(job_id, hash):
    guide = hash[:hash.find(&#39;-Sample-&#39;)]
    sample = hash[hash.rfind(&#39;-&#39;) + 1:]
    if (not isdir(current_working_directory + &#39;Results/&#39; + job_id)):
        return html.Div(dbc.Alert(&#34;The selected result does not exist&#34;, color = &#34;danger&#34;))

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    final_list = []
    final_list.append(
        #html.P(&#39;List of Targets found for the selected Sample - &#39; + sample + &#39; - and guide - &#39; + guide + &#39; -&#39;)
        html.H3(&#39;Selected Sample: &#39; + sample)
    )
    final_list.append(
        html.P(
            [
                &#39;List of Targets found for the selected sample.&#39;, #&#39;The rows highlighted in red indicates that the target was found only in the genome with variants.&#39;,
                html.Div(
                    [   
                        html.P(&#39;Generating download link, Please wait...&#39;, id = &#39;download-link-sumbysample&#39;), 
                        dcc.Interval(interval = 5*1000, id = &#39;interval-sumbysample&#39;)
                    ]

                )
            ]
        )
    )
        
    file_to_grep = &#39;.samples.annotation.txt&#39;
    sample_grep_result = current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + sample + &#39;.&#39; + guide + &#39;.txt&#39;
    put_header = &#39;head -1 &#39; + current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + file_to_grep + &#39; &gt; &#39; + sample_grep_result + &#39; ; &#39;
    final_list.append(
        html.Div(job_id + &#39;.&#39; + sample + &#39;.&#39; + guide,style = {&#39;display&#39;:&#39;none&#39;}, id = &#39;div-info-sumbysample-targets&#39;)
    )
    # print(&#39;qui sample before grep&#39;)
    # print(&#39;esiste sample?&#39;, str(os.path.exists(sample_grep_result)))

    if not os.path.exists(sample_grep_result):    #Example    job_id.HG001.guide.txt #NOTE HEADER NON SALVATO
        subprocess.call([put_header + &#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; | LC_ALL=C grep -F &#39; + sample + &#39; &gt; &#39; + sample_grep_result], shell = True)
        subprocess.Popen([&#39;zip &#39; + sample_grep_result.replace(&#39;.txt&#39;,&#39;.zip&#39;) + &#39; &#39; + sample_grep_result],shell = True)
    
    cols = [{&#34;name&#34;: i, &#34;id&#34;: i, &#39;type&#39;:t, &#39;hideable&#39;:True} for i,t in zip(COL_BOTH, COL_BOTH_TYPE)]
    
    final_list.append(          
        html.Div( 
            dash_table.DataTable(
                id=&#39;table-sample-target&#39;, 
                columns=cols, 
                #data = df.to_dict(&#39;records&#39;),
                virtualization = True,
                fixed_rows={ &#39;headers&#39;: True, &#39;data&#39;: 0 },
                #fixed_columns = {&#39;headers&#39;: True, &#39;data&#39;:1},
                style_cell={&#39;width&#39;: &#39;150px&#39;},
                page_current=0,
                page_size=PAGE_SIZE,
                page_action=&#39;custom&#39;,
                sort_action=&#39;custom&#39;,
                sort_mode=&#39;multi&#39;,
                sort_by=[],
                filter_action=&#39;custom&#39;,
                filter_query=&#39;&#39;,
                style_table={
                    &#39;max-height&#39;: &#39;600px&#39;
                    #&#39;overflowY&#39;: &#39;scroll&#39;,
                },
                style_data_conditional=[
                    # {
                    #     &#39;if&#39;: {
                    #             &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;, 
                    #             #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                    #             #&#39;column_id&#39; :&#39;{Total}&#39;
                    #         },
                    #         #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                    #         &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                    #     },
                    {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        }
                ],
                css= [{ &#39;selector&#39;: &#39;td.cell--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.cell--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                # css= [{ &#39;selector&#39;: &#39;td.row--selected, td.focused&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39; }, { &#39;selector&#39;: &#39;td.row--selected *, td.focused *&#39;, &#39;rule&#39;: &#39;background-color: rgba(0, 0, 255,0.15) !important;&#39;}],
                
            ),
            id = &#39;div-result-table&#39;,
        )
    )
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.selectSameLenGuides">
              <code class="name flex">
                <span>def <span class="ident">selectSameLenGuides</span></span
                >(<span>list_guides)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  If the user provide guides with different lengths, the
                  function select the first guide, calculate its length, and
                  discards all the guides with different lengths.
                </p>
                <p>
                  <strong><em>Args</em></strong
                  >:
                </p>
                <ul>
                  <li>
                    <strong>list_guides</strong>: list of the input guides
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>same_len_guides</strong>: list of guides with the
                    same length
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def selectSameLenGuides(list_guides):
    &#39;&#39;&#39;
    If the user provide guides with different lengths, the function select the first guide, calculate its length, and discards all the guides with
    different lengths.

    ***Args***:

    + **list_guides**: list of the input guides

    ***Returns***

    + **same_len_guides**: list of guides with the same length
    &#39;&#39;&#39;
    selected_length = len(list_guides.split(&#39;\n&#39;)[0])
    same_len_guides_list = []
    for guide in list_guides.split(&#39;\n&#39;):
        if len(guide) == selected_length:
            same_len_guides_list.append(guide)
    same_len_guides = &#39;\n&#39;.join(same_len_guides_list).strip()
    return same_len_guides</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.split_filter_part">
              <code class="name flex">
                <span>def <span class="ident">split_filter_part</span></span
                >(<span>filter_part)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Split the input filter, used for Dash DataTables. See
                  <a href="https://dash.plotly.com/datatable/filtering"
                    >https://dash.plotly.com/datatable/filtering</a
                  >
                </p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def split_filter_part(filter_part):
    &#39;&#39;&#39;
    Split the input filter, used for Dash DataTables. See https://dash.plotly.com/datatable/filtering
    &#39;&#39;&#39;
    for operator_type in operators:
        for operator in operator_type:
            if operator in filter_part:
                name_part, value_part = filter_part.split(operator, 1)
                name = name_part[name_part.find(&#39;{&#39;) + 1: name_part.rfind(&#39;}&#39;)]

                value_part = value_part.strip()
                v0 = value_part[0]
                if (v0 == value_part[-1] and v0 in (&#34;&#39;&#34;, &#39;&#34;&#39;, &#39;`&#39;)):
                    value = value_part[1: -1].replace(&#39;\\&#39; + v0, v0)
                else:
                    try:
                        value = float(value_part)
                    except ValueError:
                        value = value_part

                # word operators need spaces after them in the filter string,
                # but we don&#39;t want these later
                return name, operator_type[0].strip(), value

    return [None] * 3</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.startAddNewGenome">
              <code class="name flex">
                <span>def <span class="ident">startAddNewGenome</span></span
                >(<span>n)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-targetoutput&#39;,&#39;children&#39;),
    [Input(&#39;button-add-new-genome&#39;, &#39;n_clicks&#39;)]
)
def startAddNewGenome(n):
    if n is None:
        raise PreventUpdate
    #TODO: prende gli state dei valori selezionati dall&#39;utente e controlla se sono stati tutti selezionati, altrimenti fa comparire un 
    #avviso che manca qualcosa (cfr. funzione checkInput, ma basta solo avere l&#39;elenco dei campi da compilare)
    #...
    #...

    #input corretti
    #Faccio un subprocess.Popen facendo partire lo script per generare il nuovo genoma
    #Lo script.sh crea un file nella cartella Genomes chiamato &#39;status_creation_nomegenoma.txt&#39; dove nomegenoma Ã¨ ref o enr in base alla
    #selezione dell&#39;utente
    #In questo script faccio echo dei vari step in cui sono in questo momento con l&#39;analisi, in modo poi da leggere questo file e con un interval
    #dire all&#39;utente a che punto siamo
    print(&#39;Button clicked&#39;)
    subprocess.Popen([app_main_directory + &#39;PostProcess/aggiunta_genoma_test_script.sh&#39;, current_working_directory])
    return &#39;&#39;</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.suggestComparison">
              <code class="name flex">
                <span>def <span class="ident">suggestComparison</span></span
                >(<span>value)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update to Checked the Option 'Compare your results with the
                  corresponding reference genome' if an Enriched Genome is
                  selected ('+' is in the name of the genome)
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>value</strong>]
                    <strong>available-genome</strong> (<em>value</em>): the name
                    of the genome selected by the user in the Dropdown
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>checkbox-ref-comp</strong> [<em>checked</em>]: True
                    if an Enriched genome is selected
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;checkbox-ref-comp&#39;, &#39;checked&#39;),
    [Input(&#39;available-genome&#39;, &#39;value&#39;)]
)
def suggestComparison(value):
    &#39;&#39;&#39;
    Update to Checked the Option &#39;Compare your results with the corresponding reference genome&#39; if an Enriched Genome is selected (&#39;+&#39; is in the
    name of the genome)

    ***Args***

    + [**value**] **available-genome** (*value*): the name of the genome selected by the user in the Dropdown

    ***Returns***

    + **checkbox-ref-comp** [*checked*]: True if an Enriched genome is selected
    &#39;&#39;&#39;
    if value is None:
        raise PreventUpdate
    if &#39;+&#39; in value:
        return True
    raise PreventUpdate </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.supportFilterHistory">
              <code class="name flex">
                <span>def <span class="ident">supportFilterHistory</span></span
                >(<span>result_df, genome_f, pam_f)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def supportFilterHistory(result_df, genome_f, pam_f):
    if genome_f is not None:
        result_df.drop(result_df[(result_df[&#39;Genome&#39;] != genome_f)].index, inplace = True)
    if pam_f is not None:
        keep_values = []
        for index, row in result_df.iterrows():
            if row.PAM not in pam_f:
                keep_values.append(index)
        result_df.drop(labels= keep_values, inplace = True)

    max_page = len(result_df.index)
    max_page = math.floor(max_page / 10) + 1
    return result_df, max_page</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.test_page">
              <code class="name flex">
                <span>def <span class="ident">test_page</span></span
                >(<span>)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">def test_page():
    final_list = []
    final_list.append(html.Div(id=&#39;test-div-for-button&#39;))
    final_list.append(
        html.H3(&#39;Genomes&#39;)
    )
    final_list.append(
        html.P(&#39;Select one of the two available Tabs and fill in the field to add a new Genome or to update and existing dictionary.&#39;)
    )

    #Check if an already processing add new genome is currently active. If yes, set the button to be disabled
    already_processing = False
    status_label = &#39;Status: No Job Submitted&#39;
    status_value = 0
    style_disabled = {}
    if isfile(current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39; ):
        already_processing = True
        style_disabled = {&#39;background-color&#39;:&#39;darkgrey&#39;}
        with open(current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39;) as info_status:
            status_general = next(info_status).strip().split(&#39; &#39;) #Get current step number [0] and step name [1] on accessing page for first time
            status_label = &#39;Status: &#39; + status_general[1]
            status_value = int(status_general[0]) * 25

    new_genome_content = html.Div(
        [
            html.Br(),
            html.P(&#39;1) Select a Reference Genome&#39;),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Reference Genome Directory&#39;, id = &#39;button-select-refgenome&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-referencegenome&#39;))
                                ]
                            )  
                        ]
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select PAM File&#39;, id = &#39;button-select-pam&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-pamfile&#39;))
                                ]
                            )  
                        ]
                    ),
                    
                ]
            ),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Annotation File&#39;, id = &#39;button-select-annotation&#39;)), 
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-annotationfile&#39;))
                                ]
                            ),
                            
                        ]
                    ),
                    dbc.Col(
                            dbc.Row(
                                [
                                    dbc.Col(dcc.Input(placeholder = &#39;Select number of max Bulges&#39;, type = &#39;number&#39;, min = 0, id = &#39;input-max-bulges&#39;))
                                ]
                            )
                        )

                ]
            ),
            html.Hr(),
            html.P(&#39;2) (Optional) Enrich the previously selected Reference Genome with samples informations&#39;),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select VCFs Directory&#39;, id = &#39;button-select-vcf&#39;)),
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-vcf&#39;))
                                ]
                            )  
                        ]
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                [
                                    dbc.Col(html.Button(&#39;Select Samples ID File&#39;, id = &#39;button-select-sampleID&#39;)), 
                                    dbc.Col(html.P(&#39;Selected: None&#39;, id = &#39;selected-sampleIDfile&#39;))
                                ]
                            ),
                            
                        ]
                    )
                ]
            ),
            html.Br(),
            dbc.Row(
                [
                    dbc.Col(
                        dbc.Row(
                            [
                                dbc.Col(html.P(&#39;Enriched Genome Name&#39;)),
                                dbc.Col(dcc.Input(placeholder = &#39;Example: 1000genomeproject&#39;, id = &#39;input-enriched-name&#39;))
                            ]
                        )
                    )
                ]
            ),
            html.Hr(),
            dbc.Row(
                [
                    dbc.Col(
                        html.Button(&#39;Start add new genome&#39;, id = &#39;button-add-new-genome&#39;, disabled = already_processing, style = style_disabled)
                    ),
                    dbc.Col(
                        [
                            dbc.Row(
                                dbc.Col(
                                    html.P(status_label, id = &#39;status-add-new-genome&#39;)
                                )
                            ),
                            dbc.Row(
                                dbc.Col(
                                    html.Div(
                                        [
                                            dbc.Progress(value = status_value, id = &#39;progress-add-new-genome&#39;),
                                            dcc.Interval(interval = 30*1000,id=&#39;interval-add-new-genome&#39;)
                                        ]
                                    )
                                )
                            )
                        ]
                    )
                ]
            )
        ]
    )

    update_dictionary_content = html.Div() #TODO finire con layout simile a quello per aggiungere nuovo genoma

    final_list.append(
        dbc.Tabs(
            [
                dbc.Tab(new_genome_content, label=&#39;Add New Genome&#39;, tab_id= &#39;add-genome-tab&#39;),
                dbc.Tab(update_dictionary_content, label=&#39;Update Dictionary&#39;, tab_id = &#39;update-dictionary&#39;)
            ],
            active_tab=&#39;add-genome-tab&#39;,
            id = &#39;tabs-new-genome-or-dictionary&#39;
        )
    )

    final_list.append(html.Div(id = &#39;div-targetoutput&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
    return html.Div(final_list, style = {&#39;margin&#39;:&#39;1%&#39;})</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.toggleCollapseDistributionPopulations">
              <code class="name flex">
                <span
                  >def
                  <span class="ident"
                    >toggleCollapseDistributionPopulations</span
                  ></span
                >(<span>n, is_open)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Open/Close the section containing the Population Distributions
                  barplots.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>btn-collapse-populations</strong>
                    (<em>n_clicks</em>): int for the number of times the button
                    was clicked
                  </li>
                  <li>
                    [<strong>is_open</strong>]
                    <strong>collapse-populations</strong> (<em>is_open</em>):
                    bool for the status of the component (True: is open, False:
                    is closed)
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>collapse-populations</strong> (<em>is_open</em>):
                    True to show, False to hide
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#34;collapse-populations&#34;, &#34;is_open&#34;),
    [Input(&#34;btn-collapse-populations&#34;, &#34;n_clicks&#34;)],
    [State(&#34;collapse-populations&#34;, &#34;is_open&#34;)],
)
def toggleCollapseDistributionPopulations(n, is_open):
    &#39;&#39;&#39;
    Open/Close the section containing the Population Distributions barplots.

    ***Args***

    + [**n**] **btn-collapse-populations** (*n_clicks*): int for the number of times the button was clicked
    + [**is_open**] **collapse-populations** (*is_open*): bool for the status of the component (True: is open, False: is closed)

    ***Returns***

    + **collapse-populations** (*is_open*): True to show, False to hide
    &#39;&#39;&#39;
    if n:
        return not is_open
    return is_open</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.toggle_fade">
              <code class="name flex">
                <span>def <span class="ident">toggle_fade</span></span
                >(<span>selected_options, is_in)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Manages the fading of the InputBox for the email when the
                  option 'Notify me by email' is selected/deselected.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>selected_options</strong>]
                    <strong>checklist-advanced</strong> (<em>value</em>): list
                    of IDs of the options checked
                  </li>
                  <li>
                    [<strong>is_in</strong>]
                    <strong>fade</strong> (<em>is_in</em>): True if the Input
                    email element is displayed, False otherwise
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>fade</strong> (<em>is_in</em>): True in order to
                    show the Input email element, False to hide it
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#34;fade&#34;, &#34;is_in&#34;),
    [Input(&#34;checklist-advanced&#34;, &#34;value&#34;)],
    [State(&#34;fade&#34;, &#34;is_in&#34;)],
)
def toggle_fade(selected_options, is_in):
    &#39;&#39;&#39;
    Manages the fading of the InputBox for the email when the option &#39;Notify me by email&#39; is selected/deselected.

    ***Args***

    + [**selected_options**] **checklist-advanced** (*value*): list of IDs of the options checked
    + [**is_in**] **fade** (*is_in*): True if the Input email element is displayed, False otherwise

    ***Returns***

    + **fade** (*is_in*): True in order to show the Input email element, False to hide it
    &#39;&#39;&#39;
    if  selected_options is None:
        return False
    if &#39;email&#39; in selected_options:
        return True
    return False</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateContentTab">
              <code class="name flex">
                <span>def <span class="ident">updateContentTab</span></span
                >(<span>value, sel_cel, all_guides, search, genome_type)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Load the layout based on the selected Tab in the '/result'
                  page
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>value</strong>]
                    <strong>tabs-reports</strong> (<em>value</em>): string
                    representing the ID of the active Tab
                  </li>
                  <li>
                    [<strong>sel_cel</strong>]
                    <strong>general-profile-table</strong>
                    (<em>selected_cells</em>): list contaning the selected row
                    of the main guide table
                  </li>
                  <li>
                    [<strong>all_guides</strong>]
                    <strong>general-profile-table</strong> (<em>data</em>): list
                    of all the rows that are currenty displayed in the main
                    guide table
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                  <li>
                    [<strong>genome_type</strong>]
                    <strong>div-genome-type</strong> (<em>children</em>): string
                    containing the type of the search ('ref', 'var' or 'both')
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-tab-content</strong> (<em>children</em>): return
                    the layout based on the selected Tab:
                    <ul>
                      <li>
                        'tab-summary-by-guide': show the general table of the
                        targets divided by Bulge and Mismatch values
                      </li>
                      <li>
                        'tab-summary-by-sample': show the general table of the
                        targets divided by sample
                      </li>
                      <li>
                        'tab-summary-by-position': show the general table of the
                        targets divided by chromosome and position
                      </li>
                      <li>
                        'tab-summary-graphical': show the graphical report. A
                        total of 10 Buttons, one for each mms value, are
                        created, but only some of them are set to be visible
                        (the number of mms selected by the user)
                      </li>
                    </ul>
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-tab-content&#39;, &#39;children&#39;),
    [Input(&#39;tabs-reports&#39;, &#39;value&#39;),
    Input(&#39;general-profile-table&#39;,&#39;selected_cells&#39;)],
    [State(&#39;general-profile-table&#39;, &#39;data&#39;),
    State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;div-genome-type&#39;, &#39;children&#39;)]
)
def updateContentTab(value, sel_cel, all_guides, search, genome_type):
    &#39;&#39;&#39;
    Load the layout based on the selected Tab in the &#39;/result&#39; page

    ***Args***

    + [**value**] **tabs-reports** (*value*): string representing the ID of the active Tab
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**genome_type**] **div-genome-type** (*children*): string containing the type of the search (&#39;ref&#39;, &#39;var&#39; or &#39;both&#39;)

    ***Returns***

    + **div-tab-content** (*children*): return the layout based on the selected Tab:
        + &#39;tab-summary-by-guide&#39;: show the general table of the targets divided by Bulge and Mismatch values
        + &#39;tab-summary-by-sample&#39;: show the general table of the targets divided by sample
        + &#39;tab-summary-by-position&#39;: show the general table of the targets divided by chromosome and position
        + &#39;tab-summary-graphical&#39;: show the graphical report. A total of 10 Buttons, one for each mms value, are created, but only some of them
        are set to be visible (the number of mms selected by the user)
    &#39;&#39;&#39;

    if value is None or sel_cel is None or not sel_cel or not all_guides:
        raise PreventUpdate
    
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;

    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        mms = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1]
        genome_selected = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        max_bulges = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1]

    fl = []
    fl.append(html.Br())
    fl.append(html.H5(&#39;Focus on: &#39; + guide))

    if value == &#39;tab-summary-by-guide&#39;: #BUG se cambio guida selezionata due volte mi cambia il mms mettendo a 0, provare con un div nascosto
        #Show Summary by Guide table
        fl.append(
            html.P(
                [&#39;Summary table counting the number of targets found in the Enriched Genome for each combination of Bulge Type, Bulge Size and Mismatch. Select \&#39;Show Targets\&#39; to view the corresponding list of targets. &#39;, 
                # html.A(&#39;Click here&#39;, href = URL + &#39;/data/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.zip&#39; ,target = &#39;_blank&#39;, id = &#39;download-full-list&#39; ), &#39; to download the full list of targets.&#39;
                ]
                )
        )
        fl.append(
            html.Div(
                html.Button(html.A(&#39;Download Full list of targets&#39;, href = URL + &#39;/data/&#39; + job_id + &#39;/&#39; + job_id + &#39;.targets.&#39; + guide + &#39;.zip&#39; ,target = &#39;_blank&#39;, style = {&#39;text-decoration&#39;:&#39;none&#39;, &#39;color&#39;:&#39;black&#39;} )),
                style = {&#39;display&#39;:DISPLAY_ONLINE}
            )
        )
        fl.append(
            html.Div(
                html.Button(&#39;Open Result Directory&#39;, id = &#39;button-open-result-directory&#39;),
                style = {&#39;display&#39;:DISPLAY_OFFLINE}
            )
        )
        fl.append(html.Div(guide,id = &#39;div-open-result-directory&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
        fl.append(html.Br())
        df = pd.read_pickle(job_directory + job_id + &#39;.summary_by_guide.&#39; + guide + &#39;.txt&#39;)
        if genome_type == &#39;both&#39;:
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Reference&#39;] == 0) &amp; (df[&#39;Targets in Enriched&#39;] == 0))  ].index, inplace = True)
        elif genome_type == &#39;var&#39;: 
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Enriched&#39;] == 0))  ].index, inplace = True)
            del df[&#39;Targets in Reference&#39;]
        else:
            df.drop( df[(df[&#39;Bulge Size&#39;] == 0) &amp; ((df[&#39;Bulge Type&#39;] == &#39;DNA&#39;) | ((df[&#39;Bulge Type&#39;] == &#39;RNA&#39;))) | ((df[&#39;Targets in Reference&#39;] == 0))  ].index, inplace = True)
        more_info_col = []
        total_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
            total_col.append(df[&#39;Bulge Size&#39;])

        #Swap pam creation and Combined column
        if genome_type == &#39;both&#39;:   #TODO fixare per var e ref
            df[&#39;Combined&#39;] = df[&#39;Targets in Reference&#39;] + df[&#39;Targets in Enriched&#39;]
            #[&#39;Guide&#39; &#39;Bulge Type&#39; &#39;Bulge Size&#39; &#39;Mismatches&#39; &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39; &#39;PAM Creation&#39; &#39;Combined&#39;]
            df = df[[&#39;Guide&#39; , &#39;Bulge Type&#39;, &#39;Mismatches&#39;, &#39;Bulge Size&#39; , &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Combined&#39;, &#39;PAM Creation&#39;]]
        df[&#39;&#39;] = more_info_col
        df[&#39;Total&#39;] = df[&#39;Bulge Size&#39;] + df[&#39;Mismatches&#39;]
        if genome_type == &#39;both&#39; and genome_type == &#39;var&#39;:
            df = df.sort_values([&#39;Total&#39;, &#39;Targets in Enriched&#39;], ascending = [True, False])
        else:
            df = df.sort_values(&#39;Total&#39;, ascending = True)
        del df[&#39;Total&#39;]
        del df[&#39;Guide&#39;]
        fl.append(html.Div(
                generate_table(df, &#39;table-summary-by-guide&#39;, genome_type, guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        return fl
    elif value == &#39;tab-summary-by-sample&#39;:
        #Show Summary by Sample table
        fl.append(
            html.P(&#39;Summary table counting the number of targets found in the Enriched Genome for each sample. Filter the table by selecting the Population or Superpopulation desired from the dropdowns.&#39;)
        )
        if genome_type == &#39;both&#39;:
            col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
        else:
            col_names_sample = [&#39;Sample&#39;, &#39;Gender&#39;, &#39;Population&#39;, &#39;Super Population&#39;,  &#39;Targets in Reference&#39;, &#39;Targets in Enriched&#39;, &#39;Targets in Population&#39;, &#39;Targets in Super Population&#39;, &#39;PAM Creation&#39;, &#39;Class&#39;]
            df = pd.read_csv(job_directory + job_id + &#39;.summary_by_samples.&#39; + guide + &#39;.txt&#39;, sep = &#39;\t&#39;, names = col_names_sample, skiprows = 1)
            df = df.sort_values(&#39;Targets in Enriched&#39;, ascending = False)
            df.drop([&#39;Targets in Reference&#39;], axis = 1, inplace = True)
            df.drop([&#39;Class&#39;], axis = 1, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        
        population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
        super_populations = [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp.keys()]
        populations = []
        for k in population_1000gp.keys():
            for i in population_1000gp[k]:
                populations.append({&#39;label&#39;:i, &#39;value&#39;:i})
        fl.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = super_populations, id = &#39;dropdown-superpopulation-sample&#39;, placeholder = &#39;Select a Super Population&#39;))),
                                dbc.Col(html.Div(dcc.Dropdown(options = populations, id = &#39;dropdown-population-sample&#39;, placeholder = &#39;Select a Population&#39;))),
                                #dbc.Col(html.Div(dcc.Dropdown( id = &#39;dropdown-sample&#39;, placeholder = &#39;Select a Sample&#39;))),
                                dbc.Col(html.Div(dcc.Input(id = &#39;input-sample&#39;, placeholder = &#39;Select a Sample&#39; ))),
                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-population-sample&#39;)))
                            ]
                        ),
                    ],
                    style = {&#39;width&#39;:&#39;50%&#39;}
                )
        )
        fl.append(html.Div(&#39;None,None,None&#39;,id = &#39;div-sample-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;})) #Folr keep current filter:  Superpop,Pop
        fl.append(html.Div(
                generate_table_samples(df, &#39;table-samples&#39;, 1, guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}, id = &#39;div-table-samples&#39;
            )
        )
        fl.append(
            html.Div(
                [
                    html.Button(&#39;Prev&#39;, id = &#39;prev-page-sample&#39;),
                    html.Button(&#39;Next&#39;, id = &#39;next-page-sample&#39;)
                ],
                style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        fl.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-table-samples&#39;))
        return fl
    elif value == &#39;tab-summary-by-position&#39;:
        #Show Summary by position table
        fl.append(
            html.P(&#39;Summary table containing all the targets found in a specific position of the genome. For each position, the enriched target with the lowest Mismatch + Bulge count is shown (if no target was found in the Enriched Genome, the correspondig reference one is shown), along with his Mismatch and Bulge Size values.&#39; + 
            &#39; The subtable \&#39;Targets in Cluster by Mismatch Value\&#39; represents the number of targets found in that position for a particular Mismatch-Bulge Size pair.&#39;)
        )

        fl.append(
            html.P(&#39;Filter the table by selecting the chromosome of interest and writing the start and/or end position of the region to view.&#39;)
        )
        #Dropdown chromosomes
        try:
            onlyfile = [f for f in listdir(current_working_directory + &#39;Genomes/&#39; + genome_selected) if (isfile(join(current_working_directory + &#39;Genomes/&#39; + genome_selected, f)) and (f.endswith(&#39;.fa&#39;) or f.endswith(&#39;.fasta&#39;)))]
        except:
            onlyfile = [&#39;chr&#39; + str(i) + &#39;.fa&#39; for i in range(1,23)]
            onlyfile.append(&#39;chrX.fa&#39;)
            onlyfile.append(&#39;chrY.fa&#39;)                                              #NOTE in case no chr in GENOMES/ i put 22 chr + X Y M
            onlyfile.append(&#39;chrM.fa&#39;)
        onlyfile = [x[:x.rfind(&#39;.&#39;)] for x in onlyfile]            #removed .fa for better visualization
        chr_file = []
        chr_file_unset = []
        for chr_name in onlyfile:
            chr_name = chr_name.replace(&#39;.enriched&#39;, &#39;&#39;)
            if &#39;_&#39; in chr_name:
                chr_file_unset.append(chr_name)
            else:
                chr_file.append(chr_name)
        #Show first &#39;normal&#39; chromosomes (chr1) then the others (chr1_KI270706v1_random)
        chr_file.sort(key = lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split(r&#39;(\d+)&#39;, s)])
        chr_file_unset.sort(key = lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split(r&#39;(\d+)&#39;, s)])
        chr_file += chr_file_unset
        chr_file = [{&#39;label&#39;: chr_name, &#39;value&#39; : chr_name} for chr_name in chr_file]
        
        # Colonne tabella: chr, pos, target migliore, min mm, min bulges, num target per ogni categoria di mm e bulge, show targets; ordine per total, poi mm e poi bulge
        start_time = time.time()
        df = pd.read_csv( job_directory + job_id + &#39;.summary_by_position.&#39; + guide +&#39;.txt&#39;, sep = &#39;\t&#39;)   
        df.rename(columns = {&#39;#Chromosome&#39;:&#39;Chromosome&#39;}, inplace = True)
        more_info_col = []
        for i in range(df.shape[0]):
            more_info_col.append(&#39;Show Targets&#39;)
        df[&#39;&#39;] = more_info_col
        fl.append(
            html.Div
                (
                    [
                        dbc.Row(
                            [
                                dbc.Col(html.Div(dcc.Dropdown(options = chr_file, id = &#39;dropdown-chr-table-position&#39;, placeholder = &#39;Select a chromosome&#39;))),
                                dbc.Col(html.Div(dcc.Input(placeholder = &#39;Start Position&#39;, id = &#39;input-position-start&#39;))),
                                dbc.Col(html.Div(dcc.Input(placeholder = &#39;End Position&#39;, id = &#39;input-position-end&#39;))),
                                dbc.Col(html.Div(html.Button(&#39;Filter&#39;, id = &#39;button-filter-position&#39;)))
                            ]
                        ),
                    ],
                    style = {&#39;width&#39;:&#39;50%&#39;}
                )
        )
        fl.append(html.Div(&#39;None,None,None&#39;,id = &#39;div-position-filter-query&#39;, style = {&#39;display&#39;:&#39;none&#39;})) #Folr keep current filter:  chr,pos_start,pos_end
        start_time = time.time()
        fl.append(html.Div(
                generate_table_position(df, &#39;table-position&#39;, 1 , int(mms), int(max_bulges), guide, job_id ), style = {&#39;text-align&#39;: &#39;center&#39;}, id = &#39;div-table-position&#39;
            )
        )
        fl.append(
            html.Div(
                [
                    html.Button(&#39;Prev&#39;, id = &#39;prev-page-position&#39;),
                    html.Button(&#39;Next&#39;, id = &#39;next-page-position&#39;)
                ],
                style = {&#39;text-align&#39;: &#39;center&#39;}
            )
        )
        max_page = len(df.index)
        max_page = math.floor(max_page / 10) + 1
        fl.append(html.Div(&#39;1/&#39; + str(max_page), id= &#39;div-current-page-table-position&#39;))
        fl.append(html.Div(mms + &#39;-&#39; + max_bulges, id = &#39;div-mms-bulges-position&#39;, style = {&#39;display&#39;:&#39;none&#39;}))
        return fl
    else:
        #Show Report images
        samp_style = {}
        if genome_type == &#39;ref&#39;:
            samp_style = {&#39;display&#39;:&#39;none&#39;}
        
        fl.append(html.Br())
        
        fl_buttons = []
        for i in range (10):
            if (i &lt;= int(mms)): #TODO change into (i &lt;= (int(mms) + int(max_bulges)))
                fl_buttons.append(
                    html.Button(str(i) + &#39; mm&#39;,id = &#39;btn&#39; + str(i)),       
                )
            else:
                fl_buttons.append(
                    html.Button(str(i) + &#39; mm&#39;,id = &#39;btn&#39; + str(i), style = {&#39;display&#39;:&#39;none&#39;}), #Hide buttons for mms non selected
                )
        
        fl.append(html.Br())

        radar_img = &#39;summary_single_guide_&#39; + guide + &#39;_&#39; + str(0) + &#39;mm.png&#39;

        barplot_img = &#39;summary_histogram_&#39; + guide + &#39;_&#39; + str(0) + &#39;mm.png&#39;
        try:            #NOTE serve per non generare errori se il barplot non Ã¨ stato fatto
            barplot_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + barplot_img, &#39;rb&#39;).read()).decode())
        except:
            barplot_src = &#39;&#39;
        try:
            barplot_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + barplot_img
        except:
            barplot_href = &#39;&#39;

        try:
            radar_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + radar_img, &#39;rb&#39;).read()).decode())
        except:
            radar_src = &#39;&#39;
        try:
            radar_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + radar_img
        except:
            radar_href = &#39;&#39;
        
        if genome_type != &#39;ref&#39;:
            population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
        
            super_populations = [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp.keys()]
            populations = []
            for k in population_1000gp.keys():
                for i in population_1000gp[k]:
                    populations.append({&#39;label&#39;:i, &#39;value&#39;:i})
        else:
            super_populations = []
            populations = [] 

        fl.append(
            html.Div(
                [   dbc.Row(
                        [
                            dbc.Col(
                                [
                                    html.P(&#39;Select Mismatch Value&#39;),
                                    dbc.Row(
                                        html.Div(fl_buttons),
                                    )
                                ]
                            ),
                            dbc.Col(
                                [
                                    html.P(&#39;Select Individual Data&#39;, style = samp_style ),
                                    dbc.Row([
                                    dbc.Col(html.Div(dcc.Dropdown(options = super_populations, id = &#39;dropdown-superpopulation-sample&#39;, placeholder = &#39;Select a Super Population&#39;, style = samp_style))),
                                    dbc.Col(html.Div(dcc.Dropdown(options = populations, id = &#39;dropdown-population-sample&#39;, placeholder = &#39;Select a Population&#39;, style = samp_style))),
                                    dbc.Col(html.Div(dcc.Dropdown( id = &#39;dropdown-sample&#39;, placeholder = &#39;Select a Sample&#39;, style = samp_style))),
                                    ])
                                ]
                            )
                        ]
                    ),
                ]
            )
        )
        fl.append(html.Hr())
        fl.append(
                html.Div(
                    [
                        dbc.Row(
                            [
                                dbc.Col([    #Guide part
                                    html.Div(
                                        [
                                    
                                            dbc.Row(html.Br()),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.A(
                                                            html.Img(src = radar_src, id = &#39;barplot-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                                                            target=&#34;_blank&#34;,
                                                            href = radar_href
                                                        ),
                                                        width = 10
                                                    )
                                                ]
                                            ),
                                            dbc.Row(html.Br()),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.A(
                                                            html.Img(src = barplot_src,id = &#39;radar-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                                                            target=&#34;_blank&#34;,
                                                            href = barplot_href
                                                        ),
                                                        width = 10
                                                    )
                                                ]
                                            )
                                            
                                        ],
                                        id = &#39;div-guide-image&#39;
                                    )
                                ]),
                                dbc.Col([    #Sample part
                                    html.Div(
                                        [
                                        
                                        ],
                                        id = &#39;div-sample-image&#39;
                                    )
                                ])
                            ]
                        )
                    ]
                
                )
            )
            
        
        fl.append(html.Br())
        fl.append(html.Br())

        #TODO codice per l&#39;integrazione del CFD graph. When .CFDGraph.txt will be integrated, remove the try/except
        
        cfd_path = job_directory + job_id +&#39;.CFDGraph.txt&#39;
        if not isfile(cfd_path): #No file found
            return fl
        
        fl.extend(
            CFDGraph.CFDGraph(cfd_path)
        )

        return fl
    # guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;State&#39;]
        # return guide + value
    raise PreventUpdate</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateGenomePageTable">
              <code class="name flex">
                <span>def <span class="ident">updateGenomePageTable</span></span
                >(<span>page_current, page_size, sort_by, filter)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;genomes-table&#39;, &#39;data&#39;),
    [Input(&#39;genomes-table&#39;, &#34;page_current&#34;),
     Input(&#39;genomes-table&#39;, &#34;page_size&#34;),
     Input(&#39;genomes-table&#39;, &#39;sort_by&#39;),
     Input(&#39;genomes-table&#39;, &#39;filter_query&#39;)])
def updateGenomePageTable(page_current, page_size, sort_by, filter):
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = get_genomes.get_genomes(current_working_directory)
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    page = page_current
    size = page_size
    return dff.iloc[page * size: (page + 1) * size].to_dict(&#39;records&#39;)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateHistoryFilter">
              <code class="name flex">
                <span>def <span class="ident">updateHistoryFilter</span></span
                >(<span>n, genome, pam)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-history-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-history&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-genomes-history&#39;, &#39;value&#39;),
    State(&#39;dropdown-pam-history&#39;, &#39;value&#39;)]
)
def updateHistoryFilter(n, genome, pam):
    if n is None:
        raise PreventUpdate
    return str(genome) + &#39;,&#39; + str(pam)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateImagesTabs">
              <code class="name flex">
                <span>def <span class="ident">updateImagesTabs</span></span
                >(<span
                  >n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, superpopulation,
                  population, sample, sel_cel, search, all_guides)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Loads the images on the Graphical Report based on the selected
                  mismatch value and/or sample, population, superpopulation
                  value.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n_</strong>]
                    <strong>btn_</strong> (<em>n_clicks_timestam</em>): string
                    of the timestamp of the last time the button was pressed.
                  </li>
                  <li>
                    [<strong>superpopulation</strong>]
                    <strong>dropdown-superpopulation-sample</strong>
                    (<em>value</em>): string of the selected superpopulation
                  </li>
                  <li>
                    [<strong>population</strong>]
                    <strong>dropdown-population-sample</strong>
                    (<em>value</em>): string of the selected population
                  </li>
                  <li>
                    [<strong>sample</strong>]
                    <strong>dropdown-sample</strong> (<em>value</em>): string of
                    the selected sample
                  </li>
                  <li>
                    [<strong>sel_cel</strong>]
                    <strong>general-profile-table</strong>
                    (<em>selected_cells</em>): list contaning the selected row
                    of the main guide table
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                  <li>
                    [<strong>all_guides</strong>]
                    <strong>general-profile-table</strong> (<em>data</em>): list
                    of all the rows that are currenty displayed in the main
                    guide table
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-guide-image</strong> (<em>children</em>):
                    returns barplot and radarchart of the selected guide
                  </li>
                  <li>
                    <strong>div-sample-image</strong> (<em>children</em>):
                    returns radarchart specific for sample/pop/superpop of the
                    selected guide
                  </li>
                </ul>
                <p>
                  <strong><em>Details</em></strong>
                </p>
                <ul>
                  <li>
                    The function sort all the timestamps of the buttons (can be
                    up to 10 buttons, one for each mms value) and select the one
                    that was clicked last. Since it is not possible in the
                    current Dash version to create callbacks of components that
                    are not available in the app.layout, but the buttons are
                    created dynamically (we do not know how many mms the user
                    selects), we create 10 buttons and show only the ones
                    corresponding to the number of selected mms, the others are
                    hidden using <code>{'display':'none'}</code>. In this way we
                    can create this callback even when we do not know how may
                    mms the user will set.
                  </li>
                  <li>
                    If the image for a specific sample/pop/superpop is not
                    available, the function calls
                    <code>crispritz.py generate-report</code> in order to create
                    the image
                  </li>
                  <li>
                    The corresponding image is then loaded from the
                    <code>assets/Img/jobID</code> directory, in order to be also
                    available to be opened in a new tab (by clicking on it)
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;div-guide-image&#39;, &#39;children&#39;),
    Output(&#39;div-sample-image&#39;, &#39;children&#39;)],
    [Input(&#39;btn0&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn1&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn2&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn3&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn4&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn5&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn6&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn7&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn8&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;btn9&#39;, &#39;n_clicks_timestamp&#39;),
    Input(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;),
    Input(&#39;dropdown-population-sample&#39;, &#39;value&#39;),
    Input(&#39;dropdown-sample&#39;, &#39;value&#39;),
    Input(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
    State(&#39;general-profile-table&#39;, &#39;data&#39;)]
)
def updateImagesTabs(n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, superpopulation, population, sample, sel_cel, search, all_guides):
    &#39;&#39;&#39;
    Loads the images on the Graphical Report based on the selected mismatch value and/or sample, population, superpopulation value.

    ***Args***

    + [**n_**] **btn_** (*n_clicks_timestam*): string of the timestamp of the last time the button was pressed.
    + [**superpopulation**] **dropdown-superpopulation-sample** (*value*): string of the selected superpopulation
    + [**population**] **dropdown-population-sample** (*value*): string of the selected population
    + [**sample**] **dropdown-sample** (*value*): string of the selected sample
    + [**sel_cel**] **general-profile-table** (*selected_cells*): list contaning the selected row of the main guide table
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**all_guides**] **general-profile-table** (*data*): list of all the rows that are currenty displayed in the main guide table

    ***Returns***

    + **div-guide-image** (*children*): returns barplot and radarchart of the selected guide
    + **div-sample-image** (*children*): returns radarchart specific for sample/pop/superpop of the selected guide

    ***Details***

    + The function sort all the timestamps of the buttons (can be up to 10 buttons, one for each mms value) and select the one that was clicked last.
    Since it is not possible in the current Dash version to create callbacks of components that are not available in the app.layout, but the buttons
    are created dynamically (we do not know how many mms the user selects), we create 10 buttons and show only the ones corresponding to the number
    of selected mms, the others are hidden using `{&#39;display&#39;:&#39;none&#39;}`. In this way we can create this callback even when we do not know how may mms
    the user will set.
    + If the image for a specific sample/pop/superpop is not available, the function calls `crispritz.py generate-report` in order to create the image 
    + The corresponding image is then loaded from the `assets/Img/jobID` directory, in order to be also available to be opened in a new tab (by
    clicking on it)
    &#39;&#39;&#39;

    if sel_cel is None :
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = all_guides[int(sel_cel[0][&#39;row&#39;])][&#39;Guide&#39;]
    
    guide_images = []
    sample_images = []
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        gecko_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Gecko&#39; in s)).split(&#39;\t&#39;)[-1]

    gecko_string = &#39;&#39;
    if gecko_comp == &#39;True&#39;:
        gecko_string = &#39;-gecko&#39;
    
    #Initialize to 0 Buttons not pressed
    if not n0:
        n0 = 0
    if not n1:
        n1 = 0
    if not n2:
        n2 = 0
    if not n3:
        n3 = 0
    if not n4:
        n4 = 0
    if not n5:
        n5 = 0
    if not n6:
        n6 = 0
    if not n7:
        n7 = 0
    if not n8:
        n8 = 0
    if not n9:
        n9 = 0
    btn_group = []
    btn_group.append(n0)
    btn_group.append(n1)
    btn_group.append(n2)
    btn_group.append(n3)
    btn_group.append(n4)
    btn_group.append(n5)
    btn_group.append(n6)
    btn_group.append(n7)
    btn_group.append(n8)
    btn_group.append(n9)
    
    #Check last pressed button
    if max(btn_group) == n0:
        mm_show = 0
    if max(btn_group) == n1:
        mm_show = 1
    if max(btn_group) == n2:
        mm_show = 2
    if max(btn_group) == n3:
        mm_show = 3
    if max(btn_group) == n4:
        mm_show = 4
    if max(btn_group) == n5:
        mm_show = 5
    if max(btn_group) == n6:
        mm_show = 6
    if max(btn_group) == n7:
        mm_show = 7
    if max(btn_group) == n8:
        mm_show = 8
    if max(btn_group) == n9:
        mm_show = 9
    if max(btn_group) == 0:
        mm_show = 0
    radar_img = &#39;summary_single_guide_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;

    barplot_img = &#39;summary_histogram_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;
    try:            #NOTE if the image is not available, show nothing
        barplot_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + barplot_img, &#39;rb&#39;).read()).decode())
    except:
        barplot_src = &#39;&#39;
    try:
        barplot_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + barplot_img
    except:
        barplot_href = &#39;&#39;

    try:
        radar_src = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + radar_img, &#39;rb&#39;).read()).decode())
    except:
        radar_src = &#39;&#39;
    try:
        radar_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + radar_img
    except:
        radar_href = &#39;&#39;
    
    guide_images.extend([
        
        dbc.Row(html.Br()),
        dbc.Row(
            [
                dbc.Col(
                    html.A(
                        html.Img(src = radar_src, id = &#39;radar-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                        target=&#34;_blank&#34;,
                        href = radar_href
                    ),
                    width = 10
                )
            ]
        ),
        dbc.Row(html.Br()),
        dbc.Row(
            [
                dbc.Col(
                    html.A(
                        html.Img(src = barplot_src,id = &#39;barplot-img-guide&#39;, width=&#34;100%&#34;, height=&#34;auto&#34;),
                        target=&#34;_blank&#34;,
                        href = barplot_href
                    ),
                    width = 10
                )
            ]
        )
    ])
    class_images = [(sample, &#39;Samples&#39;), (population, &#39;Population&#39;), (superpopulation, &#39;Superpopulation&#39;)]
    
    #If the user selects a sample/pop/superpop not already processed, call crispritz generate-report and create the image
    for c in class_images:
        if c[0]:
            try:
                first_img_source = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;, &#39;rb&#39;).read()).decode())
            except:
                #create image from annotation file of samples
                subprocess.call([&#39;cd &#39;+job_directory +&#39;;&#39;+
                &#39; crispritz.py generate-report &#39; + guide + &#39; -mm &#39; + str(mm_show) + &#39; -annotation &#39; + job_id + &#39;.sample_annotation.&#39; + guide +
                &#39;.&#39; + c[1].lower() + &#39;.txt &#39;+ gecko_string +&#39; -ws -sample &#39; + c[0]], shell = True)
                
                copy_img = subprocess.Popen([&#39;cp &#39; + job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png assets/Img/&#39; + job_id], shell = True)
                copy_img.wait() #BUG se metto il copia link, mi si ricarica la pagina, forse il problema non c&#39;Ã¨ se uso gnicorn
                first_img_source = &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(open(job_directory + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;, &#39;rb&#39;).read()).decode())
            try:
                first_img_href = &#39;assets/Img/&#39; + job_id + &#39;/&#39; + &#39;summary_single_guide_&#39; + c[0] +&#39;_&#39; + guide + &#39;_&#39; + str(mm_show) + &#39;mm.png&#39;
            except:
                first_img_href = &#39;&#39;
            sample_images.append(dbc.Row(html.Br()))

            sample_images.append(
                dbc.Row(
                [
                    dbc.Col(
                        html.A(
                            html.Img(src = first_img_source, width=&#34;100%&#34;, height=&#34;auto&#34;),
                            target=&#34;_blank&#34;,
                            href = first_img_href
                        ),
                        width = 10
                    ),
                ],
                no_gutters=True 
            ),
            )
    return guide_images, sample_images</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updatePopulationDrop">
              <code class="name flex">
                <span>def <span class="ident">updatePopulationDrop</span></span
                >(<span>superpop, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update the Dropdown containing the Population list based on
                  the selected Superpopulation.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>superpop</strong>]
                    <strong>dropdown-superpopulation-sample</strong>
                    (<em>value</em>): string of the selected Superpopulation
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>dropdown-population-sample</strong>
                    (<em>options</em>): list of dictionaries for the option
                    element of the Population dropdown
                  </li>
                  <li>
                    <strong>dropdown-population-sample</strong>
                    (<em>value</em>): currently selected value (reinitialized to
                    be empty)
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;dropdown-population-sample&#39;, &#39;options&#39;),
    Output(&#39;dropdown-population-sample&#39;, &#39;value&#39;)],
    [Input(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def updatePopulationDrop(superpop, search):
    &#39;&#39;&#39;
    Update the Dropdown containing the Population list based on the selected Superpopulation.

    ***Args***

    + [**superpop**] **dropdown-superpopulation-sample** (*value*): string of the selected Superpopulation
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **dropdown-population-sample** (*options*): list of dictionaries for the option element of the Population dropdown
    + **dropdown-population-sample** (*value*): currently selected value (reinitialized to be empty)
    &#39;&#39;&#39;
    if superpop is None or superpop == &#39;&#39;:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    population_1000gp = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[2]
    return [{&#39;label&#39;:i, &#39;value&#39;:i} for i in population_1000gp[superpop]], None </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updatePositionFilter">
              <code class="name flex">
                <span>def <span class="ident">updatePositionFilter</span></span
                >(<span>n, chr, pos_start, pos_end)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update the filter (chr,start,end) for the filtering of the
                  Summary by Position table
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>button-filter-population-sample</strong>
                    (<em>n_clicks</em>): int for the number of times the button
                    was clicked
                  </li>
                  <li>
                    [<strong>chr</strong>]
                    <strong>dropdown-chr-table-position</strong>
                    (<em>value</em>): string containing the selected chromosome
                  </li>
                  <li>
                    [<strong>pos_start</strong>]
                    <strong>input-position-start</strong> (<em>value</em>):
                    string containing the start position
                  </li>
                  <li>
                    [<strong>pos_end</strong>]
                    <strong>input-position-end</strong> (<em>value</em>): string
                    containing the end position
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-position-filter-query</strong>
                    (<strong>children</strong>): string in the format of
                    'chr,start,end', or 'None' if a parameter was not provided
                    (eg 'chr4,1010,None')
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-position-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-position&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-chr-table-position&#39;, &#39;value&#39;),
    State(&#39;input-position-start&#39;, &#39;value&#39;),
    State(&#39;input-position-end&#39;, &#39;value&#39;)]
)
def updatePositionFilter(n, chr, pos_start, pos_end):
    &#39;&#39;&#39;
    Update the filter (chr,start,end) for the filtering of the Summary by Position table

    ***Args***

    + [**n**] **button-filter-population-sample** (*n_clicks*): int for the number of times the button was clicked
    + [**chr**] **dropdown-chr-table-position** (*value*): string containing the selected chromosome
    + [**pos_start**] **input-position-start** (*value*): string containing the start position
    + [**pos_end**] **input-position-end** (*value*): string containing the end position

    ***Returns***

    + **div-position-filter-query** (**children**): string in the format of &#39;chr,start,end&#39;, or &#39;None&#39; if a parameter was not provided (eg
    &#39;chr4,1010,None&#39;)
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    if pos_start == &#39;&#39;:
        pos_start = &#39;None&#39;
    if pos_end == &#39;&#39;:
        pos_end = &#39;None&#39;
    return str(chr) + &#39;,&#39; + str(pos_start) + &#39;,&#39; + str(pos_end)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateSampleDrop">
              <code class="name flex">
                <span>def <span class="ident">updateSampleDrop</span></span
                >(<span>pop, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update the Dropdown containing the Sample list based on the
                  selected Population.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>pop</strong>]
                    <strong>dropdown-population-sample</strong>
                    (<em>value</em>): string of the selected Population
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>dropdown-sample</strong> (<em>options</em>): list of
                    dictionaries for the option element of the Sample dropdown
                  </li>
                  <li>
                    <strong>dropdown-sample</strong> (<em>value</em>): currently
                    selected value (reinitialized to be empty)
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;dropdown-sample&#39;,&#39;options&#39;),
    Output(&#39;dropdown-sample&#39;,&#39;value&#39;)],
    [Input(&#39;dropdown-population-sample&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]
)
def updateSampleDrop(pop, search):
    &#39;&#39;&#39;
    Update the Dropdown containing the Sample list based on the selected Population.

    ***Args***

    + [**pop**] **dropdown-population-sample** (*value*): string of the selected Population
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **dropdown-sample** (*options*): list of dictionaries for the option element of the Sample dropdown
    + **dropdown-sample** (*value*): currently selected value (reinitialized to be empty)
    &#39;&#39;&#39;
    if pop is None or pop == &#39;&#39;:
        return [], None
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    dict_pop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[3]
    return [{&#39;label&#39;: sam, &#39;value&#39; : sam} for sam in dict_pop[pop]], None </code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateSampleFilter">
              <code class="name flex">
                <span>def <span class="ident">updateSampleFilter</span></span
                >(<span>n, superpopulation, population, sample)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Update the filter (superpop,pop,sample) for the filtering of
                  the Summary by Sample table
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>n</strong>]
                    <strong>button-filter-population-sample</strong>
                    (<em>n_clicks</em>): int for the number of times the button
                    was clicked
                  </li>
                  <li>
                    [<strong>superpopulation</strong>]
                    <strong>dropdown-superpopulation-sample</strong>
                    (<em>value</em>): string containing the selected
                    Superpopulation
                  </li>
                  <li>
                    [<strong>population</strong>]
                    <strong>dropdown-population-sample</strong>
                    (<em>value</em>): string containing the selected Population
                  </li>
                  <li>
                    [<strong>sample</strong>]
                    <strong>input-sample</strong> (<em>value</em>): string
                    containing the Sample, given in input by the user
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>div-simple-filter-query</strong>
                    (<strong>children</strong>): string in the format of
                    'superpop,pop,sample', or 'None' if a parameter was not
                    provided (eg 'EU,TSI,None')
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;div-sample-filter-query&#39;, &#39;children&#39;),
    [Input(&#39;button-filter-population-sample&#39;, &#39;n_clicks&#39;)],
    [State(&#39;dropdown-superpopulation-sample&#39;, &#39;value&#39;),
    State(&#39;dropdown-population-sample&#39;, &#39;value&#39;),
    State(&#39;input-sample&#39;, &#39;value&#39;)]
)
def updateSampleFilter(n, superpopulation, population, sample):
    &#39;&#39;&#39;
    Update the filter (superpop,pop,sample) for the filtering of the Summary by Sample table

    ***Args***

    + [**n**] **button-filter-population-sample** (*n_clicks*): int for the number of times the button was clicked
    + [**superpopulation**] **dropdown-superpopulation-sample** (*value*): string containing the selected Superpopulation
    + [**population**] **dropdown-population-sample** (*value*): string containing the selected Population
    + [**sample**] **input-sample** (*value*): string containing the Sample, given in input by the user

    ***Returns***

    + **div-simple-filter-query** (**children**): string in the format of &#39;superpop,pop,sample&#39;, or &#39;None&#39; if a parameter was not provided (eg
    &#39;EU,TSI,None&#39;)
    &#39;&#39;&#39;
    if n is None:
        raise PreventUpdate
    return str(superpopulation) + &#39;,&#39; + str(population) + &#39;,&#39; + str(sample).replace(&#39; &#39;,&#39;&#39;).upper()</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.updateStatusCreateNewGenome">
              <code class="name flex">
                <span
                  >def
                  <span class="ident">updateStatusCreateNewGenome</span></span
                >(<span>n, n_button)</span>
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;progress-add-new-genome&#39;, &#39;value&#39;),
    Output(&#39;status-add-new-genome&#39;,&#39;children&#39;),
    Output(&#39;button-add-new-genome&#39;, &#39;disabled&#39;),
    Output(&#39;button-add-new-genome&#39;, &#39;style&#39;)],
    [Input(&#39;interval-add-new-genome&#39;,&#39;n_intervals&#39;),
    Input(&#39;button-add-new-genome&#39;,&#39;n_clicks&#39;)]
)
def updateStatusCreateNewGenome(n, n_button):   
    if n is None and n_button is None:
        raise PreventUpdate
    

    context = dash.callback_context.triggered[0][&#39;prop_id&#39;].split(&#39;.&#39;)[0] #id of input that triggered callback
    if context == &#39;button-add-new-genome&#39;:
        return 0, &#39;Status: Copy Genome&#39;, True,  {&#39;background-color&#39;:&#39;darkgrey&#39;}
    #TODO questa funzione legge il file creato dalla funzione startAddNewGenome e in base allo step in cui siamo (Copia file, indicizzazione, enrichment etc)
    #ritorna in output una valore della barra (eg +25 per ogni step fatto) e lo step a cui siamo (eg Status: Enrichment Genome)
    
    #controlla se esiste il file aggiunta nuovo genoma, e aggiorna la barra e mette il bottone a Disabled = True
    if isfile(current_working_directory + &#39;Genomes/aggiunta_nuovo_genoma.txt&#39;):
        with open(current_working_directory + &#39;Genomes/aggiunta_nuovo_genoma.txt&#39;) as info_status:
            a = next(info_status).strip().split(&#39; &#39;) #Get current step number [0] and step name [1]
            if &#39;Done&#39; == a[1]:
                subprocess.run([&#39;rm&#39;, current_working_directory + &#39;Genomes/&#39; + &#39;aggiunta_nuovo_genoma.txt&#39;])
                return 100, &#39;Status: Done&#39;, False, {}
        return str(int(a[0]) * 25), &#39;Status: &#39; + a[1], True,  {&#39;background-color&#39;:&#39;darkgrey&#39;}
    return 0 , &#39;Status: No Job Submitted&#39;, False, {}</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_dict">
              <code class="name flex">
                <span>def <span class="ident">update_dict</span></span
                >(<span>nUpd)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Bottone per avviare la GUI in Tkinter per l'aggiornamento di
                  dizionari
                </p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#34;dict-job&#34;,&#34;value&#34;),        
    [Input(&#34;update-dict&#34;,&#34;n_clicks&#34;)],  
)
def update_dict(nUpd):
    &#34;&#34;&#34;
    Bottone per avviare la GUI in Tkinter per l&#39;aggiornamento di dizionari
    &#34;&#34;&#34;
    from GUI import UpdateDict as ud
    if nUpd is None:
        raise PreventUpdate
    ud.startUpdateDict(current_working_directory)
    return &#39;&#39;</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_iupac_scomposition_table_cluster">
              <code class="name flex">
                <span
                  >def
                  <span class="ident"
                    >update_iupac_scomposition_table_cluster</span
                  ></span
                >(<span
                  >page_current, page_size, sort_by, filter, search, hash)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;table-scomposition-cluster&#39;,&#39;data&#39;),
    [Input(&#39;table-scomposition-cluster&#39;, &#34;page_current&#34;),
     Input(&#39;table-scomposition-cluster&#39;, &#34;page_size&#34;),
     Input(&#39;table-scomposition-cluster&#39;, &#39;sort_by&#39;),
     Input(&#39;table-scomposition-cluster&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_iupac_scomposition_table_cluster(page_current, page_size, sort_by, filter, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;

    if genome_type == &#39;ref&#39;:       
        raise PreventUpdate
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +&#39;.scomposition.txt&#39;)
    if dff is None:
        raise PreventUpdate
    
    # #Grep annotation
    # file_to_grep = &#39;.Annotation.targets.txt&#39;
    # get_annotation = subprocess.Popen([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + position + &#39; &amp;&amp; $4==\&#34;&#39; + chromosome + &#39;\&#34;\&#39;&#39;], shell = True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # out, err = get_annotation.communicate()
    # annotation_type = out.decode(&#39;UTF-8&#39;).strip().split(&#39;\t&#39;)[-1]
    
    # if genome_type == &#39;var&#39;:           
    #     dff.rename(columns = {0:&#39;Bulge Type&#39;, 1:&#39;crRNA&#39;, 2:&#39;DNA&#39;, 3:&#39;Chromosome&#39;, 4:&#39;Position&#39;, 5:&#39;Cluster Position&#39;, 6:&#39;Direction&#39;,
    #     7:&#39;Mismatches&#39;, 8:&#39;Bulge Size&#39;, 9:&#39;Total&#39;, 10:&#39;Min Mismatches&#39;, 11:&#39;Max Mismatches&#39;, 12:&#39;Samples&#39;, 13:&#39;Correct Guide&#39;, 14:&#39;Annotation Type&#39;,15:&#39;Top Subcluster&#39;}, inplace = True)
    # else:
    dff.rename(columns = COL_BOTH_RENAME , inplace = True)
    # dff.drop(dff.columns[[-1,]], axis=1, inplace=True)         #NOTE Drop the Correct Guide column
    del dff[&#39;Correct Guide&#39;]
    #dff[&#39;Annotation Type&#39;] = annotation_type
    del dff[&#39;Variant Unique&#39;]
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break     #If a target have n, it means it&#39;s REF, because either all have samples or the single target is REF
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table">
              <code class="name flex">
                <span>def <span class="ident">update_table</span></span
                >(<span
                  >page_current, page_size, sort_by, filter, search,
                  hash_guide)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  La funzione ritorna uno split dei risultati in base ad un
                  filtering o a un sort da parte dell'utente. Inoltre aggiorna i
                  risultati visualizzati quando il bottone next page / prev page
                  Ã¨ cliccato. (Codice preso dalla pagina dash datatable sul
                  sorting con python) Inoltre carica i file targets, o scores se
                  presente, e lo trasforma in un dataframe, cambiando il nome
                  delle colonne per farle corrispondere all'id delle colonne
                  della tabella nella pagina. Se non ci sono targets ritorna un
                  avviso di errore
                </p>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;result-table&#39;, &#39;data&#39;),
    [Input(&#39;result-table&#39;, &#34;page_current&#34;),
     Input(&#39;result-table&#39;, &#34;page_size&#34;),
     Input(&#39;result-table&#39;, &#34;sort_by&#34;),
     Input(&#39;result-table&#39;, &#39;filter_query&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_table(page_current, page_size, sort_by, filter, search, hash_guide):
    &#39;&#39;&#39;
    La funzione ritorna uno split dei risultati in base ad un filtering o a un sort da parte dell&#39;utente. Inoltre aggiorna i risultati
    visualizzati quando il bottone next page / prev page Ã¨ cliccato. (Codice preso dalla pagina dash datatable sul sorting con python)
    Inoltre carica i file targets, o scores se presente, e lo trasforma in un dataframe, cambiando il nome delle colonne per farle corrispondere
    all&#39;id delle colonne della tabella nella pagina.
    Se non ci sono targets ritorna un avviso di errore
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    guide = hash_guide.split(&#39;#&#39;)[1]
    value = job_id
    if search is None:
        raise PreventUpdate

    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    #filtering_expressions.append([&#39;{crRNA} = &#39; + guide])     
    df = global_store(value)
    dff = df[df[&#39;crRNA&#39;] == guide]

    sort_by.insert(0, {&#39;column_id&#39; : &#39;Mismatches&#39;, &#39;direction&#39;: &#39;asc&#39;})
    sort_by.insert(1, {&#39;column_id&#39; : &#39;BulgeSize&#39;, &#39;direction&#39;: &#39;asc&#39;})
    #sort_by.insert(2, {&#39;column_id&#39;: &#39;CFD&#39;, &#39;direction&#39;:&#39;desc&#39;})
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)].sort_values([col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False)
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    #NOTE sort_by: [{&#39;column_id&#39;: &#39;BulgeType&#39;, &#39;direction&#39;: &#39;asc&#39;}, {&#39;column_id&#39;: &#39;crRNA&#39;, &#39;direction&#39;: &#39;asc&#39;}]
    #sort_by.insert(0, {&#39;column_id&#39; : &#39;Mismatches&#39;, &#39;direction&#39;: &#39;asc&#39;})
    #sort_by.insert(0, {&#39;column_id&#39; : &#39;BulgeSize&#39;, &#39;direction&#39;: &#39;asc&#39;})
    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Check if results are not 0
    warning_no_res = &#39;&#39;
    with open(job_directory + job_id + &#39;.targets.txt&#39;) as t:
        no_result = False
        t.readline()
        last_line = t.readline()
        if (last_line == &#39;&#39; or last_line == &#39;\n&#39;):
            no_result = True

    if (no_result):
        warning_no_res = dbc.Alert(&#34;No results were found with the given parameters&#34;, color = &#34;warning&#34;)

     
    return dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table_cluster">
              <code class="name flex">
                <span>def <span class="ident">update_table_cluster</span></span
                >(<span
                  >page_current, page_size, sort_by, filter, hide_reference,
                  search, hash)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;table-position-target&#39;, &#39;data&#39;),
    [Input(&#39;table-position-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-position-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-position-target&#39;, &#39;sort_by&#39;),
     Input(&#39;table-position-target&#39;, &#39;filter_query&#39;),
     Input(&#39;hide-reference-targets&#39;, &#39;value&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]    
)
def update_table_cluster(page_current, page_size, sort_by, filter, hide_reference, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Pos-&#39;)]
    chr_pos = hash[hash.find(&#39;-Pos-&#39;) + 5:]
    chromosome = chr_pos.split(&#39;-&#39;)[0]
    position = chr_pos.split(&#39;-&#39;)[1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.&#39; + chromosome + &#39;_&#39; + position + &#39;.&#39; + guide +  &#39;.txt&#39;)
    if dff is None:
        raise PreventUpdate

    if genome_type == &#39;ref&#39;:
        dff.rename(columns = COL_REF_RENAME, inplace = True)
    else:                           
        dff.rename(columns =COL_BOTH_RENAME , inplace = True)

    if genome_type != &#39;ref&#39;:
        # add_samples = [dff[&#39;Samples&#39;][0]] * dff.shape[0]
        # check_minmms = dff[&#39;Min Mismatches&#39;]
        # if dff[&#39;Variant Unique&#39;][0] != &#39;y&#39; and dff[&#39;PAM Creation&#39;][0] == &#39;n&#39;:
        #     for pos_minmms, minmms in enumerate(check_minmms):
        #         if minmms == &#39;-&#39;:
        #             add_samples[pos_minmms] = &#39;n&#39;
        # dff[&#39;Samples&#39;] = add_samples
        del dff[&#39;Variant Unique&#39;]
        # dff.drop(dff.head(1).index, inplace=True)       #Remove first target, that is the top1 with no iupac (lowest mm of scomposed target) and is 
                                                    #needed only for summary by guide, not the show target part
                                                    #NOTE 18/03 removed all the iupac char, the first line is needed to be shown
    # dff[&#39;Annotation Type&#39;] = list(dff[&#39;Annotation Type&#39;])[0]
    del dff[&#39;Correct Guide&#39;]
    
    if &#39;hide-ref&#39; in hide_reference or genome_type == &#39;var&#39;:
        dff.drop( dff[(dff[&#39;Samples&#39;] == &#39;n&#39;)].index, inplace = True)

    if &#39;hide-cluster&#39; in hide_reference:
        dff = dff.head(1)

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;): 
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table_general_profile">
              <code class="name flex">
                <span
                  >def
                  <span class="ident">update_table_general_profile</span></span
                >(<span>page_current, page_size, sort_by, filter, search)</span>
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>The function loads the data to be shown into the table.</p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>page_current</strong>]
                    <strong>general-profile-table</strong>
                    (<em>page_current</em>): int of the current page to show
                  </li>
                  <li>
                    [<strong>page_size</strong>]
                    <strong>general-profile-table</strong> (<em>page_size</em>):
                    int of the maximum number of row for each page
                  </li>
                  <li>
                    [<strong>sort_by</strong>]
                    <strong>general-profile-table</strong> (<em>sort_by</em>):
                    list dictionaries of column IDs and sorting direction
                  </li>
                  <li>
                    [<strong>filter</strong>]
                    <strong>general-profile-table</strong>
                    (<em>filter_query</em>): list dictionaries for the data
                    filtering
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>general-profile-table</strong> (<em>data</em>):
                    dictionary of the data to be shown
                  </li>
                  <li>
                    <strong>general-profile-table</strong>
                    (<em>selected_cells</em>): dictionary containing the
                    selected cell, default at first row
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;general-profile-table&#39;, &#39;data&#39;),
    Output(&#39;general-profile-table&#39;, &#39;selected_cells&#39;)],
    [Input(&#39;general-profile-table&#39;, &#34;page_current&#34;),
     Input(&#39;general-profile-table&#39;, &#34;page_size&#34;),
     Input(&#39;general-profile-table&#39;, &#39;sort_by&#39;),
     Input(&#39;general-profile-table&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;)]    
)
def update_table_general_profile(page_current, page_size, sort_by, filter, search):
    &#39;&#39;&#39;
    The function loads the data to be shown into the table. 

    ***Args***

    + [**page_current**] **general-profile-table** (*page_current*): int of the current page to show
    + [**page_size**] **general-profile-table** (*page_size*): int of the maximum number of row for each page
    + [**sort_by**] **general-profile-table** (*sort_by*): list dictionaries of column IDs and sorting direction
    + [**filter**] **general-profile-table** (*filter_query*): list dictionaries for the data filtering
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;

    ***Returns***

    + **general-profile-table** (*data*): dictionary of the data to be shown
    + **general-profile-table** (*selected_cells*): dictionary containing the selected cell, default at first row
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        mms = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Mismatches&#39; in s)).split(&#39;\t&#39;)[-1])
        max_bulges = int((next(s for s in all_params.split(&#39;\n&#39;) if &#39;Max_bulges&#39; in s)).split(&#39;\t&#39;)[-1])
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    
    #Get error guides
    list_error_guides = []
    if os.path.exists(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides_error.txt&#39;):
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides_error.txt&#39;) as error_g:
            for e_g in error_g:
                list_error_guides.append(e_g.strip())
    
    #Get guide from guide.txt
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/guides.txt&#39;) as g:
        guides = g.read().strip().split(&#39;\n&#39;)
        guides.sort()

    #load acfd for each guide 
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/acfd.txt&#39;) as a:
        all_scores = a.read().strip().split(&#39;\n&#39;)
    
    #Load scores
    if &#39;NO SCORES&#39; not in all_scores:
        all_scores.sort()
        acfd = [float(a.split(&#39;\t&#39;)[1]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        doench = [int(a.split(&#39;\t&#39;)[2]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        if genome_type == &#39;both&#39;:
            doench_enr = [int(a.split(&#39;\t&#39;)[3]) for a in all_scores if a.split(&#39;\t&#39;)[0] not in list_error_guides]
        acfd  = [int(round((100/(100 + x))*100)) for x in acfd] 

    #Get target counting from summary by guide
    column_on_target = []
    column_off_target_ref = []
    column_sample_class = []
    column_total = []
    if genome_type == &#39;ref&#39; or genome_type == &#39;var&#39;:
        for g in guides:
            one_to_n_mms = []
            df_profile = pd.read_pickle(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.summary_by_guide.&#39; + g + &#39;.txt&#39;)
            on_t_ref = int(df_profile[(df_profile.Mismatches == 0) &amp; (df_profile[&#39;Bulge Type&#39;] == &#39;X&#39;)].iloc[0][&#39;Targets in Reference&#39;])
            try: #For VAR, read enriched values
                on_t_enr = int(df_profile[(df_profile.Mismatches == 0) &amp; (df_profile[&#39;Bulge Type&#39;] == &#39;X&#39;)].iloc[0][&#39;Targets in Enriched&#39;]) 
                column_on_target.append(str(on_t_enr))
            except: #For REF, read only reference values
                column_on_target.append(str(on_t_ref))
            
            for i in range (1, mms + 1 + int(max_bulges)):         #For column Targets for 1-2 Total (Mismatches + Bulges), sum values for row with same total
                try:    #For VAR
                    one_to_n_mms.append(sum(df_profile[((df_profile[&#39;Mismatches&#39;] + df_profile[&#39;Bulge Size&#39;]) == i)][&#39;Targets in Enriched&#39;].to_list()))
                except: #For REF
                    one_to_n_mms.append(sum(df_profile[((df_profile[&#39;Mismatches&#39;] + df_profile[&#39;Bulge Size&#39;]) == i)][&#39;Targets in Reference&#39;].to_list()))
            column_total.append(int(sum(one_to_n_mms)))
            column_off_target_ref.append([int(x) for x in one_to_n_mms])  #[[1, 5, 10], [3, 7, 20]]       each internal list is the number of off-target for a guide, divided by value (from 1 to mm+max_bulge)
    else:
        #NOTE  USO IL CONTEGGIO PRESO DA jobid.general_target_count.txt
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.general_target_count.txt&#39;) as general_count:
            header_general = next(general_count) #skip header
            general_count_content = general_count.read().strip().split(&#39;\n&#39;)
            general_count_content.sort(key = lambda x : x[0])
        guides = []
        column_on_target_old = dict()      #will contain GUIDE -&gt; 3(1 - 2), then later, in column_on_target, only the 1 will be kept
        for tmp in general_count_content:
            tmp = tmp.split(&#39;\t&#39;)   #[GUIDE, total_onT (onT_ref - onTvar), total_offT_ref ( - - - ), total_offT_var ( - - -)]
            guides.append(tmp[0])
            column_on_target_old[tmp[0]] = tmp[1]      #tmp[1] =  3(1 - 2)
            a = tmp[2].replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).replace(&#39;-&#39;,&#39;&#39;).replace(&#39;  &#39;,&#39; &#39;).strip().split(&#39; &#39;) # ottengo in a[0] il total, da a[1:] il numero di targets per 1 2 3 ... Total del REF
            b = tmp[3].replace(&#39;(&#39;,&#39;&#39;).replace(&#39;)&#39;,&#39;&#39;).replace(&#39;-&#39;,&#39;&#39;).replace(&#39;  &#39;,&#39; &#39;).strip().split(&#39; &#39;) # ottengo in a[0] il total, da a[1:] il numero di targets per 1 2 3 ... Total del VAR
            column_total.append(a[0] + &#39;\n&#39; + b[0] + &#39;\n&#39; + str(int(a[0]) + int(b[0])))
            column_off_target_ref.append(
                [a[x] + &#39;\n&#39; + b[x] + &#39;\n&#39; + str(int(a[x]) + int(b[x])) for x in range(len(a))][1:]     #[1:] to skip total value
            )   # in the end i obtain [ [&#39;1\n3\n5&#39;, &#39;12\n21\n54&#39;] , [&#39;0\n3\n4&#39;, &#39;12\n25\n34&#39;]], one list per guide, inside each list string for each total value
            
        with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39; + job_id + &#39;.SampleClasses.txt&#39;) as samp_classes:
            header_classes = next(samp_classes).strip().split(&#39;\t&#39;)[1:]     #List of Guides
            for line in samp_classes:
                if &#39;Total for Class&#39; in line:       #Last line
                    value_classes = line.strip().split(&#39;\t&#39;)[1:]           #List of values of classes for each guide
        #NOTE just for changing &#39;-&#39; to &#39; - &#39;
        for pos_vc, vc in enumerate(value_classes):
            value_classes[pos_vc] = &#39; - &#39;.join(vc.split(&#39;-&#39;))
        
        dict_classes = dict(zip(header_classes, value_classes))
        column_on_target = []
        for g in guides:
            column_sample_class.append(dict_classes[g]) 
            column_on_target.append(column_on_target_old[g].split(&#39;(&#39;)[-1].split(&#39;-&#39;)[0])

    data_guides = dict()
    data_guides[&#39;Guide&#39;] = guides
    if &#39;NO SCORES&#39; not in all_scores:
        data_guides[&#39;CFD&#39;] = acfd
        if genome_type == &#39;both&#39;:
            data_guides[&#39;Reference&#39;] = doench
            data_guides[&#39;Enriched&#39;] = doench_enr
        else:
            data_guides[&#39;Doench 2016&#39;] = doench

    if genome_type == &#39;ref&#39; or genome_type == &#39;both&#39;:
        data_guides[&#39;On-Targets Reference&#39;] = column_on_target
        data_guides[&#39;Genome&#39;] = &#39;REFERENCE&#39;     #NOTE if genome_type == &#39;both&#39;, it will be updated
    else:
        data_guides[&#39;On-Targets Enriched&#39;] = column_on_target
        data_guides[&#39;Genome&#39;] = &#39;ENRICHED&#39;

    if genome_type == &#39;both&#39;:
        data_guides[&#39;Samples in Class 0 - 0+ - 1 - 1+&#39;] = column_sample_class
        data_guides[&#39;Genome&#39;] = &#39;REFERENCE\nENRICHED\nCOMBINED&#39;
    data_guides[&#39;Total&#39;] = column_total
    for i in range (1, mms + int(max_bulges) + 1):  #add count target for each total value
        data_guides[str(i) + &#39; MM + B&#39;] = [str(x[i-1]) for x in column_off_target_ref]      #NOTE i-1 since i starts from 1

    dff = pd.DataFrame(data_guides)
    
    if &#39;NO SCORES&#39; not in all_scores:
        try:
            dff = dff.sort_values([&#39;CFD&#39;, &#39;Doench 2016&#39;], ascending = [False, False])
        except: #for BOTH
            dff = dff.sort_values([&#39;CFD&#39;, &#39;Enriched&#39;], ascending = [False, False])
    else:
        try:
            dff = dff.sort_values(&#39;On-Targets Reference&#39;, ascending = True)
        except:
            dff = dff.sort_values(&#39;On-Targets Enriched&#39;, ascending = True)

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    return data_to_send, [{&#39;row&#39;:0, &#39;column&#39;:0}]</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table_sample">
              <code class="name flex">
                <span>def <span class="ident">update_table_sample</span></span
                >(<span
                  >page_current, page_size, sort_by, filter, search, hash)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;table-sample-target&#39;, &#39;data&#39;),
    [Input(&#39;table-sample-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-sample-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-sample-target&#39;, &#39;sort_by&#39;),
     Input(&#39;table-sample-target&#39;, &#39;filter_query&#39;)],
    [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]    
)
def update_table_sample(page_current, page_size, sort_by, filter, search, hash):
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    hash = hash.split(&#39;#&#39;)[1]
    guide = hash[:hash.find(&#39;-Sample-&#39;)]
    sample = hash[hash.rfind(&#39;-&#39;) + 1:]
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
        
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    dff = global_store_general(current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + &#39;.&#39; + sample + &#39;.&#39; + guide + &#39;.txt&#39;)
    if dff is None:
        raise PreventUpdate
    
    dff.rename(columns = COL_BOTH_RENAME , inplace = True)
    del dff[&#39;Correct Guide&#39;]         #NOTE Drop the Correct Guide column
    del dff[&#39;Variant Unique&#39;]
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )

    #Calculate sample count
    dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    for row in data_to_send:
        summarized_sample_cell = dict()
        for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
            if s == &#39;n&#39;:
                break
            try:
                summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
            except:
                summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
        if summarized_sample_cell:
            row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
        else:
            row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table_subset">
              <code class="name flex">
                <span>def <span class="ident">update_table_subset</span></span
                >(<span
                  >page_current, page_size, sort_by, filter, hide_reference,
                  search, hash_guide)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc">
                <p>
                  Function that returns the data to be shown in the 'Show
                  Targets' table of the Summary by Guide.
                </p>
                <p>
                  <strong><em>Args</em></strong>
                </p>
                <ul>
                  <li>
                    [<strong>page_current</strong>]
                    <strong>table-subset-target</strong>
                    (<em>page_current</em>): int of the current page to show
                  </li>
                  <li>
                    [<strong>page_size</strong>]
                    <strong>table-subset-target</strong> (<em>page_size</em>):
                    int of the maximum number of row for each page
                  </li>
                  <li>
                    [<strong>sort_by</strong>]
                    <strong>table-subset-target</strong> (<em>sort_by</em>):
                    list dictionaries of column IDs and sorting direction
                  </li>
                  <li>
                    [<strong>filter</strong>]
                    <strong>table-subset-target</strong>
                    (<em>filter_query</em>): list dictionaries for the data
                    filtering
                  </li>
                  <li>
                    [<strong>hide_reference</strong>]
                    <strong>hide-reference-targets</strong> (<em>value</em>): if
                    the value is not None, then the Reference targets are
                    removed from the shown data
                  </li>
                  <li>
                    [<strong>search</strong>]
                    <strong>url</strong> (<em>search</em>): string containing
                    the job ID, eg '?job=QV99PN6XDL'
                  </li>
                  <li>
                    [<strong>hash_guide</strong>]
                    <strong>url</strong> (<em>hash</em>): string containing the
                    informations about the selected 'Show Targets' row, eg
                    '#CCATCGGTGGCCGTTTGCCCNNNnewDNA10'
                  </li>
                </ul>
                <p>
                  <strong><em>Returns</em></strong>
                </p>
                <ul>
                  <li>
                    <strong>table-subset-target</strong> (<em>data</em>):
                    dictionary of the data to be shown
                  </li>
                </ul>
              </div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    Output(&#39;table-subset-target&#39;, &#39;data&#39;),
    [Input(&#39;table-subset-target&#39;, &#34;page_current&#34;),
     Input(&#39;table-subset-target&#39;, &#34;page_size&#34;),
     Input(&#39;table-subset-target&#39;, &#34;sort_by&#34;),
     Input(&#39;table-subset-target&#39;, &#39;filter_query&#39;),
     Input(&#39;hide-reference-targets&#39;, &#39;value&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;)]
)
def update_table_subset(page_current, page_size, sort_by, filter, hide_reference, search, hash_guide):
    &#39;&#39;&#39;
    Function that returns the data to be shown in the &#39;Show Targets&#39; table of the Summary by Guide. 

    ***Args***

    + [**page_current**] **table-subset-target** (*page_current*): int of the current page to show
    + [**page_size**] **table-subset-target** (*page_size*): int of the maximum number of row for each page
    + [**sort_by**] **table-subset-target** (*sort_by*): list dictionaries of column IDs and sorting direction
    + [**filter**] **table-subset-target** (*filter_query*): list dictionaries for the data filtering
    + [**hide_reference**] **hide-reference-targets** (*value*): if the value is not None, then the Reference targets are removed from the shown data
    + [**search**] **url** (*search*): string containing the job ID, eg &#39;?job=QV99PN6XDL&#39;
    + [**hash_guide**] **url** (*hash*): string containing the informations about the selected &#39;Show Targets&#39; row, eg &#39;#CCATCGGTGGCCGTTTGCCCNNNnewDNA10&#39;
    
    ***Returns***

    + **table-subset-target** (*data*): dictionary of the data to be shown
    
    &#39;&#39;&#39;
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]
    
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    value = job_id
    if search is None:
        raise PreventUpdate
    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    #filtering_expressions.append([&#39;{crRNA} = &#39; + guide])   
    guide = hash_guide[1:hash_guide.find(&#39;new&#39;)]
    mms = hash_guide[-1:]
    bulge_s = hash_guide[-2:-1]
    if &#39;DNA&#39; in hash_guide:
        bulge_t = &#39;DNA&#39;
    elif &#39;RNA&#39; in hash_guide:
        bulge_t = &#39;RNA&#39;
    else:
        bulge_t = &#39;X&#39;  
    df = global_store_subset(value, bulge_t, bulge_s, mms, guide)
    dff = df
    if genome_type == &#39;ref&#39;:
        dff.rename(columns = COL_REF_RENAME, inplace = True)
    else:
        dff.rename(columns = COL_BOTH_RENAME , inplace = True)

    if &#39;hide-ref&#39; in hide_reference or genome_type == &#39;var&#39;:
        dff.drop( df[(df[&#39;Samples&#39;] == &#39;n&#39;)].index, inplace = True)
    
    try:    #For VAR and BOTH
        del dff[&#39;Variant Unique&#39;]
    except: #For REF
        pass

    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)
        if col_name == &#39;Samples Summary&#39;:
            col_name = &#39;Samples&#39;
        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
   
    cells_style = [
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                            &#39;if&#39;: {
                                    &#39;filter_query&#39;: &#39;{Cluster Position} eq &#34;&#39; + guide + &#39;&#34;&#39;, 
                                    #&#39;column_id&#39; :&#39;{#Bulge type}&#39;,
                                    #&#39;column_id&#39; :&#39;{Total}&#39;
                                },
                                #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                                &#39;background-color&#39;:&#39;rgba(0, 0, 255,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                                
                        },
                        
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send#, cells_style + style_data_table</code></pre>
              </details>
            </dd>
            <dt id="crisprme_off.update_table_subsetSecondTable">
              <code class="name flex">
                <span
                  >def
                  <span class="ident"
                    >update_table_subsetSecondTable</span
                  ></span
                >(<span
                  >page_current, page_size, sort_by, filter, search, hash_guide,
                  active_cel, data)</span
                >
              </code>
            </dt>
            <dd>
              <div class="desc"></div>
              <details class="source">
                <summary>
                  <span>Expand source code</span>
                </summary>
                <pre><code class="python">@app.callback(
    [Output(&#39;second-table-subset-targets&#39;, &#39;data&#39;),                         #Table showing iupac scomposition
    Output(&#39;second-table-subset-targets&#39;, &#39;style_data_conditional&#39;)],
    [Input(&#39;second-table-subset-targets&#39;, &#34;page_current&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#34;page_size&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#34;sort_by&#34;),
     Input(&#39;second-table-subset-targets&#39;, &#39;filter_query&#39;)],
     [State(&#39;url&#39;, &#39;search&#39;),
     State(&#39;url&#39;, &#39;hash&#39;),
     State(&#39;table-subset-target&#39;, &#39;active_cell&#39;),
    State(&#39;table-subset-target&#39;, &#39;data&#39;)]
)
def update_table_subsetSecondTable(page_current, page_size, sort_by, filter, search, hash_guide, active_cel, data):
    #NOTE tabella secondaria della scomposizione ora non serve, non cancello il codice ma uso PreventUpdate per non azionare la funzione
    if False:
        raise PreventUpdate
    if active_cel is None:
        raise PreventUpdate
    job_id = search.split(&#39;=&#39;)[-1]
    job_directory = current_working_directory + &#39;Results/&#39; + job_id + &#39;/&#39;
    with open(current_working_directory + &#39;Results/&#39; + job_id + &#39;/Params.txt&#39;) as p:
        all_params = p.read()
        genome_type_f = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Genome_selected&#39; in s)).split(&#39;\t&#39;)[-1]
        ref_comp = (next(s for s in all_params.split(&#39;\n&#39;) if &#39;Ref_comp&#39; in s)).split(&#39;\t&#39;)[-1]

    guide = hash_guide[1:hash_guide.find(&#39;new&#39;)]
    genome_type = &#39;ref&#39;
    if &#39;+&#39; in genome_type_f:
        genome_type = &#39;var&#39;
    if &#39;True&#39; in ref_comp:
        genome_type = &#39;both&#39;
    if search is None:
        raise PreventUpdate

    if genome_type == &#39;ref&#39;:
        raise PreventUpdate    

    filtering_expressions = filter.split(&#39; &amp;&amp; &#39;)
    bulge_t =  data[active_cel[&#39;row&#39;]][&#39;Bulge Type&#39;]
    bulge_s = str(data[active_cel[&#39;row&#39;]][&#39;Bulge Size&#39;])
    mms = str(data[active_cel[&#39;row&#39;]][&#39;Mismatches&#39;])
    chrom = str(data[active_cel[&#39;row&#39;]][&#39;Chromosome&#39;])
    pos = str(data[active_cel[&#39;row&#39;]][&#39;Cluster Position&#39;])
    # annotation_type = str(data[active_cel[&#39;row&#39;]][&#39;Annotation Type&#39;])

    scomposition_file = job_directory + job_id + &#39;.&#39; + bulge_t + &#39;.&#39; + bulge_s + &#39;.&#39; + mms + &#39;.&#39; + guide + &#39;.&#39; + chrom + &#39;.&#39; + pos + &#39;.scomposition.txt&#39;
    file_to_grep = &#39;.samples.annotation.txt&#39;

    if not os.path.exists(scomposition_file):    #Example    job_id.X.0.4.GUIDE.chrom.position.scomposition.txt
        # subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + pos + &#39; &amp;&amp; $4==\&#34;&#39; + chrom + &#39;\&#34; &amp;&amp; $8==&#39; + mms + &#39; &amp;&amp; $9==&#39; + bulge_s +&#39;\&#39; &gt; &#39; + scomposition_file], shell = True)
        subprocess.call([&#39;LC_ALL=C grep -F &#39; + guide + &#39; &#39; + current_working_directory + &#39;Results/&#39;+ job_id + &#39;/&#39; + job_id + file_to_grep + &#39; |  awk \&#39;$6==&#39; + pos + &#39; &amp;&amp; $4==\&#34;&#39; + chrom + &#39;\&#34; &amp;&amp; $9==&#39; + bulge_s + &#39; &amp;&amp; $13!=\&#34;n\&#34;&#39; +&#39;\&#39; &gt; &#39; + scomposition_file], shell = True)
    
    if os.path.getsize(scomposition_file) &gt; 0:          #Check if result grep has at least 1 result
        df = pd.read_csv(scomposition_file, header = None, sep = &#39;\t&#39;)
        # df[&#39;Annotation Type&#39;] = annotation_type
    else:
        raise PreventUpdate
     
    df.rename(columns = COL_BOTH_RENAME , inplace = True)
    df.drop(df[(~( df[&#39;Cluster Position&#39;] == int(data[active_cel[&#39;row&#39;]][&#39;Cluster Position&#39;]))) | (~( df[&#39;Chromosome&#39;] == data[active_cel[&#39;row&#39;]][&#39;Chromosome&#39;]))].index, inplace = True)
    dff = df
    
    for filter_part in filtering_expressions:
        col_name, operator, filter_value = split_filter_part(filter_part)

        if operator in (&#39;eq&#39;, &#39;ne&#39;, &#39;lt&#39;, &#39;le&#39;, &#39;gt&#39;, &#39;ge&#39;):
            # these operators match pandas series operator method names
            dff = dff.loc[getattr(dff[col_name], operator)(filter_value)]
        elif operator == &#39;contains&#39;:
            dff = dff.loc[dff[col_name].str.contains(filter_value)]
        elif operator == &#39;datestartswith&#39;:
            # this is a simplification of the front-end filtering logic,
            # only works with complete fields in standard format
            dff = dff.loc[dff[col_name].str.startswith(filter_value)]

    if len(sort_by):
        dff = dff.sort_values(
            [&#39;Samples&#39; if col[&#39;column_id&#39;] == &#39;Samples Summary&#39; else col[&#39;column_id&#39;] for col in sort_by],
            ascending=[
                col[&#39;direction&#39;] == &#39;asc&#39;
                for col in sort_by
            ],
            inplace=False
        )
   

    cells_style = [
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Variant Unique} eq y&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        {
                        &#39;if&#39;: {
                                &#39;filter_query&#39;: &#39;{Variant Unique} eq F&#39;,
                                #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                                #&#39;column_id&#39; :&#39;Bulge Type&#39;
                            },
                            #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                            &#39;background-color&#39;:&#39;rgba(0, 0, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                        }
                        # {
                        # &#39;if&#39;: {
                        #         &#39;filter_query&#39;: &#39;{Chromosome} eq &#34;chr2&#34;&#39;,
                        #         #&#39;filter_query&#39;: &#39;{Direction} eq +&#39;, 
                        #         #&#39;column_id&#39; :&#39;Bulge Type&#39;
                        #     },
                        #     #&#39;border-left&#39;: &#39;5px solid rgba(255, 26, 26, 0.9)&#39;, 
                        #     &#39;background-color&#39;:&#39;rgba(255, 69, 0,0.15)&#39;#&#39;rgb(255, 102, 102)&#39;
                            
                        # },
                        # {
                        #     &#39;if&#39;: {
                        #             &#39;filter_query&#39;: &#39;{Variant Unique} eq n&#39;,           
                        #             &#39;column_id&#39; :&#39;Bulge Type&#39;
                        #         },
                        #         &#39;border-left&#39;: &#39;5px solid rgba(26, 26, 255, 0.9)&#39;,

                        # }
                        
                ]
    
    #Calculate sample count
    
    data_to_send=dff.iloc[
        page_current*page_size:(page_current+ 1)*page_size
    ].to_dict(&#39;records&#39;)
    if genome_type != &#39;ref&#39;:
        dict_sample_to_pop, dict_pop_to_superpop = associateSample.loadSampleAssociation(job_directory + &#39;sampleID.txt&#39;)[:2]
        for row in data_to_send:
            summarized_sample_cell = dict()
            for s in row[&#39;Samples&#39;].split(&#39;,&#39;):
                if s == &#39;n&#39;:
                    break
                try:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] += 1
                except:
                    summarized_sample_cell[dict_pop_to_superpop[dict_sample_to_pop[s]]] = 1
            if summarized_sample_cell:
                row[&#39;Samples Summary&#39;] = &#39;, &#39;.join([str(summarized_sample_cell[sp]) + &#39; &#39; + sp for sp in summarized_sample_cell])
            else:
                row[&#39;Samples Summary&#39;] = &#39;n&#39;
    return data_to_send, cells_style</code></pre>
              </details>
            </dd>
          </dl>
        </section>
        <section></section>
      </article>
      <nav id="sidebar">
        <h1>Index</h1>
        <div class="toc">
          <ul></ul>
        </div>
        <ul id="index">
          <li>
            <h3><a href="#header-functions">Functions</a></h3>
            <ul class="">
              <li>
                <code
                  ><a
                    title="crisprme_off.add_genome"
                    href="#crisprme_off.add_genome"
                    >add_genome</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.availableGenomes"
                    href="#crisprme_off.availableGenomes"
                    >availableGenomes</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.availablePAM"
                    href="#crisprme_off.availablePAM"
                    >availablePAM</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.changePage"
                    href="#crisprme_off.changePage"
                    >changePage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.changeUrl"
                    href="#crisprme_off.changeUrl"
                    >changeUrl</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.change_annotation"
                    href="#crisprme_off.change_annotation"
                    >change_annotation</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.checkEmailValidity"
                    href="#crisprme_off.checkEmailValidity"
                    >checkEmailValidity</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.checkInput"
                    href="#crisprme_off.checkInput"
                    >checkInput</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.clusterPage"
                    href="#crisprme_off.clusterPage"
                    >clusterPage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.colorSelectedRow"
                    href="#crisprme_off.colorSelectedRow"
                    >colorSelectedRow</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.downloadLinkGuide"
                    href="#crisprme_off.downloadLinkGuide"
                    >downloadLinkGuide</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.downloadLinkPosition"
                    href="#crisprme_off.downloadLinkPosition"
                    >downloadLinkPosition</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.downloadLinkSample"
                    href="#crisprme_off.downloadLinkSample"
                    >downloadLinkSample</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogAnnotation"
                    href="#crisprme_off.fileDialogAnnotation"
                    >fileDialogAnnotation</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogPam"
                    href="#crisprme_off.fileDialogPam"
                    >fileDialogPam</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogRefGenome"
                    href="#crisprme_off.fileDialogRefGenome"
                    >fileDialogRefGenome</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogSamplesID"
                    href="#crisprme_off.fileDialogSamplesID"
                    >fileDialogSamplesID</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogUpdateAnnotation"
                    href="#crisprme_off.fileDialogUpdateAnnotation"
                    >fileDialogUpdateAnnotation</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.fileDialogVCF"
                    href="#crisprme_off.fileDialogVCF"
                    >fileDialogVCF</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.filterPositionTable"
                    href="#crisprme_off.filterPositionTable"
                    >filterPositionTable</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.filterSampleTable"
                    href="#crisprme_off.filterSampleTable"
                    >filterSampleTable</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.generate_table"
                    href="#crisprme_off.generate_table"
                    >generate_table</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.generate_table_position"
                    href="#crisprme_off.generate_table_position"
                    >generate_table_position</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.generate_table_results"
                    href="#crisprme_off.generate_table_results"
                    >generate_table_results</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.generate_table_samples"
                    href="#crisprme_off.generate_table_samples"
                    >generate_table_samples</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.get_results"
                    href="#crisprme_off.get_results"
                    >get_results</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.global_store"
                    href="#crisprme_off.global_store"
                    >global_store</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.global_store_general"
                    href="#crisprme_off.global_store_general"
                    >global_store_general</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.global_store_subset"
                    href="#crisprme_off.global_store_subset"
                    >global_store_subset</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.guidePagev3"
                    href="#crisprme_off.guidePagev3"
                    >guidePagev3</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.historyPage"
                    href="#crisprme_off.historyPage"
                    >historyPage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.inExample"
                    href="#crisprme_off.inExample"
                    >inExample</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.indexPage"
                    href="#crisprme_off.indexPage"
                    >indexPage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.loadDistributionPopulations"
                    href="#crisprme_off.loadDistributionPopulations"
                    >loadDistributionPopulations</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.loadFullSubsetTable"
                    href="#crisprme_off.loadFullSubsetTable"
                    >loadFullSubsetTable</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.openDialog"
                    href="#crisprme_off.openDialog"
                    >openDialog</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.openResultDirectory"
                    href="#crisprme_off.openResultDirectory"
                    >openResultDirectory</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.parse_contents"
                    href="#crisprme_off.parse_contents"
                    >parse_contents</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.refreshSearch"
                    href="#crisprme_off.refreshSearch"
                    >refreshSearch</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.removeJobIDandFilter"
                    href="#crisprme_off.removeJobIDandFilter"
                    >removeJobIDandFilter</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.resetTab"
                    href="#crisprme_off.resetTab"
                    >resetTab</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.resultPage"
                    href="#crisprme_off.resultPage"
                    >resultPage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.samplePage"
                    href="#crisprme_off.samplePage"
                    >samplePage</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.selectSameLenGuides"
                    href="#crisprme_off.selectSameLenGuides"
                    >selectSameLenGuides</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.split_filter_part"
                    href="#crisprme_off.split_filter_part"
                    >split_filter_part</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.startAddNewGenome"
                    href="#crisprme_off.startAddNewGenome"
                    >startAddNewGenome</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.suggestComparison"
                    href="#crisprme_off.suggestComparison"
                    >suggestComparison</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.supportFilterHistory"
                    href="#crisprme_off.supportFilterHistory"
                    >supportFilterHistory</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.test_page"
                    href="#crisprme_off.test_page"
                    >test_page</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.toggleCollapseDistributionPopulations"
                    href="#crisprme_off.toggleCollapseDistributionPopulations"
                    >toggleCollapseDistributionPopulations</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.toggle_fade"
                    href="#crisprme_off.toggle_fade"
                    >toggle_fade</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateContentTab"
                    href="#crisprme_off.updateContentTab"
                    >updateContentTab</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateGenomePageTable"
                    href="#crisprme_off.updateGenomePageTable"
                    >updateGenomePageTable</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateHistoryFilter"
                    href="#crisprme_off.updateHistoryFilter"
                    >updateHistoryFilter</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateImagesTabs"
                    href="#crisprme_off.updateImagesTabs"
                    >updateImagesTabs</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updatePopulationDrop"
                    href="#crisprme_off.updatePopulationDrop"
                    >updatePopulationDrop</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updatePositionFilter"
                    href="#crisprme_off.updatePositionFilter"
                    >updatePositionFilter</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateSampleDrop"
                    href="#crisprme_off.updateSampleDrop"
                    >updateSampleDrop</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateSampleFilter"
                    href="#crisprme_off.updateSampleFilter"
                    >updateSampleFilter</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.updateStatusCreateNewGenome"
                    href="#crisprme_off.updateStatusCreateNewGenome"
                    >updateStatusCreateNewGenome</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_dict"
                    href="#crisprme_off.update_dict"
                    >update_dict</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_iupac_scomposition_table_cluster"
                    href="#crisprme_off.update_iupac_scomposition_table_cluster"
                    >update_iupac_scomposition_table_cluster</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table"
                    href="#crisprme_off.update_table"
                    >update_table</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table_cluster"
                    href="#crisprme_off.update_table_cluster"
                    >update_table_cluster</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table_general_profile"
                    href="#crisprme_off.update_table_general_profile"
                    >update_table_general_profile</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table_sample"
                    href="#crisprme_off.update_table_sample"
                    >update_table_sample</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table_subset"
                    href="#crisprme_off.update_table_subset"
                    >update_table_subset</a
                  ></code
                >
              </li>
              <li>
                <code
                  ><a
                    title="crisprme_off.update_table_subsetSecondTable"
                    href="#crisprme_off.update_table_subsetSecondTable"
                    >update_table_subsetSecondTable</a
                  ></code
                >
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </main>
    <footer id="footer">
      <p>
        Generated by
        <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.
      </p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
  </body>
</html>
